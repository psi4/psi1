      subroutine fentry(z,iz,maxcor)
C
C    GES VERSION: MAY 6, 1987
C
C    CC SYMM GRADS
C
C**********************************************************************
C SORT FOR CCSD GRADIENT WRITTEN BY JULIA RICE                       **
C MODIFIED BY GUSTAVO SCUSERIA FOR SYMMETRY (NON-C1) CASES.          **
C**********************************************************************
C
C**********************************************************************
C*   NOTICE OF PROGRAM MODIFICATION                                   *
C**********************************************************************
C*  BY:  Curtis Janssen                          Key: clj022589       *
C*  DATE:  2/25/89                                                    *
C*  REASON: Put in run time core allocation.                          *
C**********************************************************************
C*  BY:  Curtis Janssen                          Key: clj020489       *
C*  DATE:  2/4/89                                                     *
C*  REASON: Take out external reference to IND                        *
C**********************************************************************
c Moved to PSI area on 2/4/89 by clj.
C**********************************************************************
C*  BY:  RICHARD REMINGTON                         search:  c5-22-88  *
C*  DATE:  MAY   22,   1988                                           *
C*  REASON: DECREASE CORE TO RUN IN 7MB ON 9370                       *
C**********************************************************************
C   NOTICE OF PROGRAM MODIFICATION                                    *
C      BY:  TJL                                                       *
C    DATE:  DECEMBER 15, 1985                                         *
C  REASON:  PUT ON HEADER                                             *
C**********************************************************************
C
      REAL*8 Z(maxcor)
      INTEGER IZ(1)
      COMMON /TAPES/ IT58,IT91,IT68,IT78,IT52,IT53
clj022589      EQUIVALENCE (IZ(1), Z(1))
C
 6000 FORMAT(//,46('-'),/,46('-'),/,
     .' THE CCTODRT SYMMETRY COUPLED CLUSTER  PROGRAM',/,
     .'           GES VERSION: MAY 6, 1987)   ',/,46('-'),/,46('-'),//)
 1000 FORMAT(///,10X,' >>>>> SORT OF INTEGRALS, ONE AND TWOPDM ',
     1   'COMPLETED <<<<< ')
C
clj022589      MAXCOR=500000
C
      CALL TSTART(3)
      CALL TSTART(6)
      CALL NOUNFL
      WRITE(6,6000)
C
      CALL MAINU(IZ,Z,MAXCOR)
C
C
      WRITE(6,1000)
C
      CALL TSTOP(3)
      CALL TSTOP(6)
C
      STOP
      END
C=================================================================
C==================================================================
      SUBROUTINE MAINU(IZ,Z,MAXCOR)
      IMPLICIT INTEGER(A-Z)
      REAL*8 Z(MAXCOR),ZZ,DRTVER,VAL
      DIMENSION I30 (200)
      INTEGER NLAMDA(8),NC(8),PTOCC(500),IORD(500)
      REAL *8 EIG(500),WTEMP(500)
      COMMON /TAPES/ IT58,IT91,IT68,IT78,IT52,IT53
      COMMON/DIMS/NIJ,NBF,NMPB,LMPB,ISYMRB,NUMIJ,NORBS,NMAX,NDF,IX,NGRP
      COMMON/SRTMP/VAL,IADR,IBKT,NBKT
      COMMON/BIGM/IBIG,IBIG2,BKTSZ2,BKTSZ
      LOGICAL LINTS
      DIMENSION IZ(*)
      DIMENSION IA47(192)
CTJL  EQUIVALENCE(Z,IZ)
CTJL  CALL NOUNFL
      MAXR=MAXCOR
      IT68=68
      IT58=58
      IT91=91
      IT78=78
      IT52=52
      IT53=53
      CALL RFILE(IT68)
      CALL RFILE(IT91)
      CALL RFILE(IT58)
CJ
CJ
C
C     ----- READ DIMENSIONS FROM DRT TAPE -----
C
      CALL WREADW(IT58,DRTVER,INTOWP(1),1,END)
CJ    CALL WREADW(IT58,LBLDRT,26,END,END)
      END=END+26
      CALL WREADW(IT58,NBF,1,END,END)
      CALL WREADW(IT58,NSYM,1,END,END)
      CALL WREADW(IT58,NORBS,1,END,END)
      CALL WREADW(IT58,NROWS,1,END,END)
      CALL WREADW(IT58,NROWS4,1,END,END)
      CALL WREADW(IT58,NLEVS,1,END,END)
      CALL WREADW(IT58,NREFS,1,END,END)
      CALL WREADW(IT58,NROWOC,1,END,END)
      CALL WREADW(IT58,NROW4O,1,END,END)
      CALL WREADW(IT58,NWKS,1,END,END)
      CALL WREADW(IT58,NEWSOC,1,END,END)
      CALL WREADW(IT58,NLEVOC,1,END,END)
      CALL WREADW(IT58,LFERM,1,END,END)
CJ    PRINT *,' LFERM'
CJ    WRITE(6,*) LFERM
      CALL WREADW(IT58,ISYMRB,1,END,END)
      CALL WREADW(IT58,NUMIJ,1,END,END)
      CALL WREADW(IT58,NGRP,1,END,END)
      CALL WREADW(IT58,NUMINT,1,END,END)
      CALL WREADW(IT58,NMAX,1,END,END)
      CALL WREADW(IT58,BMAX,1,END,END)
      END=END+2
      WRITE(6,2001) DRTVER
 2001 FORMAT(/1X,'DRTVER  = ',F10.6)
      WRITE(6,2003)NBF,NSYM,NORBS,NROWS,NMAX,NUMIJ,NGRP,ISYMRB
 2003 FORMAT( 1X,'NBF     = ',I8/
     1       ,1X,'NSYM    = ',I8/
     2       ,1X,'NORBS   = ',I8/
     3       ,1X,'NROWS   = ',I8/
     4       ,1X,'NMAX    = ',I8/
     5       ,1X,'NUMIJ   = ',I8/
     6       ,1X,'NGROUP  = ',I8/
     7       ,1X,'ISYMRB  = ',I8/)
COUT  WRITE(6,1002)LBLDRT
 1002 FORMAT(/,1X,'LABEL FROM DRT :   ',26A3)
      NIJ=NBF*(NBF+1)/2
CJ    WRITE(6,*) NIJ,NBF,MAXR
      KADD = 1
      LADD=KADD+ISYMRB
      IJADD=LADD+ISYMRB
      IJGRP=IJADD+NUMIJ
      ORBSYM=IJGRP+NUMIJ
      IOUT=ORBSYM+NORBS
      JCODED=IOUT+NBF
      CALL GETDRX(IZ(KADD),IZ(LADD),IZ(IJADD),IZ(IJGRP),
     1    IZ(ORBSYM),IZ(JCODED),IZ(IOUT),END)
      BKTSZ=4096
      BKTSZ2=INTOWP(BKTSZ)
      MAXBKT=500
      INTOFF=JCODED+NORBS
      START=INTOFF+MAXBKT
      ILAST=START+MAXBKT
      BKTPNT=ILAST+MAXBKT
      BUF=IADTWP(BKTPNT+MAXBKT)
C
      BUFSZ=SEC2I(100)/INTOWP(1)
C
      IBUF=WPADTI(BUF)
      FINTS=BUF+BKTSZ
      TOUT=BUF+BUFSZ
      ITOUT=WPADTI(TOUT)
      SPACE=MAXR-FINTS
      SPACE2=MAXR-TOUT
      NMPB=SPACE/NMAX
      IF(NMPB.EQ.0) THEN
        WRITE(6,111) SPACE,NMAX
111   FORMAT(/' NOT ENOUGH SPACE FOR DRT SORT, HAVE ',I8,
     1  ' WORDS, REQUIRE ',I8,' WORDS')
        CALL MABORT
      END IF
      IF(NMPB.GT.NGRP)NMPB=NGRP
      LENR=NMPB*NMAX
      NBKT=NGRP/NMPB
      LMPB=NGRP-(NBKT*NMPB)
      IF(LMPB.NE.0) THEN
         NBKT=NBKT+1
      ELSE
         LMPB=NMPB
      END IF
CJ    WRITE(6,*) ' NBKT,NMPB ' , NBKT,NMPB
      IF(NBKT.GT.MAXBKT) THEN
        WRITE(6,2701)NBKT,MAXBKT
2701  FORMAT(/' NBKT = ',I5,'  MAXBKT = ',I5,' INCREASE CORE OR MAXBKT')
          CALL MABORT
      END IF
CJ    WRITE(6,*) SPACE2,NBKT,BKTSZ
      IF(NBKT*BKTSZ.GT.SPACE2) THEN
        WRITE(6,2700)
2700  FORMAT( ' NOT ENOUGH STORE  ',
     1         '- INCREASE STORE OR DECREASE BUCKET SIZE')
           CALL MABORT
      END IF
      IBIG2=BKTSZ*NBKT
      IBIG=INTOWP(IBIG2)
      ITOP1=FINTS+LENR
CJ    WRITE(6,*) ' ITOP1 ',ITOP1
C
CGES  OPEN 68, READ ONE- AND TWO-PDM, SORT THEM TO DRT AND WRITE TO 53
C
      ITAP30=30
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I30,200,101,LWORD)
      MPOINT=I30(2)
      MCONST=I30(3)
      MCALCS=I30(4)
      NCALCS=I30(5)
      NT=I30(18)
      NBFAO=I30(22)
      NIRRED=I30(28)
      NSYMHF=I30(41)
      MXCOEF=I30(42)
C
      JPOINT = 101 + MCONST + MPOINT
      CALL WREADW (ITAP30,I30,MCALCS,JPOINT,JPOINT)
      LOCCAL = I30(NCALCS)
      JPOINT = LOCCAL + 60
      CALL WREADW (ITAP30,LOCVEC,1,JPOINT,JPOINT)
      LOCVEC=LOCVEC+INTOWP(MXCOEF)
      CALL WREADW (ITAP30,EIG,INTOWP(NT),LOCVEC,LOCVEC)
COUT  WRITE(*,*)'ORDERING FROM FILE30'
COUT  DO 151 I=1,NT
COUT  WRITE(*,*)'I ',I,' EIG(I) ',EIG(I)
  151 CONTINUE
C     WRITE(*,*)EIG
C     CALL WREADW (ITAP30,ITYP,NSYMHF,LOCVEC,LOCVEC)
      LOCVEC = LOCVEC + NSYMHF
C     WRITE(*,*) ' LOCVEC,MXCOEF = ',LOCVEC,MXCOEF
      CALL WREADW (ITAP30,NLAMDA,NSYMHF,LOCVEC,LOCVEC)
      CALL WREADW (ITAP30,NC,NSYMHF,LOCVEC,LOCVEC)
      NO=0
      DO 555 I=1,NSYMHF
         NO=NO+NC(I)
COUT     WRITE (6,*) ' I,NC=',I,NC(I)
  555 CONTINUE
      ICNT=0
      IOF = 0
      DO 558 I=1,NSYMHF
      IF(I.NE.1) IOF = IOF + NLAMDA(I-1)
      NOI=NC(I)
      DO 557 J=1,NOI
      ICNT=ICNT+1
      IPT=IOF+J
C     WRITE(6,*)'IPT=',IPT,ICNT
  557 PTOCC(IPT)=ICNT
  558 CONTINUE
C     WRITE(*,*) '  VIRTUALS'
      IOF = 0
      DO 658 I=1,NSYMHF
      IF(I.NE.1) IOF = IOF + NLAMDA(I-1)
      NVI=NLAMDA(I)-NC(I)
      DO 657 J=1,NVI
      ICNT=ICNT+1
      IPT=IOF+NC(I) + J
C     WRITE(6,*) IOF,NC(I),J
C     WRITE(6,*)'IPT=',IPT,ICNT
  657 PTOCC(IPT)=ICNT
  658 CONTINUE
      DO 551 I=1,NT
      IPT=PTOCC(I)
  551 WTEMP(IPT)=EIG(I)
      DO 553 J=1,NT
  553 EIG(J)=WTEMP(J)
      DO 552 I=1,NT
      IJ=PTOCC(I)
  552 IORD(IJ)=I
COUT  WRITE(*,*)'CC ORDERING'
      DO 152 I=1,NT
      PTOCC(I)=I
COUT  WRITE(*,*)'I',I,' EIG(I) ',EIG(I),' IORD(I)',IORD(I)
  152 CONTINUE
  210 IFK=0
      I=0
  220 I=I+1
      IF(EIG(I).GT.EIG(I+1))THEN
      VAL=EIG(I)
      EIG(I)=EIG(I+1)
      EIG(I+1)=VAL
      IDU=IORD(I)
      IORD(I)=IORD(I+1)
      IORD(I+1)=IDU
      IDU=PTOCC(I)
      PTOCC(I)=PTOCC(I+1)
      PTOCC(I+1)=IDU
      IFK=1
      ENDIF
  222 CONTINUE
      IF(I.LT.(NBF-1))GO TO 220
      IF(IFK.EQ.1)GO TO 210
COUT  WRITE(*,*)'C1 ORDERING (STILL NOT DRT)'
      DO 153 I=1,NT
COUT  WRITE(*,668)I, EIG(I),IORD(I), PTOCC(I)
  153 CONTINUE
  668 FORMAT(1X,'I=',I4,'  EIG(I)=',F12.8,'  IORD=',I4,'  PTOCC=',I4)
C
C     PTOCC CONTAINS THE SYMMETRY CC TO C1 TRANSFORMATION ARRAY
C     THE INVERSE IS NOW CALCULATED AN LATER USED WITH IOUT
C
      DO 559 I=1,NT
      IJ=PTOCC(I)
  559 IORD(IJ)=I
C
      LINTS=.FALSE.
      CALL CIDINT(IZ(KADD),IZ(LADD),IZ(IJADD),
     1   IZ(ORBSYM),IZ(IJGRP),IZ(BKTPNT),IZ(START),IZ(ILAST),
     2   Z(TOUT),IZ(ITOUT),IZ(INTOFF),Z(BUF),IZ(IBUF),LINTS,BUFSZ,
     3   IZ(JCODED),IZ(IOUT),IORD)
      CALL RCLOSE(IT68,3)
      CALL RFILE(IT53)
      CALL CID1(Z(BUF),IZ(IBUF),Z(FINTS),LENR,IZ(INTOFF),IZ(ILAST),
     1   IZ(IJGRP),NBKT,LINTS)
      JCODE=3
      CALL RCLOSE(IT53,JCODE)
C
CGES  OPEN 78, READ ONE- AND TWO-INT, SORT THEM TO DRT AND WRITE TO 52
C
      CALL RFILE(IT78)
      LINTS=.TRUE.
      CALL CIDINT(IZ(KADD),IZ(LADD),IZ(IJADD),
     1   IZ(ORBSYM),IZ(IJGRP),IZ(BKTPNT),IZ(START),IZ(ILAST),
     2   Z(TOUT),IZ(ITOUT),IZ(INTOFF),Z(BUF),IZ(IBUF),LINTS,BUFSZ,
     3   IZ(JCODED),IZ(IOUT),IORD)
      CALL RFILE(IT52)
      CALL CID1(Z(BUF),IZ(IBUF),Z(FINTS),LENR,IZ(INTOFF),IZ(ILAST),
     1   IZ(IJGRP),NBKT,LINTS)
      JCODE=3
      CALL RCLOSE(IT52,JCODE)
      CALL RCLOSE(IT58,JCODE)
      CALL RCLOSE(IT78,JCODE)
      JCODE=4
      CALL RCLOSE(IT91,JCODE)
      RETURN
      END
      SUBROUTINE CID1(BUF,IBUF,FINTS,LENR,INTOFF,ILAST,IJGRP,NBKT,LINTS)
      IMPLICIT REAL*8(A-H,O-Z)
      INTEGER BKTSZ,BKTSZ2
      LOGICAL LINTS
      COMMON /TAPES/ IT58,IT91,IT68,IT78,IT52,IT53
      COMMON/DIMS/NIJ,NBF,NMPB,LMPB,ISYMRB,NUMIJ,NORBS,NMAX,NDF,IX,NGRP
      DIMENSION BUF(BKTSZ),IBUF(2*BKTSZ),FINTS(1),INTOFF(1),ILAST(1)
      DIMENSION IJGRP(1)
      COMMON/BIGM/IBIG,IBIG2,BKTSZ2,BKTSZ
      ITXXX=IT91
      ITAPNN=IT53
      IF(LINTS) ITAPNN=IT52
CJ    WRITE(6,*) ' ITAPNN ',ITAPNN
      CALL SREW(ITAPNN)
CJ    PRINT *,' ENTERED CID1',LENR
      CALL SREW(ITAPNN)
      DO 15 IGRP=1,NBKT
      CALL ZERO(FINTS,LENR)
      IADR=ILAST(IGRP)
CJ    WRITE(6,*) IADR
       IF(IADR.EQ.-1) GO TO 11
       IF(IADR.LT.-1) THEN
          PRINT*,' FOR IGRP ',IGRP,' IADR = ',IADR
          STOP
      END IF
10    CALL RREAD(ITXXX,IBUF,BKTSZ2,IADR)
      IADR=IBUF(1)
      NUM=IBUF(2)
CJ    WRITE(6,*) ' IBUF ',(IBUF(JKI),JKI=1,28)
CJ    PRINT *,' IADR,NUM'
CJ    WRITE(6,*) IADR,NUM
      DO 70 I=1,NUM
CJ    WRITE(6,*) ' FINTS ',IBUF(I+2)
CJ    WRITE(6,*) ' INTOFF ',I,INTOFF(1)
70    FINTS(IBUF(I+2))=FINTS(IBUF(I+2))+BUF(I+INTOFF(1))
11    CONTINUE
      IF(IADR.NE.-1) GO TO 10
CJ    WRITE(6,*) ' LMPB' , LMPB
      LSMPB=NMPB
      IF (IGRP.EQ.NBKT) LSMPB=LMPB
      DO 35 IR=1,LSMPB
      CALL SWRIT(ITAPNN,FINTS(1+(IR-1)*NMAX),INTOWP(NMAX))
CJ    WRITE(6,*) ' FINTS ',(FINTS(JKI),JKI=1,NMAX)
35    CONTINUE
15    CONTINUE
      CALL SREW(ITAPNN)
      CALL ZERO(FINTS,NMAX)
      CALL SREAD(ITAPNN,FINTS,INTOWP(NMAX))
CJ    WRITE(6,*) ' FINTS ROUND 2 ',(FINTS(JKI),JKI=1,NMAX)
      RETURN
      END
      SUBROUTINE GETDRX(KADD,LADD,IJADD,IJGRP,ORBSYM,JCODED,IOUT,
     1 END)
      IMPLICIT INTEGER (A-Z)
C
C
      COMMON /TAPES/ IT58,IT91,IT68,IT78,IT52,IT53
      COMMON/DIMS/NIJ,NBF,NMPB,LMPB,ISYMRB,NUMIJ,NORBS,NMAX,NDF,IX,NGRP
      DIMENSION KADD(ISYMRB),LADD(ISYMRB),IJADD(NUMIJ),IJGRP(NUMIJ)
      DIMENSION ORBSYM(NORBS),JCODED(NORBS),IOUT(NBF)
      CALL WREADW(IT58,KADD,ISYMRB,END,END)
      CALL WREADW(IT58,LADD,ISYMRB,END,END)
      CALL WREADW(IT58,IJADD,NUMIJ,END,END)
      CALL WREADW(IT58,IJGRP,NUMIJ,END,END)
      END=END+4*NORBS+NGRP
      CALL WREADW(IT58,IOUT,NBF,END,END)
COUT  WRITE(6,*) ' IOUT ',IOUT
      CALL WREADW(IT58,ORBSYM,NORBS,END,END)
      END=END+NBF
      CALL WREADW(IT58,JCODED,NBF,END,END)
C     PRINT*,' ORBSYM= ',ORBSYM
C     PRINT*,' LADD= ',LADD
C     PRINT*,' KADD= ',KADD
C     PRINT*,' IJADD= ',IJADD
      RETURN
      END
      SUBROUTINE CIDINT(KADD,LADD,IJADD,ORBSYM,IJGRP,
     1 BKTPNT,START,ILAST,TOUT,ITOUT,INTOFF,BUF,IBUF,LINTS,BUFSZ,JCODED,
     2 IOUT,IORD)
      IMPLICIT REAL*8(A-H,O-Z)
      INTEGER ORBSYM,BKTSZ,BKTSZ2,BKTPNT,START,BUFSZ
      LOGICAL LINTS
      COMMON /TAPES/ IT58,IT91,IT68,IT78,IT52,IT53
      COMMON/DIMS/NIJ,NBF,NMPB,LMPB,ISYMRB,NUMIJ,NORBS,NMAX,NDF,IX,NGRP
      COMMON/SRTMP/VAL,IADR,IBKT,NBKT
      COMMON/BIGM/IBIG,IBIG2,BKTSZ,BKTSZ2
      DIMENSION START(1),BKTPNT(1),ILAST(1),TOUT(2),ITOUT(1),INTOFF(1)
      DIMENSION KADD(ISYMRB),LADD(ISYMRB),IJADD(NUMIJ),ORBSYM(NORBS)
      DIMENSION IJGRP(NUMIJ),MULTS(8),LKUPSM(64)
      DIMENSION BUF(BUFSZ),IBUF(2),JCODED(NORBS)
      DIMENSION ITYP(9),IOUT(NBF),IORD(NBF)
C
      DATA ITEMP /255/
      DATA MULTS/0,8,16,24,32,40,48,56/
      DATA LKUPSM/1,2,3,4,5,6,7,8,2,1,4,3,6,5,8,7,3,4,1,2,7,8,5,6,4,3,
     A2,1,8,7,6,5,5,6,7,8,1,2,3,4,6,5,8,7,2,1,4,3,7,8,5,6,3,4,1,2,
     B8,7,6,5,4,3,2,1/
clj020489 Put the IND inline function back in.
      IND(I,J)=MAX(I,J)*(MAX(I,J)-1)/2+MIN(I,J)
C
      TOL=1.0D-20
      ITXXX=IT91
      IF (LINTS) THEN
         FAC1=1.0D0
         ITAPNN=IT78
         FAC2=1.0D0
      ELSE
         CALL IZERO(ITYP,9)
         ITAPNN=IT68
         FAC2=8.0D0
         FAC1=2.0D0
         DO 315 IORB=1,NORBS
            NTYP=JCODED(IORB)
            ITYP(NTYP)=ITYP(NTYP)+1
 315     CONTINUE
         NUOC=ITYP(4)+ITYP(6)
         NDOC=ITYP(3)+ITYP(5)
CJ       WRITE(6,*) ' NDOC,NUOC ',NDOC,NUOC
         IF(NUOC+NDOC.NE.NORBS) THEN
CJ          WRITE(6,*) ' THIS IS NOT A CLOSED SHELL CALCULATION .... '
CJ          WRITE(6,*) ' NUOC,NDOC,NORBS ',NUOC,NDOC,NORBS
            STOP
         END IF
         NDOC=1+NUOC
       END IF
C
      CALL SRTMP2(BKTPNT,START,ILAST,TOUT,ITOUT,INTOFF,NBKT,ITXXX)
      IBFLEN=(INTOWP(BUFSZ)-2)/INTOWP(1)
      MAXBUF=INTOWP(IBFLEN)/(1+INTOWP(1))
      IBOFF=(MAXBUF+3)/INTOWP(1)
C     WRITE (JOUT,*) ' MAXBUF=',MAXBUF
C
C  THIS CURRENTLY READS PAST THE ONE ELECTRON INTEGRALS FOR ONE PDM ETC
C
      NIJ=NBF*(NBF+1)/2
C
 1111 CALL ZERO(BUF,BUFSZ)
      CALL SREAD(ITAPNN,BUF,INTOWP(BUFSZ))
C
      CALL SETMBF(IFLG,IBUF(1))
COUT  WRITE (6,*) ' IFLG=',IFLG
      CALL SETMBF(MBUF,IBUF(2))
CJ    WRITE(6,*) ' MBUF = ',MBUF
C
      DO 1101 II=1,MBUF
         CALL SETMBF(IJKL,IBUF(2+II))
         I1=ISHFT(IJKL,-24)
         J1=IAND(ITEMP,ISHFT(IJKL,-16))
         K1=IAND(ITEMP,ISHFT(IJKL,-8))
         L1=IAND(ITEMP,IJKL)
         VAL=BUF(IBOFF+II)
CJ       WRITE (6,*) I1,J1,K1,L1,VAL
         I1=IOUT(IORD(I1))
         J1=IOUT(IORD(J1))
         K1=IOUT(IORD(K1))
         L1=IOUT(IORD(L1))
CGES     I1=IOUT(I1)
CGES     J1=IOUT(J1)
CGES     K1=IOUT(K1)
CGES     L1=IOUT(L1)
CJ       WRITE (6,*) ' NEW ',I1,J1,K1,L1,VAL
         IF(I1.LT.J1) THEN
            ISWOP=J1
            J1=I1
            I1=ISWOP
         END IF
         IF(K1.LT.L1) THEN
            ISWOP=L1
            L1=K1
            K1=ISWOP
         END IF
         IF(IND(I1,J1).LT.IND(K1,L1)) THEN
            ISWOP=K1
            K1=I1
            I1=ISWOP
            ISWOP=L1
            L1=J1
            J1=ISWOP
         END IF
         VAL=VAL/FAC2
CJ
CJ       IF(.NOT.LINTS) VAL=0.0D0
CJ
      MB=1
C
C     ITYPE             DRT
C       1               7  1
C       2               5  1
C       3               5  2
C       4               6  2
C       5               6  1
C       6               3  2
C       7               3  1
C       8               2  1
C       9               4  1
C      10               4  2
C      11               2  2
C      12               1  2
C      13               1  1
C      14               1  3
C
CTJL  WRITE(6,*) ' ITYPE ' ,ITYPE(I1,J1,K1,L1)
      IF(LINTS) GO TO 98
      IF (I1.LT.NDOC.OR.J1.LT.NDOC.OR.K1.LT.NDOC.OR.L1.LT.NDOC) GO TO 98
C
      IF(ITYPE(I1,J1,K1,L1).EQ.1) VAL=VAL+1.0D0
      IF(ITYPE(I1,J1,K1,L1).EQ.4) VAL=VAL+2.0D0
      IF(ITYPE(I1,J1,K1,L1).EQ.5) VAL=VAL-0.5D0
C
98    IF(ITYPE(I1,J1,K1,L1).LT.3.OR.ITYPE(I1,J1,K1,L1).EQ.8) GO TO 100
      MB=2
      IF(ITYPE(I1,J1,K1,L1).EQ.3) THEN
        J1=I1
        K1=I1
        GO TO 100
      END IF
      IF(ITYPE(I1,J1,K1,L1).EQ.4.OR.ITYPE(I1,J1,K1,L1).EQ.6.
CJ   1   OR.ITYPE(I1,J1,K1,L1).EQ.3.
     1 OR.ITYPE(I1,J1,K1,L1).EQ.10.OR.ITYPE(I1,J1,K1,L1).EQ.12)GOTO 100
      IF(ITYPE(I1,J1,K1,L1).EQ.14) THEN
         ITMP=J1
         J1=K1
         K1=L1
         L1=ITMP
         MB=3
         GO TO 100
      END IF
      IF(ITYPE(I1,J1,K1,L1).NE.11) THEN
         MB=1
         ITMP=J1
         J1=K1
         K1=ITMP
      ELSE
         MB=2
         ITMP=J1
         J1=L1
         L1=ITMP
      END IF
100   IIJ=IND(I1,J1)
      JSM=ORBSYM(I1)
      LKUP=MULTS(JSM)+ORBSYM(J1)
      KSM=LKUPSM(LKUP)
      LKUP=MULTS(KSM)+ORBSYM(K1)
      LSM=LKUPSM(LKUP)
      IF(LSM.NE.ORBSYM(L1)) THEN
         WRITE(6,701)
701      FORMAT(//,' **** SYMMETRY ERROR   *****',/
     .            ,' SET UP DRT INPUT IN C1 FOR COUPLED CLUSTER')
         STOP 'ERROR IN DRT SYMMETRY'
      END IF
      KSMPT=K1+(KSM-1)*NORBS
      LSMPT=L1+(LSM-1)*NORBS
      IBKT=(IJGRP(IIJ)-1)/NMPB + 1
      IOFFST = (IJGRP(IIJ)-((IBKT-1)*NMPB)-1)*NMAX
      IADR=IJADD(IIJ)+KADD(KSMPT)+LADD(LSMPT)+MB + IOFFST
CJ    WRITE(6,*) ' IADR ',IADR,NMAX
CJ    PRINT *,'  I,J,K,L,I1,J1,K1,L1,VAL,IADR,IJGRP(IIJ),IBKT'
CTJL  WRITE(6,*) I,J,K,L,I1,J1,K1,L1,VAL,IADR,IJGRP(IIJ),IBKT
      CALL SRTOUN
20    CONTINUE
10    CONTINUE
 1101 CONTINUE
      IF (IFLG.EQ.0) GOTO 1111
C************TJL
      ITJL = 0
      IF(ITJL.EQ.1) RETURN
C************TJL
C
  111 CALL ZERO(BUF,BUFSZ)
      CALL SREAD(ITAPNN,BUF,INTOWP(BUFSZ))
C
      CALL SETMBF(IFLG,IBUF(1))
CJ    WRITE (6,*) ' IFLG=',IFLG
      CALL SETMBF(MBUF,IBUF(2))
CJ    WRITE(6,*) ' MBUF = ',MBUF
C
      DO 101 II=1,MBUF
         CALL SETMBF(IJKL,IBUF(2+II))
         I=ISHFT(IJKL,-8)
         L=IAND(ITEMP,IJKL)
         VAL=BUF(IBOFF+II)
CJ       WRITE (6,*) 'I,L,VAL ',I,L,VAL
         I=IOUT(IORD(I))
         L=IOUT(IORD(L))
C
         VAL=VAL/FAC1
CJ
CJ       IF(.NOT.LINTS) VAL=0.0D0
CJ
      MB=3
      IF(I.EQ.L) THEN
         MB=2
         IF(.NOT.LINTS.AND.I.GE.NDOC) VAL=2.0D0+VAL
      ELSE
         IF(I.LT.L) THEN
            ISWOP=L
            L=I
            I=ISWOP
         END IF
      END IF
      IJA=I*(I+1)/2
      LSM=ORBSYM(I)
      IF(LSM.NE.ORBSYM(L)) GO TO 101
      LSMPT=L+(LSM-1)*NORBS
      IBKT=(IJGRP(IJA)-1)/NMPB+1
      IOFFST = (IJGRP(IJA)-((IBKT-1)*NMPB)-1)*NMAX
      IADR=IJADD(IJA)+KADD(I)+LADD(LSMPT)+MB + IOFFST
      CALL SRTOUN
  101 CONTINUE
CJ    WRITE(6,*) ' IFLG BEFORE 111 ',IFLG
      IF (IFLG.EQ.0) GOTO 111
CJ    WRITE(6,*) ' CALLING SRTLMN '
      CALL SRTLMN
      RETURN
      END
      SUBROUTINE SRTMP2(BKTPNT,START,ILAST,TTT,ITTT,INTOFF,
     1 BKT,ITXXX)
      IMPLICIT INTEGER (A-Z)
      REAL*8 TTT(IBIG2),VAL
      COMMON /BIGM/ IBIG,IBIG2,BKTSZ2,BKTSZ
      COMMON /OFF/ MAXINT
      COMMON /SRTMP/VAL,IADR,IDUM,NBKT
      DIMENSION ITTT(IBIG),BKTPNT(1),START(1),
     1 ILAST(1),INTOFF(1)
CJ
CJ    WRITE(6,*) ' IN SRTMP2 '
      NUM=NUM+1
C     SWOUT=0
      BKTPNT(1)=1
      START(1)=0
      ILAST(1)=-1
      DO 360 II=2,BKT
      ILAST(II)=-1
      START(II)=START(II-1)+BKTSZ2
      BKTPNT(II)=1
360   CONTINUE
CJ
CJ    BEWARE ! POINTR=0 IN CAMBRIDGE
CJ
      POINTR=1
      PTAD=BKTSZ2/SEC2I(1)
      CALL SREW(ITXXX)
      IF(SEC2I(1)*PTAD.NE.BKTSZ2) PTAD = PTAD+1
      MAXINT=((BKTSZ2-2)/6)*2
      IF(MAXINT.LE.0) THEN
      STOP
      END IF
      DO 370 II=1,BKT
      INTOFF(II)=(START(II)+MAXINT)/2+1
CJ    WRITE(6,*) INTOFF(1)
370   CONTINUE
 22   CONTINUE
CJ    PRINT *,' MAXINT'
CJ    WRITE(6,*) MAXINT,INTOFF(1)
      RETURN
C
      ENTRY SRTOUN
            STRT=START(IDUM)
      PNT=BKTPNT(IDUM)
      OFSET=INTOFF(IDUM)
      ADRL=STRT+PNT+2
      ADRV=OFSET+PNT
      ITTT(ADRL)=IADR
      TTT(ADRV)=VAL
CJ    PRINT *,' IDUM,START(1),BKTPNT,ILAST,INTOFF'
CJ    WRITE(6,*) IDUM,START(1),BKTPNT(1),ILAST(1),INTOFF(1)
      BKTPNT(IDUM)=BKTPNT(IDUM)+1
CJ    WRITE(6,2998) ADRL,IADR,ADRV,TTT(ADRV),VAL,IADR
2998  FORMAT(/' ADRL,IADR,ADRV,TTT,VAL = ',3I8,2F20.8,I8)
      IF (ADRL .LT. (OFSET*2)) RETURN
CJ    WRITE(6,*) ' IN SRTOUN ADRL,OFSET,IDUM =',ADRL,OFSET,IDUM
      ITTT(STRT+1)=ILAST(IDUM)
      ILAST(IDUM)=POINTR
      POINTR=POINTR+PTAD
      ITTT(STRT+2)=MAXINT
      CALL RGETSA(ITXXX,IX)
      CALL RWRIT(ITXXX,ITTT(STRT+1),BKTSZ2,IX)
CJ
      BKTPNT(IDUM)=1
      RETURN
C
      ENTRY SRTLMN
      DO 10 II=1,BKT
      STRT=START(II)
CJ    PRINT*, 'STRT=',STRT
CJ    WRITE(6,*) BKTPNT(II),II
      IF (BKTPNT(II) .EQ. 1) GOTO 201
      ITTT(STRT+1)=ILAST(II)
      ILAST(II)=POINTR
      POINTR=POINTR+PTAD
      ITTT(STRT+2)=BKTPNT(II)-1
      CALL RGETSA(ITXXX,IX)
      CALL RWRIT(ITXXX,ITTT(STRT+1),BKTSZ2,IX)
CJ    WRITE(6,*) ' JUST WRITTEN TO TAPE AT POSITION IX ',IX
CJ    PRINT *,' ITTT ETC '
CJ    WRITE(6,*) ITTT(STRT+1),ITTT(STRT+2),ILAST(II),BKTPNT(II)-1
CJ
 201  CONTINUE
10    CONTINUE
CJ
      RETURN
      END
      FUNCTION ITYPE(I,J,K,L)
      IF (J-K)150,10,80
10    IF (I-J) 50,20,50
20    IF (K-L) 40,30,40
30    ITYPE=1
      RETURN
40    ITYPE=2
      RETURN
50    IF (K-L) 70,60,70
60    ITYPE=3
      RETURN
70    ITYPE=8
      RETURN
80    IF (I-J) 120,90,120
90    IF (K-L) 110,100,110
100   ITYPE=4
      RETURN
110   ITYPE=6
      RETURN
120   IF (K-L) 140,130,140
130   ITYPE=10
      RETURN
140   ITYPE=12
      RETURN
150   IF (J-L) 220,190,160
160   IF (I-K) 180,170,180
170   ITYPE=7
      RETURN
180   ITYPE=13
      RETURN
190   IF (I-K) 210,200,210
200   ITYPE=5
      RETURN
210   ITYPE=9
      RETURN
220   IF (K-L) 240,230,240
230   ITYPE=11
      RETURN
240   ITYPE=14
      RETURN
      END
C
      SUBROUTINE SETMBF(MBUF,IBUF)
      IMPLICIT REAL*8 (A-H,O-Z)
      MBUF=IBUF
      RETURN
      END
