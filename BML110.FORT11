C**********************************************************************
C Library for BMATIN6 fortran.
C**********************************************************************
c Moved to PSI area on 2/3/89 by clj.
C**********************************************************************
C     NOTIFICATION OF PROGRAM CHANGE:                                 *
C     BY:     TRACY HAMILTON                                          *
C     DATE:    JULY 18,1988                                           *
C     REASON:  SCALE FORCES CORRECTLY IN DO 20 LOOP                   *
C**********************************************************************
      SUBROUTINE EFC(NUMIT,NQ,F1,QQ,FI,C,MODEBM,QQ1,IFSTRE,GEC)
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  THIS ROUTINE SETS UP ALL THE COMMON BLOCKS NEEDED PRIOR TO CALLING
C  LINK 110.
C
      COMMON/MODOUT/VMODE1(50)
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
      COMMON/ASTRE/STRE(50)
      DIMENSION F1(1),QQ(1),FI(1),C(1),QQ1(1),CORE(1),IFSTRE(1),GEC(1)
      LOGICAL STRE,IFSTRE
      DATA TOANG/0.52917706D0/, HARTRE/4.359813653D0/
      CONV1 = TOANG/HARTRE
      CONV2 = TOANG*CONV1
      DO 5 I=1,NQ
    5 STRE(I) = IFSTRE(I)
C
      NSTEP = NUMIT
      MODE = MODEBM
C
C     NUMBER OF SYMMETRY INTERNAL COORDINATES:
      NVAR = NQ
C
C     VALUES OF SYMMETRY INTERNAL COORDINATES:
      DO 10 I=1,NVAR
      X(I) = QQ(I)
C     CONVERT  ANG --> BOHR
      IF(STRE(I)) X(I) = X(I) / TOANG
   10 CONTINUE
C     WRITE(6,666) (X(I),I=1,NVAR)
C 666 FORMAT('X  ',6F10.7)
C
C     FORCES (CONVERT  MDYNE --> HARTREE/BOHR):
      DO 20 I=1,NVAR
         IF(STRE(I)) THEN
            F(I) = FI(I) * CONV1
         ELSE
            F(I) = FI(I) / HARTRE
         ENDIF
   20 CONTINUE
C     WRITE(6,667) (F(I),I=1,NVAR)
C 667 FORMAT('F  ',6F10.7)
C
C     HESSIAN:
      IJ = 0
      DO 31 I=1,NVAR
      DO 30 J=1,NVAR
      IJ = IJ+1
      HESS(I,J) = C(IJ)
      IF(STRE(I).AND.STRE(J)) THEN
C         MDYNE/ANG --> HARTREE/BOHR**2
          HESS(I,J) = HESS(I,J) * CONV2
      ELSE IF(STRE(I).OR.STRE(J)) THEN
C         MDYNE/RAD --> HARTREE/BOHR/RAD
          HESS(I,J) = HESS(I,J) * CONV1
      ELSE
C         MDYNE*ANG/RAD**2 --> HARTREE/RAD**2
          HESS(I,J) = HESS(I,J) / HARTRE
      ENDIF
   30 CONTINUE
C     WRITE(6,668) (HESS(I,J),J=1,NVAR)
C 668 FORMAT('HESS  ',6F10.7)
   31 CONTINUE
C
      IF(NSTEP.GT.0) THEN
C
C     OLD GRADIENT (NEGATIVE OF OLD FORCES) (CONVERT TO HARTREE/BOHR):
      DO 40 I=1,NVAR
   40 OLDF(I) = -F1(I) * CONV1
C     WRITE(6,669) (OLDF(I),I=1,NVAR)
C 669 FORMAT('OLDF  ',6F10.7)
C
C     SKIP OVER FIRST LINE IN INP4:
CTPH  READ(INP4,1000) DD
C
C     OLD STEP SIZE AND STEP:
CTPH  READ(INP4,1000) DD
CTPH  READ(INP4,1000) (D(I),I=1,NVAR)
      DD = 0.0D0
      DO 45 I=1,NVAR
         D(I) = GEC(I)
         IF(STRE(I)) D(I) = D(I) / TOANG
         DD = DD + D(I)**2
   45 CONTINUE
      DD = DSQRT(DD)
C     WRITE(6,670) (D(I),I=1,NVAR)
C 670 FORMAT('D  ',6F10.7)
C
C     POSSIBLY RECOVER OLD HESSIAN MODE:
      IF(MODE.GT.0) THEN
C         READ(INP3,1010) MODE
C         READ(INP3,1020) (VMODE(I),I=1,NVAR)
      DO 46 I=1,NVAR
         READ(INP2,1020) VMODE(I)
   46 CONTINUE
          IF(MODE.EQ.1) MODE=0
          ENDIF
      ENDIF
C
C
C
      CALL OPTEFC(CORE)
C
C
C
CTPH  REWIND INP4
CTPH  WRITE(INP4,1010) -1,NSTEP
C
C     SAVE STEP SIZE AND STEP:
CTPH  WRITE(INP4,1000) DD
CTPH  WRITE(INP4,1000) (D(I),I=1,NVAR)
C
C     SAVE MODE:
CTPH  REWIND INP3
CTPH  WRITE(INP3,1010) MODE
CTPH  WRITE(INP3,1020) (VMODE(I),I=1,NVAR)
C
C     PUT HESSIAN BACK INTO BMAT FORM:
      MODEBM = MODE
      DO 51 I=1,NVAR
         VMODE1(I) = VMODE(I)
  51  CONTINUE
      IJ = 0
      DO 70 I=1,NVAR
      DO 70 J=1,NVAR
      IJ = IJ+1
      IF(STRE(I).AND.STRE(J)) THEN
C         HARTREE/BOHR**2 --> MDYNE/ANG
          HESS(I,J) = HESS(I,J) / CONV2
      ELSE IF(STRE(I).OR.STRE(J)) THEN
C         HARTREE/BOHR/RAD --> MDYNE/RAD
          HESS(I,J) = HESS(I,J) / CONV1
      ELSE
C         HARTREE/RAD**2 --> MDYNE*ANG/RAD**2
          HESS(I,J) = HESS(I,J) * HARTRE
      ENDIF
   70 C(IJ) = HESS(I,J)
C     WRITE(6,671) (C(I),I=1,NVAR*NVAR)
C 671 FORMAT('C  ',6F10.7)
C
C     COPY DISPLACEMENTS INTO BMAT ARRAY (AND CONVERT BOHR --> ANG):
      DO 80 I=1,NVAR
      QQ1(I) = D(I)
      IF(STRE(I)) QQ1(I) = QQ1(I) * TOANG
   80 CONTINUE
C
      RETURN
C
 1000 FORMAT(F10.6)
 1010 FORMAT(2I5)
 1020 FORMAT(8F10.6)
C
      END
      SUBROUTINE OPTEFC(CORE)
      IMPLICIT REAL*8(A-H,O-Z)
C
C
C  **************************************************************
C  *                                                            *
C  *  DRIVER FOR EIGENVECTOR FOLLOWING TRANSITION STATE SEARCH  *
C  *  BASED ON "ON FINDING TRANSITION STATES" BY CERJAN AND     *
C  *  MILLER (J.CHEM.PHYS. 75 (1981) 2800);   "WALKING ON       *
C  *  POTENTIAL ENERGY SURFACES" BY SIMONS, JORGENSON, TAYLOR   *
C  *  AND OZMENT (J.PHYS.CHEM. 87 (1983) 2745)  AND  "SEARCH    *
C  *  FOR STATIONARY POINTS ON SURFACES" BY BANERJEE, ADAMS,    *
C  *  SIMONS AND SHEPARD (J.PHYS.CHEM. 89 (1985) 52).           *
C  *                                                            *
C  *  ORIGINAL VAX CODE BY JON BAKER          JB MARCH 1985     *
C  *                                                            *
C  **************************************************************
C
C
C  OPTIONS          COMMON/IOP/
C
C  IOP(5)     NATURE OF REQUIRED STATIONARY POINT
C             0    FIND A TS                            (DEFAULT)
C             1    FIND A MINIMUM
C
C  IOP(6)     MAXIMUM NUMBER OF STEPS ALLOWED
C             0    MIN(40,NVAR+20)                      (DEFAULT)
C                  (WHERE NVAR = NUMBER OF VARIABLES)
C             N    N STEPS
C
C  IOP(7)     CONVERGENCE CRITERIA ON RMS GRADIENT
C             0    0.0003                               (DEFAULT)
C             N    0.001/N
C             NOTE: THE OTHER CONVERGENCE CRITERIA ARE
C             MAXIMUM GRADIENT = 1.5 * RMS GRADIENT
C             RMS DISPLACEMENT = 4.0 * RMS GRADIENT
C             MAX DISPLACEMENT = 1.5 * RMS DISPLACEMENT
C
C  IOP(8)     MAXIMUM STEPSIZE ALLOWED DURING OPTIMIZATION
C             0    DMAX = 0.3                           (DEFAULT)
C             N    DMAX = 0.01*N
C
C  IOP(10)    INPUT OF INITIAL SECOND DERIVATIVE MATRIX
C             ALL VALUES MUST BE IN ATOMIC UNITS
C             0    ESTIMATE ENTIRE HESSIAN NUMERICALLY     (TS DEFAULT)
C                  ESTIMATE DIAGONAL ELEMENTS ONLY        (MIN DEFAULT)
C             1    READ IN FULL FRCNST MATRIX (LOWER TRIANGLE)
C                  FORMAT (8F10.6)
C             2    READ IN SELECTED ELEMENTS OF FRCNST
C                  READ I,J,FRCNST(I,J)        2I3, F20.0
C             3    READ FRCNST MATRIX FROM THE CHECKPOINT FILE
C             4    CALCULATE HESSIAN ANALYTICALLY
C             5    READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
C  IOP(11)    HESSIAN RECALCULATION
C             0    UPDATE THE HESSIAN ONLY              (DEFAULT)
C             N    RECALCULATE THE HESSIAN (ANALYTICALLY IF
C                  POSSIBLE, ELSE NUMERICALLY) EVERY N POINTS
C             (OBS!  IF THIS OPTION IS INVOKED, RESTARTS FROM THE
C              CHECKPOINT FILE SHOULD NOT BE ATTEMPTED EXCEPT VIA A
C              NON-STANDARD ROUTE. EXCEPTION: ANALYTICAL DERIVATIVES
C              AT ALL POINTS VIA "CALCALL" CAN BE RESTARTED)
C
C  IOP(13)    TYPE OF HESSIAN UPDATE
C             0    POWELL UPDATE                        (DEFAULT)
C             1    BFGS UPDATE (USED IN CONJUNCTION WITH MIN)
C             2    BFGS UPDATE WITH SAFEGUARDS TO ENSURE RETENTION
C                  OF POSITIVE DEFINITENESS
C
C  IOP(16)    MAXIMUM ALLOWABLE MAGNITUDE OF HESSIAN EIGENVALUES
C             IF THIS MAGNITUDE IS EXCEEDED, THE EIGENVALUE IS REPLACED
C             0    EIGMAX = 25.0                        (DEFAULT)
C             N    EIGMAX = 0.1*N
C
C  IOP(17)    MINIMUM ALLOWABLE MAGNITUDE OF HESSIAN EIGENVALUES
C             SIMILAR TO IOP(16)
C             0    EIGMIN = 0.0001                      (DEFAULT)
C             N    EIGMIN = 1.0/N
C
C  IOP(19)    SEARCH SELECTION
C             0    P-RFO OR RFO STEP ONLY               (DEFAULT)
C             1    P-RFO OR RFO STEP FOR "WRONG" HESSIAN
C                  OTHERWISE NEWTON-RAPHSON
C
C  IOP(21)    EXPERT SWITCH
C             0    NORMAL MODE                          (DEFAULT)
C             1    EXPERT MODE
C                  CERTAIN CUTOFFS TO CONTROL OPTIMIZATION RELAXED
C
C  IOP(33)    PRINT OPTION
C             0    ON                                   (DEFAULT)
C             1    OFF  TURNS OFF EXTRA PRINTING
C             (DEFAULT OF "ON" BY POPULAR REQUEST)
C
C  IOP(34)    DUMP OPTION
C             0    OFF                                  (DEFAULT)
C             1    ON   TURNS ON DEBUG PRINTING
C
C  IOP(35)    RESTART OPTION
C             0    NORMAL OPTIMIZATION                  (DEFAULT)
C             1    FIRST POINT OF A RESTART
C                  RECOVER GEOMETRY ETC.. FROM CHECKPOINT FILE
C
C  IOP(36)    CHECKPOINT OPTION
C             0    CHECKPOINTING AS NORMAL              (DEFAULT)
C             1    SUPPRESS CHECKPOINTING
C
C  IOP(37)    D2E CLEANUP OPTION
C             0    NO SPECIAL ACTION TAKEN              (DEFAULT)
C             1    THIS IS THE LAST POINT AT WHICH ANALYTICAL
C                  DERIVATIVES ARE AVAILABLE; CLEAN UP THE RWF
C
C
C  MODE FOLLOWING:  MODE FOLLOWING IS TURNED ON VIA THE IC ARRAY, WHICH
C  IS INPUT WITH THE Z-MATRIX VARIABLES IN LINK 101. ADDING 4 TO THE IC
C  ENTRY FOR A PARTICULAR VARIABLE WILL CAUSE A TRANSITION STATE SEARCH
C  TO FOLLOW THE HESSIAN MODE WITH THE LARGEST MAGNITUDE COMPONENT FOR
C  THAT VARIABLE. ADDING 10 TO THE IC ENTRY FOR THE KTH VARIABLE WILL
C  FOLLOW THE KTH HESSIAN MODE. ONLY ONE IC ENTRY SHOULD BE MODIFIED IN
C  THIS WAY  I.E. ONLY ONE MODE SHOULD BE FOLLOWED AT A TIME.
C
C
c     REAL*8 CORE(1)
      REAL*8 U(50,50),HESSC(50,50),EIGVAL(50),FX(50),TVEC(50),tvec2(50)
      LOGICAL PRNT,NRFLAG,DUMP,CNVGRD,last
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
      EQUIVALENCE (FX(1),TVEC(1))
C
c     DATA IGRDNT/511/,LGRDNT/1327/, IZSUBS/570/,LZSUBS/175/
c     DATA IOPTEF/575/,LOPTEF/2790/
      DATA ZERO/0.0D0/, ONE/1.0D0/
C
C
C  INITIALIZE THIS LINK
C  THE ILSW BIT WILL BE SET UNLESS THIS IS THE FIRST ENTRY TO
C  LINK 110, IN WHICH CASE WE'LL JUST DO SOME INITIALIZATION
C
c     CALL DRUM
      WRITE(IOUT,1000)
c     CALL ILSW(2,23,IGRD)
c     CALL ILSW(1,23,1)
c     IF(IGRD.EQ.1.OR.IOP(35).GT.0) GO TO 100
C
C  READ IN DATA AND INITIALIZE OPTIMIZATION
C
      IF(IOP(5).EQ.0) WRITE(IOUT,1005)
      IF(IOP(5).NE.0) WRITE(IOUT,1006)
c     WRITE(IOUT,1010)
      CALL INITEF(CORE)
c     CALL EXITEF(0)
c     RETURN
C
C  START LOOP FOR SECOND AND LATER CALLS TO LINK 110
C
C  RESTORE THE CHECKPOINTED INFORMATION IF THIS IS THE FIRST
C  POINT OF A RESTART FROM THE CHECKPOINT FILE
C
c 100 IF(IOP(35).EQ.1) CALL CHKPNT(1)
C
C  RECOVER COMMON BLOCKS FROM RWF
C
c     CALL TREAD(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     CALL TREAD(IGRDNT,ENERGY,LGRDNT,1,LGRDNT,1,0)
c     CALL TREAD(IOPTEF,X,LOPTEF,1,LOPTEF,1,0)
c     IF(NEGREQ.EQ.1) WRITE(IOUT,1005)
c     IF(NEGREQ.EQ.0) WRITE(IOUT,1006)
c     IF(IOP(6).NE.0) MXSTEP=IOP(6)
c     IF(IOP(36).EQ.0) CALL CHKPNT(0)
C
C  CONVERT FORCES TO GRADIENT
C
      CALL DNEGV(F,NVAR)
C
C  CHECK ON STATUS OF HESSIAN
C  THIS IS GIVEN BY THE INTEGER FLAG IHESS
C  IHESS=0    HESSIAN UNAVAILABLE
C             (BEING ESTIMATED NUMERICALLY)
C  IHESS=1    FIRST POINT WITH CONSTRUCTED HESSIAN
C  IHESS=N    NTH POINT WITH HESSIAN
C             (SHOULD BE UPDATED PRIOR TO USE)
C
c     IF(IHESS.LE.0) CALL HESSEF
C
C  IF HESSIAN STILL UNAVAILABLE UPDATE PARAMETER LIST AND EXIT
C
c     IF(IHESS.EQ.0) THEN
c     WRITE(IOUT,1015)
c     WRITE(IOUT,1020) NSTEP,IS
c     CALL EXITEF(0)
c     RETURN
c     ENDIF
C
C  UPDATE THE HESSIAN (UNLESS FIRST POINT)
c  (or unless already updated by BMAT or calculated analytically)
C
c     IF(IHESS.GT.1) CALL UPDATE(EIGVAL,TVEC)
      IF(nstep.gt.0 .and. iop(13).ge.0) CALL UPDATE(EIGVAL,TVEC)
C
C  IF THIS IS THE LAST POINT AT WHICH ANALYTICAL SECOND
C  DERIVATIVES WILL BE AVAILABLE, CLEAN UP THE RWF
C
c     IF(IOP(37).NE.0) CALL CLND2E
C
C  HESSIAN READY FOR USE
C  START OPTIMIZATION PROPER
C
      NSTEP=NSTEP+1
      WRITE(IOUT,1025) NSTEP
c     IHESS=IHESS+1
C
C  DIAGONALIZE HESSIAN
C  FIRST COPY HESS INTO HESSC SINCE HESSIAN IS DESTROYED
C  BY DIAGONALIZATION ROUTINE
C
c     CALL DMCOPY(HESSC,HESS,NVAR)
c     CALL DODIAG(NVAR,50,HESSC,U,EIGVAL,TVEC)
      call cntrct(hessc,hess,nvar)
      call rsp(50,nvar,2500,hessc,eigval,1,u,tvec,tvec2)
C
C  PRINT THE HESSIAN, ITS EIGENVECTORS AND EIGENVALUES IF
C  REQUESTED. VECTORS ARE IN U, EIGENVALUES IN EIGVAL
C
      IF(PRNT) THEN
      IF(DUMP) WRITE(IOUT,1030)
      IF(DUMP) CALL DMPRNT(HESS,NVAR,IOUT)
      WRITE(IOUT,1035)
c     CALL MATPRT(U,50,50,NVAR,NVAR,2,0,XNAME,XNAME,0,EIGVAL,1)
      last = .false.
      nstar = 1
   10 nend = nstar + 5
      if(nend.ge.nvar) then
         last = .true.
         nend = nvar
      endif
      write(iout,1045) (eigval(l),l=nstar,nend)
      write(iout,1045)
      do 997 i=1,nvar
      write(iout,1045) (u(i,l),l=nstar,nend)
  997 continue
      write(iout,1045)
      nstar = nend + 1
      if(.not.last) go to 10
C
      ELSE
C
      WRITE(IOUT,1040)
      WRITE(IOUT,1045) (EIGVAL(L),L=1,NVAR)
      ENDIF
C
C  CHECK FOR MAXIMUM AND MINIMUM ALLOWED MAGNITUDES
C  FOR THE HESSIAN EIGENVALUES
C
      CALL MAGCHK(EIGVAL,NVAR)
C
C  CALCULATE NEG, THE NUMBER OF NEGATIVE EIGENVALUES
C
      CALL FNDNEG(EIGVAL,NEG,NVAR)
C
C  FORM THE FX VECTOR
C  (THE COMPONENT OF F ALONG THE LOCAL EIGENDIRECTIONS U)
C
      DO 20 I=1,NVAR
      FX(I)=DVTV(U(1,I),F,NVAR)
   20 CONTINUE
C
C  IF WE ARE IN THE "RIGHT" REGION OF THE ENERGY SURFACE
C  I.E. THE HESSIAN HAS THE REQUIRED NUMBER OF NEGATIVE EIGENVALUES
C  AND NRFLAG IS ON, TAKE THE NEWTON-RAPHSON STEP
C
      IF(NRFLAG.AND.NEG.EQ.NEGREQ) THEN
      WRITE(IOUT,1050)
      CALL FORMNR(U,EIGVAL,FX,D,NVAR)
C
      ELSE
C
C  TAKE THE P-RFO STEP FOR A TS SEARCH AND
C  THE SIMPLE RFO STEP FOR A MINIMUM SEARCH
C
      IF(NEG.EQ.NEGREQ.AND.NEGREQ.EQ.1) WRITE(IOUT,1055)
      IF(NEG.EQ.NEGREQ.AND.NEGREQ.EQ.0) WRITE(IOUT,1056)
      IF(NEG.NE.NEGREQ.AND.NEGREQ.EQ.1) WRITE(IOUT,1057)
      IF(NEG.NE.NEGREQ.AND.NEGREQ.EQ.0) WRITE(IOUT,1058)
      CALL FORMD(U,EIGVAL,FX,NVAR)
      ENDIF
C
C  WE NOW HAVE A NEW STEP IN D
C  CHECK THAT THE STEPSIZE DOES NOT EXCEED DMAX
C  IF SO, SCALE
C
      CALL CHECKD(D,DMAX,DD,SKAL,NVAR)
C
C  PREDICT THE CHANGE IN ENERGY
C
      CALL ESTIME(EIGVAL,FX,DD,SKAL,CHNGE,NVAR)
C
C  TEST FOR CONVERGENCE AND PRINT OUT CURRENT PARAMETER VALUES
C
      CALL CONVEF(NEG,CNVGRD,TVEC)
      WRITE(IOUT,1060) CHNGE
C
C  IF CONVERGED THEN EXIT
C
      IF(CNVGRD) THEN
c     CALL EXITEF(1)
      write(iout,1000)
      RETURN
      ENDIF
C
C  FORM THE NEW X VECTOR AND SAVE THE CURRENT GRADIENT
C
c     CALL DVADDV(X,X,D,NVAR)
c     CALL DVCOPY(OLDF,F,NVAR)
C
C  CHECK IF THE HESSIAN IS TO BE RECALCULATED/REESTIMATED
C
c     IF(IHESS.GT.MXHESS) THEN
c     IHESS=0
c     IS=0
c     CALL GET202(ICHAIN,1)
c     CALL EXITEF(ICHAIN)
c     RETURN
c     ENDIF
C
C  AND EXIT
C
c     CALL EXITEF(0)
      write(iout,1000)
C
      RETURN
C
1000  FORMAT(/24('EF-'))
C
1005  FORMAT(//'EIGENVECTOR FOLLOWING TRANSITION STATE SEARCH')
C
1006  FORMAT(//'EIGENVECTOR FOLLOWING MINIMUM SEARCH')
C
1010  FORMAT(' INITIALIZATION PASS')
C
1015  FORMAT(//' NUMERICALLY ESTIMATING SECOND DERIVATIVES')
C
1020  FORMAT(' ITERATION ',I3,' VARIABLE ',I2)
C
1025  FORMAT(//'ITERATION ',I3)
C
1030  FORMAT(//' HESSIAN MATRIX')
C
1035  FORMAT('EIGENVECTORS AND EIGENVALUES'/)
C
1040  FORMAT(//'EIGENVALUES OF THE HESSIAN')
C
c1045  FORMAT(5X,6F12.6)
1045  FORMAT(6F12.6)
C
1050  FORMAT(' HESSIAN HAS REQUIRED LOCAL STRUCTURE'/
     $       ' TAKING NEWTON-RAPHSON STEP')
C
1055  FORMAT(' TS SEARCH. TAKING P-RFO STEP')
C
1056  FORMAT(' MINIMUM SEARCH. TAKING SIMPLE RFO STEP')
C
1057  FORMAT(' HESSIAN DOES NOT HAVE THE DESIRED LOCAL STRUCTURE'/
     $       ' TAKING P-RFO STEP')
C
1058  FORMAT(' HESSIAN DOES NOT HAVE THE DESIRED LOCAL STRUCTURE'/
     $       ' TAKING SIMPLE RFO STEP')
C
1060  FORMAT(' PREDICTED CHANGE IN ENERGY  ',F9.6)
C
      END
      SUBROUTINE CHECKD(D,DMAX,DD,SKAL,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 D(1)
      COMMON/IO/IN,IOUT
C
C  GET CURRENT STEPSIZE
C
      DD=DVTV(D,D,NVAR)
      DD=DSQRT(DD)
C
      IF(DD.GT.DMAX) THEN
      SKAL=DMAX/DD
      WRITE(IOUT,1000) SKAL
      CALL DVSKAL(D,D,SKAL,NVAR)
      DD=DMAX
      ENDIF
C
      WRITE(IOUT,1010) DD
      RETURN
C
1000  FORMAT(' CALCULATED STEP TOO LARGE. STEP SCALED BY ',F9.6)
C
1010  FORMAT(' STEP TAKEN. STEPSIZE IS ',F9.6)
C
      END
      SUBROUTINE CONVEF(NEG,CNVGRD,TVEC)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TVEC(1)
c     DIMENSION TVEC(1),IRESLT(3)
      character*3 ireslt
      LOGICAL PRNT,NRFLAG,DUMP,CNVGRD,stre
      common/astre/stre(50)
      COMMON/IO/IN,IOUT
c     COMMON/PHYCON/TOANG,PHYCON(29)
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVARRD
C
c     DATA IOZMAT/507/,LZMAT/351/
      data toang/0.52917706d0/, todeg/57.296d0/
C
C  PRINT OUT CURRENT X, CURRENT GRADIENTS, DISPLACEMENTS
C  AND NEWX
C
      WRITE(IOUT,1000)
      WRITE(IOUT,1010)
      DO 20 I=1,NVAR
      TVEC(I)=X(I)+D(I)
      if(stre(i)) then
          temp = tvec(i) * toang
      else
          temp = tvec(i) * todeg
      endif
      WRITE(IOUT,1020) I,X(I),F(I),D(I),TVEC(I),temp
   20 CONTINUE
C
C  FIND MAXIMUM AND RMS GRADIENTS AND DISPLACEMENTS
C
      FMAX=DABS(F(1))
      DXMAX=DABS(D(1))
      IF(NVAR.GT.1) THEN
      DO 30 I=2,NVAR
      IF(DABS(F(I)).GT.FMAX) FMAX=DABS(F(I))
      IF(DABS(D(I)).GT.DXMAX) DXMAX=DABS(D(I))
   30 CONTINUE
      ENDIF
C
      FSQ=DVTV(F,F,NVAR)
      FRMS=DSQRT(FSQ/NVAR)
      DXRMS=DSQRT(DD*DD/NVAR)
C
C  CHECK CONVERGENCE
C
      WRITE(IOUT,1030)
      CALL CONVGD(FMAX,CNVFMX,IRESLT)
      WRITE(IOUT,1032) FMAX,CNVFMX,IRESLT
      CALL CONVGD(FRMS,CONVF,IRESLT)
      WRITE(IOUT,1034) FRMS,CONVF,IRESLT
      CALL CONVGD(DXMAX,CNVXMX,IRESLT)
      WRITE(IOUT,1036) DXMAX,CNVXMX,IRESLT
      CALL CONVGD(DXRMS,CONVX,IRESLT)
      WRITE(IOUT,1038) DXRMS,CONVX,IRESLT
C
C  SET CONVERGENCE FLAG AND TEST FOR MAXIMUM ITERATIONS
C  EXCEEDED
C
      IF(FMAX.GT.CNVFMX.OR.FRMS.GT.CONVF.OR.
     $   DXMAX.GT.CNVXMX.OR.DXRMS.GT.CONVX) THEN
      CNVGRD=.FALSE.
c     IF(NSTEP.GE.MXSTEP) THEN
c     WRITE(IOUT,1040)
c     CALL ILSW(1,25,0)
c     CALL ILSW(1,27,1)
c     CNVGRD=.TRUE.
c     ENDIF
      RETURN
      ENDIF
C
C  CONVERGED. PRINT FINAL SOLUTION
C
      CNVGRD=.TRUE.
      WRITE(IOUT,1050)
C
C  TEST IF THE HESSIAN HAS THE REQUIRED NUMBER OF
C  NEGATIVE EIGENVALUES
C
      IF(NEG.NE.NEGREQ) WRITE(IOUT,1060)
C
C  PRINT FINAL PARAMETERS
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
c     DO 40 I=1,NVAR
c     IC(I)=99
c  40 CONTINUE
C
c     CALL PRMTBL(1,XNAME,X,IC,F,NVAR,LBL,NZ,TOANG)
C
      RETURN
C
1000  FORMAT(//'CURRENT PARAMETER VALUES (INTERNAL COORDINATES)',
     $       17x,'Angstrom')
C
1010  FORMAT(3X,'I',8X,'X',9X,'GRADIENT',4X,
     $       'DISPLACEMENT',7X,'NEWX',5x,'or degrees')
C
1020  FORMAT(I4,4(2X,F10.6,2X),3x,f9.4)
C
1030  FORMAT(//8X,4HITEM,15X,5HVALUE,5X,9HTHRESHOLD,2X,
     $       10HCONVERGED?)
C
1032  FORMAT(/14H MAXIMUM FORCE,12X,F8.6,5X,F8.6,5X,a3)
C
1034  FORMAT(14H RMS     FORCE,12X,F8.6,5X,F8.6,5X,a3)
C
1036  FORMAT(21H MAXIMUM DISPLACEMENT,5X,F8.6,5X,F8.6,5X,a3)
C
1038  FORMAT(21H RMS     DISPLACEMENT,5X,F8.6,5X,F8.6,5X,a3)
C
1040  FORMAT(//' ***********************************'/
     $         ' **     OPTIMIZATION STOPPED      **'/
     $         ' **  MAXIMUM ITERATIONS EXCEEDED  **'/
     $         ' ***********************************'//)
C
1050  FORMAT(//' *************************************************'/
     $         ' **  CONVERGENCE CRITERIA APPARENTLY SATISFIED  **'/
     $         ' *************************************************'//)
C
1060  FORMAT(//'|| WARNING: THE HESSIAN HAS THE WRONG NUMBER OF',
     $       ' NEGATIVE EIGENVALUES ||'/)
C
      END
c     SUBROUTINE ESTM
c     IMPLICIT REAL*8(A-H,O-Z)
c     LOGICAL PRNT,NRFLAG,DUMP
C
C  MAKES GUESSES AT THE DIAGONAL SECOND DERIVATIVES
C  THIS ROUTINE IS A MODIFIED VERSION OF THE GAUSSIAN 82 ROUTINE
C  OF THE SAME NAME USED IN LINK 103.
C
C  BENDING FORCE CONSTANTS ARE 1.35 FOR MINIMAL BASIS, ELSE 1.0.
C  FOR STRETCHES THE VALUE CHOSEN DEPENDS UPON THE INTERNUCLEAR
C  DISTANCE AND THE ROWS OF THE PERIODIC TABLE IN WHICH THE TWO
C  AFFECTED ATOMS RESIDE AS WELL AS THE BASIS.
C  DUMMIES ARE CONSIDERED THE SAME AS HYDROGEN.
C
c     DIMENSION AA(3,3),IROW(18),ISAVE(50),XANG(50)
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MAXSTP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVAR
C
c     DATA TOANG/0.52917706/, HARTRE/4.359814D0/
c     DATA A1,A2/5.38D0,4.0D0/, B1,B2/1.35D0,1.0D0/
c     DATA IROW/2*1,8*2,8*3/
c     DATA AA/-0.129D0,0.186D0,0.349D0,
c    $         0.186D0,0.574D0,0.805D0,
c    $         0.349D0,0.805D0,1.094D0/
c     DATA IOZMAT/507/,LZMAT/351/
C
C
C  RECOVER COMMON/ZMAT/
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
C
C  ALLOW FOR CHANGES IN HESS WITH BASIS
C
c     CALL ILSW(2,3,IA)
c     AAA=A1
c     IF(IA.NE.0) AAA=A2
c     BBB=B1
c     IF(IA.NE.0) BBB=B2
c     IF(NZ.LT.2) GO TO 50
C
C  CONVERT BOND LENGTHS TO ANGSTROMS
C
c     DO 15 I=1,NVAR
c     XANG(I)=X(I)
c     IF(NREP(I,LBL,NZ).NE.0) XANG(I)=XANG(I)*TOANG
c  15 CONTINUE
C
C  GUESS DIAGONAL 2ND DERIVATIVES IN MDYNE UNITS
C
c     DO 20 I=2,NZ
c     IVAR=IABS(LBL(I))
c     IF(IVAR.EQ.0) GO TO 20
c     IATNO=IANZ(I)
c     IA=IROW(IATNO)
c     IF(IATNO.LT.1.OR.IATNO.GT.18) IA=1
c     JATOM=IZ(I,1)
c     JATNO=IANZ(JATOM)
c     IB=IROW(JATNO)
c     IF(JATNO.LT.1.OR.JATNO.GT.18) IB=1
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR) = HESS(IVAR,IVAR)
c    $                       + AAA/( (XANG(IVAR)-AA(IA,IB))**3 )
c  20 CONTINUE
c     IF(NZ.LT.3) GO TO 50
C
c     DO 30 I=3,NZ
c     IVAR=IABS(LALPHA(I))
c     IF(IVAR.EQ.0) GO TO 30
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)+BBB
c  30 CONTINUE
c     IF(NZ.LT.4) GO TO 50
C
c     DO 40 I=4,NZ
c     IVAR=IABS(LBETA(I))
c     IF(IVAR.EQ.0) GO TO 40
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)+BBB
c  40 CONTINUE
C
c  50 CONTINUE
C
C  CONVERT TO ATOMIC UNITS
C
c     CONSTR=TOANG**2/HARTRE
c     CONBND=1.0D0/HARTRE
c     CALL ICLEAR(50,ISAVE)
c     NSAVE=0
c     DO 60 I=2,NZ
c     IVAR=IABS(LBL(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 60
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONSTR
c  60 CONTINUE
C
c     CALL ICLEAR(NSAVE,ISAVE)
c     NSAVE=0
c     DO 70 I=3,NZ
c     IVAR=IABS(LALPHA(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 70
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONBND
c  70 CONTINUE
C
c     DO 80 I=4,NZ
c     IVAR=IABS(LBETA(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 80
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONBND
c  80 CONTINUE
C
c     RETURN
c     END
      SUBROUTINE ESTIME(EIGVAL,FX,DD,SKAL,CHNGE,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1),FX(1)
      REAL*8 LAMDA,LAMDA0
      COMMON/IO/IN,IOUT
      COMMON/LAMBDA/LAMDA,LAMDA0,IT
C
C  ESTIMATE THE LIKELY ENERGY CHANGE DUE TO THE STEP D
C
      CHNGE=0.0D0
      DO 10 I=1,NVAR
      DUMMY=LAMDA
      IF(I.EQ.IT) DUMMY=LAMDA0
      TEMP=FX(I)*FX(I)*(DUMMY-EIGVAL(I)/2)
      TEMP=TEMP/( (DUMMY-EIGVAL(I))*(DUMMY-EIGVAL(I)) )
      CHNGE=CHNGE+TEMP
   10 CONTINUE
C
      CHNGE=CHNGE/(1+DD*DD)
C
C  SCALE THE ENERGY, IN CASE THE STEP WAS SCALED
C  (A SCALED ENERGY CHANGE IS LIKELY TO BE AN OVERESTIMATE)
C
      CHNGE=CHNGE*SKAL
C
      RETURN
      END
c     SUBROUTINE EXITEF(ICHAIN)
c     IMPLICIT REAL*8(A-H,O-Z)
c     REAL*8 GEN(47)
c     LOGICAL PRNT,NRFLAG,DUMP
c     COMMON/IO/IN,IOUT
c     COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
C
c     DATA IRWGEN/501/,LRWGEN/47/,  IGRDNT/511/,LGRDNT/1327/
c     DATA IZSUBS/570/,LZSUBS/175/, IOPTEF/575/,LOPTEF/2790/
C
C  LET SYNOPSIS ROUTINES KNOW IF JOB IS TERMINATING
C  (BY SETTING APPROPIATE FLAG IN GEN)
C
c     IF(ICHAIN.EQ.1) THEN
c     CALL FILEIO(2,-IRWGEN,LRWGEN,GEN,0)
c     GEN(3)=2.0D0
c     CALL FILEIO(1,-IRWGEN,LRWGEN,GEN,0)
C
C  COPY HESS INTO FRCNST AT SAME TIME CONTRACTING FULL MATRIX
C  INTO LOWER TRIANGLE
C  (THIS IS SO SYNOPSIS HAS A COPY OF THE FINAL DERIVATIVES)
C
c     CALL CNTRCT(FRCNST,HESS,NVAR)
c     ENDIF
C
C  UPDATE THE RW FILES AND EXIT
C
c     CALL DVCOPY(VALUES,X,NVAR)
c     CALL TWRITE(IGRDNT,ENERGY,LGRDNT,1,LGRDNT,1,0)
c     CALL TWRITE(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     CALL TWRITE(IOPTEF,X,LOPTEF,1,LOPTEF,1,0)
C
c     WRITE(IOUT,1000)
c     CALL CHAINX(ICHAIN)
c     RETURN
C
c1000  FORMAT(/' ',24('EF-'))
C
c     END
      SUBROUTINE FORMD(U,EIGVAL,FX,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50),EIGVAL(1),FX(1)
      REAL*8 LAMDA,LAMDA0,LAMDA1,LAMDA2
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
      COMMON/LAMBDA/LAMDA,LAMDA0,IT
C
      DATA ZERO/0.0D0/, HALF/0.5D0/, TOLL/1.0D-8/
      DATA STEP/0.05D0/, BIG/1.0D+3/, MAXIT/999/
C
C
C  TS SEARCH    FORMS A STEP BY P-RFO THAT TRIES TO MAXIMIZE
C               ALONG THE DIRECTION OF A CHOSEN HESSIAN MODE
C               AND MINIMIZE ALONG ALL OTHER MODES
C  MIN SEARCH   FORMS A STEP BY SIMPLE RFO THAT ATTEMPTS TO
C               MINIMIZE ALONG ALL HESSIAN MODES
C
C
      NUMIT=0
      IT=0
      IF(NEGREQ.EQ.0) GO TO 10
C
C  (A) MAXIMIZATION ALONG ONE OF THE HESSIAN MODES
C
      IF(MODE.NE.0) THEN
      CALL OVRLAP(U,NMODE,NVAR)
C
C  ON RETURN FROM OVRLAP, NMODE IS THE MODE ALONG WHICH
C  THE ENERGY IS TO BE MAXIMIZED
C
      IF(NMODE.NE.MODE) WRITE(IOUT,1000) MODE,NMODE
      MODE=NMODE
      IF(PRNT) WRITE(IOUT,1010) MODE
      IT=MODE
C
C  IF THE MODE BEING FOLLOWED IS NOW THE LOWEST MODE,
C  THEN SWITCH OFF MODE FOLLOWING
C
      IF(MODE.EQ.1) THEN
      MODE=0
      WRITE(IOUT,1015)
      ENDIF
C
      ELSE
C
      IF(PRNT) WRITE(IOUT,1020)
      IT=1
      ENDIF
C
      LAMDA0=EIGVAL(IT)+DSQRT(EIGVAL(IT)**2 +4.0D0*FX(IT)**2)
      LAMDA0=HALF*LAMDA0
      IF(PRNT) WRITE(IOUT,1030) LAMDA0
      IF(NVAR.EQ.1) GO TO 40
C
C  (B) MINIMIZATION ALONG ALL OTHER MODES
C
   10 CONTINUE
      JT=1+IT
      IF(JT.GT.2) JT=1
C
      IF(PRNT.AND.NEGREQ.EQ.1) WRITE(IOUT,1040)
      IF(PRNT.AND.NEGREQ.EQ.0) WRITE(IOUT,1050)
C
C  SOLVE ITERATIVELY FOR LAMDA
C  INITIAL GUESS FOR LAMDA IS ZERO EXCEPT NOTE THAT
C  LAMDA SHOULD BE LESS THAH EIGVAL(JT)
C
      LAMDA=ZERO
      IF(EIGVAL(JT).LT.ZERO) THEN
      LAMDA=EIGVAL(JT)-STEP
      LAMDA1=EIGVAL(JT)
      LAMDA2=-BIG
      ENDIF
C
   20 NUMIT=NUMIT+1
      TEMP=ZERO
      DO 25 I=1,NVAR
      IF(I.EQ.IT) GO TO 25
      TEMP=TEMP+(FX(I)*FX(I))/(LAMDA-EIGVAL(I))
   25 CONTINUE
      IF(DUMP) WRITE(IOUT,1111) LAMDA,TEMP
C
C  CHECK FOR CONVERGENCE OF LAMDA
C
      IF(DABS(LAMDA-TEMP).LT.TOLL) GO TO 30
C
C  CHECK FOR MAXIMUM ITERATIONS EXCEEDED
C
      IF(NUMIT.GT.MAXIT) GO TO 91
C
C  (A) SIMPLE ITERATIVE SCHEME
C      (USED IF EIGVAL(JT) > ZERO)
C
      IF(EIGVAL(JT).GT.ZERO) THEN
      LAMDA=TEMP
      GO TO 20
C
      ELSE
C
C  (B) CAUTIOUS BRACKETING SCHEME
C      (USED IF EIGVAL(JT) < ZERO)
C
      IF(TEMP.LT.LAMDA) LAMDA1=LAMDA
      IF(TEMP.GT.LAMDA) LAMDA2=LAMDA
      IF(LAMDA2.GT.-BIG) LAMDA=HALF*(LAMDA1+LAMDA2)
      IF(LAMDA2.EQ.-BIG) LAMDA=LAMDA-STEP
      GO TO 20
      ENDIF
C
C  AT THIS POINT WE HAVE AN ACCEPTABLE VALUE FOR LAMDA
C  MAKE FINAL CHECK ON ACCEPTABILITY
C
   30 IF(PRNT) WRITE(IOUT,1030) LAMDA
      IF(LAMDA.GT.EIGVAL(JT)) GO TO 90
      IF(EIGVAL(JT).GT.ZERO.AND.LAMDA.GT.ZERO) GO TO 90
C
C  CALCULATE THE STEP
C
   40 CALL ACLEAR(NVAR,D)
      DO 50 I=1,NVAR
      TEMP=FX(I)/(LAMDA-EIGVAL(I))
      IF(I.EQ.IT) TEMP=FX(I)/(LAMDA0-EIGVAL(I))
      DO 60 J=1,NVAR
      D(J)=D(J)+TEMP*U(J,I)
   60 CONTINUE
   50 CONTINUE
C
      RETURN
C
C  ...........................................................
C    ERROR SECTION
C
   90 CONTINUE
      WRITE(IOUT,1060)
c     CALL LNK1E
      stop
   91 CONTINUE
      WRITE(IOUT,1070)
c     CALL LNK1E
      stop
C
1000  FORMAT(' WARNING!! MODE SWITCHING. WAS FOLLOWING MODE ',I3,
     $       ' NOW FOLLOWING MODE ',I3)
C
1010  FORMAT(' SEARCHING FOR LAMDA THAT MAXIMIZES ALONG MODE ',I3)
C
1015  FORMAT(' MODE FOLLOWING SWITCHED OFF')
C
1020  FORMAT(' SEARCHING FOR LAMDA THAT MAXIMIZES ALONG THE',
     $       ' LOWEST MODE')
C
1030  FORMAT(' VALUE TAKEN    LAMDA= ',F12.8)
C
1040  FORMAT(' SEARCHING FOR LAMDA THAT MINIMIZES ALONG ALL',
     $       ' OTHER MODES')
C
1050  FORMAT(' SEARCHING FOR LAMDA THAT MINIMIZES ALONG ALL MODES')
C
1060  FORMAT(//' *****************************************'/
     $         ' ** ERROR IN DETERMINING LAMDA IN FORMD **'/
     $         ' *****************************************'//)
C
1070  FORMAT(//' ****************************************'/
     $         ' ** UNABLE TO DETERMINE LAMDA IN FORMD **'/
     $         ' ****************************************'//)
C
1111  FORMAT(' IN ITERATIVE CYCLE:  LAMDA= ',F12.8,' TEMP= ',F12.8)
C
      END
      SUBROUTINE FORMNR(U,EIGVAL,FX,D,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50),EIGVAL(1),FX(1),D(1)
C
C  TAKE THE NEWTON-RAPHSON STEP
C  (I.E. SET LAMDA TO ZERO)
C
      CALL ACLEAR(NVAR,D)
      DO 10 I=1,NVAR
      TEMP=-FX(I)/EIGVAL(I)
      DO 20 J=1,NVAR
      D(J)=D(J)+TEMP*U(J,I)
   20 CONTINUE
   10 CONTINUE
C
      RETURN
      END
c     SUBROUTINE GET202(ICHAIN,N)
c     IMPLICIT INTEGER(A-Z)
c     COMMON/TMPRTE/NCHAIN,LL,NLINK,PAD,LNK(200)
c     COMMON/IO/IN,IOUT
c     DATA IRWLNK/999/, LRWLNK/102/
C
C
C  THIS ROUTINE DETERMINES THE CORRECT VALUE FOR ICHAIN
C  IN ORDER FOR CHAINX TO RETURN TO THE NTH OCCURANCE
C  OF LINK 202 IN THE ROUTE
C  GET202 IS USED IN LINKS 104, 109, 110 AND 111.
C  THE ARGUMENT N TAKES THE FOLLOWING VALUES:
C    L104   N=1
C    L109   N=1 OR 2
C    L110   N=1
C    L111   N=1, 2 OR 3
C  IN LINKS 104/110 THIS ENSURES THAT ANALYTICAL SECOND
C  DERIVATIVES ARE USED WHEN RESETTING THE HESSIAN;
C  IN LINKS 109/111 N CONTROLS WHETHER GRADIENTS ARE
C  CALCULATED OR SKIPPED FOR THE CURRENT POINT.
C  N=3 IN L111 IS A FORWARD JUMP LEADING TO JOB TERMINATION
C
C
C  FIRST READ IN "LNK" WHICH CONTAINS THE ROUTE
C  NLINK IS THE CURRENT POSITION IN "LNK"
C
c     CALL TREAD(IRWLNK,NCHAIN,LRWLNK,1,LRWLNK,1,0)
C
C  GO TO THE BEGINNING OF THE ROUTE AND FIND THE NTH
C  OCCURANCE OF LINK 202
C
c     FOUND=0
c     DO 5 I=1,200
c     IF(MOD(LNK(I),10000).EQ.202) FOUND=FOUND+1
c     IF(FOUND.EQ.N) GO TO 10
c   5 CONTINUE
C
c     WRITE(IOUT,1000)
c1000  FORMAT(//' ***********************************'/
c    $         ' **  ERROR IN SUBROUTINE GET202   **'/
c    $         ' ** LINK 202 IS NOT IN THE ROUTE! **'/
c    $         ' ***********************************'//)
C
c     CALL LNK1E
c  10 CONTINUE
C
C  CALCULATE THE NEW VALUE OF ICHAIN
C
c     ICHAIN=I-NLINK-100
c     IF(N.EQ.3) ICHAIN=ICHAIN+200
C
c     RETURN
c     END
c     SUBROUTINE HESSEF
c     IMPLICIT REAL*8(A-H,O-Z)
c     LOGICAL PRNT,NRFLAG,DUMP
C
C
C  ..............................................
C
C  HESSIAN INITIALIZATION ROUTINE
C  (PUT SECOND DERIVATIVES INTO HESS)
C
C  ..............................................
C
C
C  THE HESSIAN CAN BE CALCULATED ANALYTICALLY OR ESTIMATED
C  NUMERICALLY. IT CAN ALSO BE READ IN OR ONLY PARTLY
C  ESTIMATED. THE FLAG THAT CONTROLS THIS IS IOP(10)
C
C    0   FOR A TS SEARCH ESTIMATE PART OR ALL OF THE HESSIAN
C        NUMERICALLY  (DEFAULT ALL)
C        FOR A MIN SEARCH ESTIMATE THE DIAGONAL ELEMENTS ONLY
C    1   READ IN FULL HESSIAN (LOWER TRIANGLE)
C    2   READ IN SELECTED ELEMENTS OF THE HESSIAN MATRIX
C        (REMAINDER SET TO ZERO)
C    3   READ HESSIAN FROM THE CHECKPOINT FILE
C    4   CALCULATE HESSIAN ANALYTICALLY
C    5   READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
C
C  NUMERICAL
C
C  FOR NUMERICAL ESTIMATION OF THE HESSIAN, HESSEF WILL BE
C  ENTERED NVAR TIMES (WHERE NVAR IS THE NUMBER OF PARAMETERS
C  TO BE OPTIMIZED); EACH ENTRY WILL ESTIMATE DERIVATIVES FOR
C  ONE OF THE PARAMETERS I.E. FOR ONE COLUMN OF THE HESSIAN
C  MATRIX. NOTE THAT THE PARAMETERS ARE STEPPED BY AN AMOUNT
C  DELTA IN ONE DIRECTION ONLY. AFTER NVAR ENTRIES THE ENTIRE
C  HESSIAN WILL HAVE BEEN ESTIMATED; IT IS THEN SYMMETRIZED
C  AND THEREAFTER WILL BE UPDATED AT EACH CYCLE.
C
C  ON THE INITIALIZATION STEP IT IS POSSIBLE TO REQUEST ONLY A
C  PARTIAL ESTIMATION OF THE HESSIAN  I.E. ONLY CERTAIN COLUMNS
C  WILL BE ESTIMATED. THIS IS CONTROLLED BY THE IC ARRAY. IT IS
C  ALSO POSSIBLE TO READ IN SPECIFIC DIAGONAL ELEMENTS. ANY OFF
C  DIAGONAL ELEMENTS NOT CALCULATED OR READ IN ARE SET TO ZERO;
C  ANY DIAGONAL ELEMENTS NOT CALCULATED OR READ IN ARE ESTIMATED
C  VIA THE ROUTINE ESTM.
C
C
C  ANALYTICAL
C
C  IF ANALYTICAL DERIVATIVES ARE AVAILABLE, THEN HESSEF WILL
C  BE ENTERED ONCE ONLY. DERIVATIVES WILL BE COPIED FROM THE
C  FRCNST ARRAY IN COMMON/GRDNT/ INTO HESS - THUS THE FULL
C  HESSIAN IS AVAILABLE IMMEDIATELY.
C
C
C  REESTIMATION
C
C  REESTIMATION OF THE HESSIAN CAN OCCUR PERIODICALLY THROUGHOUT
C  THE COURSE OF THE OPTIMIZATION IF REQUESTED. THIS IS CONTROLLED
C  BY IOP(11). AFTER EVERY IOP(11) STEPS, THE ENTIRE HESSIAN IS
C  RECALCULATED (EITHER NUMERICALLY OR ANALYTICALLY).
C
C
c     COMMON/IO/IN,IOUT
c     COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),OLDX(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
c     DATA DELTA/0.005D0/
C
C  THIS ROUTINE WILL ONLY BE ENTERED IF IHESS IS ZERO
C  I.E. THE HESSIAN IS NOT CURRENTLY AVAILABLE
C
C  CHECK IF ANALYTICAL DERIVATIVES ARE AVAILABLE
C
c     IF(IGETFC.EQ.4) THEN
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     IHESS=IHESS+1
c     WRITE(IOUT,1000)
c     RETURN
c     ENDIF
C
C  ESTIMATE CERTAIN COLUMNS OF THE HESSIAN NUMERICALLY
C  STORE CURRENT ENERGY, POSITION AND GRADIENTS
C  ESTIMATE ANY DIAGONAL ELEMENTS WHICH ARE NOT GOING
C  TO BE ESTIMATED NUMERICALLY BY CALLING ESTM
C
c     IF(IS.EQ.0) THEN
c     CALL ESTM
c     ES=ENERGY
c     CALL DVCOPY(OLDX,X,NVAR)
c     CALL DVCOPY(OLDF,F,NVAR)
c     ENDIF
C
C  ESTIMATION OF SECOND DERIVATIVES
C  UPDATE VARIABLES AND STEPLENGTH
C
c     IF(IS.GT.0) THEN
c     X(IS)=OLDX(IS)
c     DO 9 I=1,NVAR
c     HESS(IS,I)=(F(I)-OLDF(I))/DELTA
c   9 CONTINUE
c     ENDIF
C
C  NEXT POINT
C
c  10 IS=IS+1
c     IF(IS.LE.NVAR) THEN
c     IF(NSTEP.EQ.0.AND.IC(IS).NE.3) GO TO 10
c     X(IS)=OLDX(IS)+DELTA
c     RETURN
c     ENDIF
C
C  ESTIMATION COMPLETE
C  SYMMETRIZE THE NUMERICAL HESSIAN
C
c     CALL DMSYMM(HESS,NVAR)
c     ENERGY=ES
c     CALL DVCOPY(F,OLDF,NVAR)
c     IHESS=1
c     WRITE(IOUT,2000)
c     RETURN
C
c1000  FORMAT(' ANALYTICAL SECOND DERIVATIVES USED')
C
c2000  FORMAT(' HESSIAN INITIALIZED')
C
c     END
      SUBROUTINE INITEF(CORE)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 CORE(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT
c     COMMON/PHYCON/TOANG,PHYCON(29)
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVARRD
C
c     DATA IOZMAT/507/,LZMAT/351/, IZSUBS/570/,LZSUBS/175/
      DATA DELTA/0.005D0/, ZERO/0.0D0/
C
C
C  INITIALIZATION OF LINK 110 FOR GEOMETRY OPTIMIZATION
C
C  READ IN ZMAT AND ZSUBS AND CHECK FOR VALID NVARRD
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
c     CALL TREAD(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     IF(NVARRD.LT.1.OR.NVARRD.GT.50) THEN
c     WRITE(IOUT,1000) NVARRD
c     CALL LNK1E
c     ENDIF
C
C  MOVE RELEVANT DATA READ BY LINK 101 TO COMMON OPTEF
C
c     NVAR=NVARRD
c     NVTT=(NVAR*(NVAR+1))/2
C
c     CALL CBLANK(50*INTPWP(0),XNAME)
c     NC=0
c     JC=0
c     DO 9 I=1,NVAR
c     CALL GETB(2,ITMP,LEN,ANAMES,NC)
c     CALL PUTB(ITMP,LEN,XNAME,JC)
c     CALL PUTDEL(2,XNAME,JC)
c     X(I)=VALUES(I)
c     IC(I)=INTVEC(I)
c   9 CONTINUE
C
C  CHECK THE IC ARRAY
C  THE IC ARRAY IS READ IN WITH THE VARIABLES IN LINK 101
C  IT CAN CONTROL THE SETTING UP OF THE INITIAL HESSIAN (SEE BELOW)
C  AND ALSO DETERMINE IF HESSIAN MODE FOLLOWING IS SWITCHED ON.
C
c     MODE=0
c     DO 8 I=1,NVAR
c     IF(IC(I).GT.9) THEN
c     IC(I)=IC(I)-10
c     MODE=I+NVAR
c     ENDIF
c     IF(IC(I).GT.3) THEN
c     IC(I)=IC(I)-4
c     MODE=I
c     ENDIF
c     IF(IC(I).LT.0.OR.IC(I).GT.3) THEN
c     WRITE(IOUT,1005) I
c     CALL LNK1E
c     ENDIF
c   8 CONTINUE
C
C  ZERO OUT THE HESSIAN
C
c     CALL ACLEAR(2500,HESS)
C
C  SEE HOW TO OBTAIN INITIAL HESSIAN
C  THIS IS CONTROLLED BY IOP(10)
C    0    ESTIMATE HESSIAN NUMERICALLY OR VIA ESTM (DEFAULT)
C    1    READ IN FULL FRCNST MATRIX
C    2    READ IN SELECTED ELEMENTS OF FRCNST
C    3    READ FRCNST MATRIX FROM CHECKPOINT FILE
C    4    CALCULATE HESSIAN ANALYTICALLY
C    5    READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
c     IHOP=IOP(10)
c     IF(IOP(10).EQ.0) IHOP=6
c     IF(IHOP.GT.6.OR.IHOP.LE.0) THEN
c     WRITE(IOUT,1010) IHOP
c     CALL LNK1E
c     ENDIF
c     GO TO (110,120,130,140,130,150), IHOP
C
c 110 READ(IN,500) (FRCNST(I),I=1,NVTT)
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     GO TO 200
C
c 120 READ(IN,510) I,J,FFIN
c     IF(I.EQ.0) THEN
c     CALL CNTRCT(FRCNST,HESS,NVAR)
c     GO TO 200
c     ENDIF
c     HESS(I,J)=FFIN
c     HESS(J,I)=FFIN
c     GO TO 120
C
c 130 CALL READFC(IHOP,IOP(33),XNAME,CORE)
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     GO TO 200
C
c 140 DO 7 I=1,NVAR
c     IC(I)=-1
c     IDX=(I*(I+1))/2
c     FRCNST(IDX)=ZERO
c   7 CONTINUE
c     IGETFC=4
c     GO TO 200
C
c 150 CONTINUE
C
C  NUMERICAL ESTIMATION OF PART OR ALL OF THE HESSIAN
C  FIRST CHECK THE IC ARRAY
C  IF ALL OF THE ENTRIES ARE ZERO THEN
C   (A)  FOR A TS    CALCULATE THE ENTIRE HESSIAN NUMERICALLY
C   (B)  FOR A MIN   ESTIMATE THE DIAGONAL ELEMENTS ONLY
C  NOTE THAT FOR A TS, IF ONE OR MORE OF THE IC ENTRIES ARE NON-ZERO,
C  THEN HESSIAN ESTIMATION IS CONTROLLED ENTIRELY BY THE IC ARRAY
C
c     IDX=0
c     DO 6 I=1,NVAR
c     IF(IC(I).GT.0) IDX=IDX+1
c   6 CONTINUE
c     IF(IOP(5).EQ.0.AND.IDX.EQ.0) THEN
c     DO 5 I=1,NVAR
c     IC(I)=3
c   5 CONTINUE
c     ENDIF
C
c     DO 4 I=1,NVAR
c     IDX=(I*(I+1))/2
C
C  DELTA IS THE STEPLENGTH FOR NUMERICAL ESTIMATION OF THE
C  HESSIAN
C
c     IF(IC(I).EQ.3) FRCNST(IDX)=DELTA
c     IF(IC(I).EQ.1) FRCNST(IDX)=FPVEC(I)
c     HESS(I,I)=FRCNST(IDX)
c   4 CONTINUE
C
C  PRINT THE INITIAL SECOND DERIVATIVE TABLE
C
c 200 IF(IOP(10).NE.0.AND.IOP(10).NE.4) THEN
c     DO 3 I=1,NVAR
c     IC(I)=1
c   3 CONTINUE
c     ENDIF
c     CALL PRMTBL(0,XNAME,X,IC,FRCNST,NVAR,LBL,NZ,TOANG)
C
C
C  SET OPTIMIZATION CONTROL PARAMETERS
C
      NEGREQ=1
c     NSTEP=0
      MXSTEP=MIN0(NVAR+20,40)
c     IHESS=1
c     MXHESS=999999
      EIGMAX=25.0D0
      EIGMIN=0.0001D0
c     IS=0
      IUPDAT=0
      NRFLAG= IOP(19).NE.0
      PRNT = IOP(33).EQ.0
      DUMP = IOP(34).NE.0
      DMAX=0.3D0
      CONVF=0.0003D0
C
C  CHANGE DEFAULT VALUES IF INSTRUCTED BY OPTIONS
C
      IF(IOP(5).NE.0) NEGREQ=0
      IF(IOP(6).NE.0) MXSTEP=IOP(6)
c     IF(IOP(10).EQ.0.OR.IOP(10).EQ.4) IHESS=0
c     IF(IOP(11).NE.0) MXHESS=IOP(11)
c     IF(IOP(11).EQ.1.AND.IGETFC.EQ.4) MXHESS=999999
c     IF(IOP(11).EQ.1.AND.IGETFC.EQ.4) IHESS=-999999
      IF(IOP(13).NE.0) IUPDAT=IOP(13)
      IF(IOP(16).NE.0) EIGMAX=0.1D0*IOP(16)
      IF(IOP(17).NE.0) EIGMIN=1.0D0/IOP(17)
      IF(IOP(8).NE.0) DMAX=0.01D0*IOP(8)
c     IF(IOP(21).NE.0) THEN
c       DMAX=1.0D0
c       EIGMIN=ZERO
c       EIGMAX=1.0D+12
c     ENDIF
      IF(IOP(7).NE.0) CONVF=0.001D0/IOP(7)
C
C  CALCULATE REMAINING CONVERGENCE FACTORS
C
      CNVFMX=CONVF*1.5D0
      CONVX=CONVF*4.0D0
      CNVXMX=CONVX*1.5D0
C
C  PRINT OUT SELECTED PARAMETERS
C
c     IHOP=MXHESS
c     IF(IOP(11).EQ.1) IHOP=1
c     WRITE(IOUT,1020) MXSTEP,DMAX,IHOP
C
C  CHECK HESSIAN MODE FOLLOWING
C
      IF(MODE.GT.0 .and. nstep.lt.1) THEN
      IF(MODE.GT.NVAR) THEN
      IHOP=MODE-NVAR
      WRITE(IOUT,1025) IHOP
      ELSE
      WRITE(IOUT,1030) MODE
      ENDIF
      IF(MODE.GT.2*NVAR) WRITE(IOUT,1040)
c     IF(MODE.GT.2*NVAR) CALL LNK1E
      IF(MODE.GT.2*NVAR) stop
      ENDIF
C
      RETURN
C
 500  FORMAT(8F10.6)
 510  FORMAT(2I3,F20.0)
C
1000  FORMAT(//' ************************************************'/
     $         ' ** ERROR IN INITEF. NUMBER OF VARIABLES (',I3,') **'/
     $         ' **   INCORRECT (SHOULD BE BETWEEN 1 AND 50)   **'/
     $         ' ************************************************'//)
C
1005  FORMAT(//' CALL FROM INITEF:  BAD IC ENTRY FOR VARIABLE ',I3)
C
1010  FORMAT(//' CALL FROM INITEF:  OPTION 10 OUT OF RANGE ',
     $       ' IOP(10) = ',I4)
C
1020  FORMAT(//' ***************************************************'/
     $         ' ** O P T I M I Z A T I O N   P A R A M E T E R S **'/
     $         ' **  MAXIMUM NO. OF ITERATIONS      :  ',I10,' **'/
     $         ' **  MAXIMUM ALLOWED STEP LENGTH    :  ',F10.6,' **'/
     $         ' **  STEPS BEFORE HESSIAN REEVALUATED :  ',I8,' **'/
     $         ' ***************************************************'//)
C
1025  FORMAT(//' HESSIAN MODE FOLLOWING SWITCHED ON',/
     $       ' FOLLOWING MODE ',I3)
C
1030  FORMAT(//' HESSIAN MODE FOLLOWING SWITCHED ON',/
     $       ' FOLLOWING MODE WITH LARGEST MAGNITUDE COMPONENT',
     $       ' FOR VARIABLE ',I3)
C
1040  FORMAT(//' CALL FROM INITEF:  MODE FOLLOWING OUT OF RANGE')
C
      END
      SUBROUTINE MAGCHK(EIGVAL,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
      DATA ZERO/0.0D0/
C
C  FIRST CHECK IF THE MAGNITUDES OF THE LOWEST EIGENVALUES
C  EXCEED EIGMIN
C
      DO 10 I=1,NVAR
      IF(EIGVAL(I).GT.EIGMIN) GO TO 11
      IF(DABS(EIGVAL(I)).LT.EIGMIN) THEN
      IF(EIGVAL(I).LT.ZERO) EIGVAL(I)=-EIGMIN
      IF(EIGVAL(I).GE.ZERO) EIGVAL(I)= EIGMIN
      IF(PRNT) WRITE(IOUT,1000) I,EIGVAL(I)
      ENDIF
   10 CONTINUE
   11 CONTINUE
C
C  NOW CHECK IF THE MAGNITUDES OF THE HIGHEST EIGENVALUES
C  EXCEED EIGMAX
C
      DO 20 I=1,NVAR
      II=NVAR-I+1
      IF(EIGVAL(II).LT.EIGMAX) GO TO 21
      IF(DABS(EIGVAL(II)).GT.EIGMAX) THEN
      IF(EIGVAL(II).LT.ZERO) EIGVAL(II)=-EIGMAX
      IF(EIGVAL(II).GE.ZERO) EIGVAL(II)= EIGMAX
      IF(PRNT) WRITE(IOUT,2000) II,EIGVAL(II)
      ENDIF
   20 CONTINUE
   21 CONTINUE
C
      RETURN
C
1000  FORMAT(' WARNING! EIGENVALUE ',I2,' TOO SMALL. REPLACED',
     $       ' BY ',F12.6)
C
2000  FORMAT(' WARNING! EIGENVALUE ',I2,' TOO LARGE. REPLACED',
     $       ' BY ',F12.6)
C
      END
      SUBROUTINE OVRLAP(U,NMODE,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
C  ON THE FIRST STEP DETERMINE WHICH MODE TO FOLLOW
C
      IF(NSTEP.EQ.1) THEN
C
C  (A) FOLLOWING A GIVEN MODE
C
      IF(MODE.GT.NVAR) THEN
      IT=MODE-NVAR
      GO TO 10
      ENDIF
C
C  FIND THE HESSIAN EIGENVECTOR WITH THE LARGEST MAGNITUDE
C  COMPONENT IN THE POSITION GIVEN BY MODE (READ IN VIA IC ARRAY)
C
      IT=1
      TOVLP=DABS(U(MODE,1))
      DO 5 I=2,NVAR
      IF(DABS(U(MODE,I)).GT.TOVLP) THEN
      TOVLP=DABS(U(MODE,I))
      IT=I
      ENDIF
    5 CONTINUE
C
   10 MODE=IT
      IF(PRNT) WRITE(IOUT,1000) MODE
C
      ELSE
C
C  ON SUBSEQUENT STEPS DETERMINE WHICH HESSIAN EIGENVECTOR HAS
C  THE GREATEST OVERLAP WITH THE MODE WE ARE FOLLOWING
C
      IT=1
      TOVLP=DVTV(U(1,1),VMODE,NVAR)
      TOVLP=DABS(TOVLP)
      DO 6 I=2,NVAR
      OVLP=DVTV(U(1,I),VMODE,NVAR)
      OVLP=DABS(OVLP)
      IF(OVLP.GT.TOVLP) THEN
      TOVLP=OVLP
      IT=I
      ENDIF
    6 CONTINUE
C
      IF(PRNT) WRITE(IOUT,1010) TOVLP
      ENDIF
C
C  SAVE THE EIGENVECTOR IN VMODE
C
      DO 7 I=1,NVAR
      VMODE(I)=U(I,IT)
    7 CONTINUE
C
      NMODE=IT
      RETURN
C
1000  FORMAT(' HESSIAN MODE FOLLOWING SWITCHED ON'/
     $       ' FOLLOWING MODE ',I3)
C
1010  FORMAT(' OVERLAP OF CURRENT MODE WITH PREVIOUS MODE IS ',F12.6)
C
      END
      SUBROUTINE UPDATE(SVEC,TVEC)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SVEC(1),TVEC(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
     $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
      DATA ZERO/0.0D0/
C
C  UPDATING OF THE HESSIAN
C  DEPENDS ON CURRENT GRADIENTS, OLD GRADIENTS AND THE
C  CORRECTION VECTOR USED ON THE LAST CYCLE
C  SVEC & TVEC ARE FOR TEMPORARY STORAGE
C
C  2 UPDATING PROCEDURES ARE POSSIBLE
C  (I)   THE POWELL UPDATE
C        THIS PRESERVES THE SYMMETRIC CHARACTER OF THE HESSIAN
C        WHILST ALLOWING ITS EIGENVALUE STRUCTURE TO CHANGE.
C        IT IS THE DEFAULT UPDATE
C  (II)  THE BFGS UPDATE
C        THIS UPDATE HAS THE IMPORTANT CHARACTERISTIC OF RETAINING
C        POSITIVE DEFINITENESS (NOTE: THIS IS NOT RIGOROUSLY
C        GUARANTEED) WHICH CAN BE USEFUL FOR A MINIMUM SEARCH.
C        SHOULD BE USED IN CONJUNCTION WITH "MIN".
C
C
      CALL DMDOTV(TVEC,HESS,D,NVAR)
C
      IF(IUPDAT.EQ.0) THEN
C
C   (I) POWELL UPDATE
C
      IF(PRNT) WRITE(IOUT,1000)
C
      DO 9 I=1,NVAR
      TVEC(I)=F(I)-OLDF(I)-TVEC(I)
    9 CONTINUE
      DDS=DD*DD
      DDTD=DVTV(TVEC,D,NVAR)
      DDTD=DDTD/DDS
C
      DO 10 I=1,NVAR
      DO 11 J=1,I
      TEMP=TVEC(I)*D(J) + D(I)*TVEC(J) - D(I)*DDTD*D(J)
      HESS(I,J)=HESS(I,J)+TEMP/DDS
      HESS(J,I)=HESS(I,J)
   11 CONTINUE
   10 CONTINUE
C
      ELSE
C
C  (II) BFGS UPDATE
C
      IF(PRNT) WRITE(IOUT,2000)
C
      DO 19 I=1,NVAR
      SVEC(I)=F(I)-OLDF(I)
   19 CONTINUE
      DDS=DVTV(SVEC,D,NVAR)
C
C  IF DDS IS NEGATIVE, RETENTION OF POSITIVE DEFINITENESS IS NOT
C  GUARANTEED. PRINT A WARNING AND SKIP THE UPDATE THIS TIME IF
C  REQUESTED
C
      IF(DDS.LT.ZERO) THEN
      WRITE(IOUT,1500)
      IF(IUPDAT.EQ.2) THEN
      WRITE(IOUT,1600)
      RETURN
      ENDIF
      ENDIF
C
      DDTD=DVTV(D,TVEC,NVAR)
C
      DO 20 I=1,NVAR
      DO 21 J=1,I
      TEMP= (SVEC(I)*SVEC(J))/DDS - (TVEC(I)*TVEC(J))/DDTD
      HESS(I,J)=HESS(I,J)+TEMP
      HESS(J,I)=HESS(I,J)
   21 CONTINUE
   20 CONTINUE
      ENDIF
C
      RETURN
C
1000  FORMAT(' HESSIAN UPDATED USING POWELL UPDATE')
C
1500  FORMAT(' WARNING! HEREDITARY POSITIVE DEFINITENESS ENDANGERED')
C
1600  FORMAT(' UPDATE SKIPPED THIS CYCLE')
C
2000  FORMAT(' HESSIAN UPDATED USING BFGS UPDATE')
C
      END
      SUBROUTINE FNDNEG(EIGVAL,NEG,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1)
      DATA ZERO/0.0D0/
C
C  FIND THE NUMBER OF NEGATIVE EIGENVALUES
C  THIS WILL BE RETURNED IN NEG
C
      DO 9 I=1,NVAR
      IF(EIGVAL(I).GT.ZERO) GO TO 10
    9 CONTINUE
   10 NEG=I-1
C
      RETURN
      END
      SUBROUTINE CNTRCT(A,B,N)
      REAL*8 A(1),B(50,1)
C
C  CONTRACTS A FULL MATRIX B INTO A SINGLE SUBSCRIPT
C  LOWER TRIANGLE ARRAY A
C
      DO 10 I=1,N
      II=(I*(I-1))/2
      DO 10 J=1,I
      IJ=II+J
      A(IJ)=B(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE EXPAND(A,B,N)
      REAL*8 A(50,1),B(1)
C
C  EXPANDS A SINGLE SUBSCRIPT LOWER TRIANGLE ARRAY B
C  INTO A FULL MATRIX A
C
      DO 10 I=1,N
      II=(I*(I-1))/2
      DO 10 J=1,I
      IJ=II+J
      A(I,J)=B(IJ)
      A(J,I)=A(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVSKAL(A,B,SCALE,N)
      REAL*8 A(1),B(1),SCALE
C
C  A = B * SCALE
C
      DO 10 I=1,N
      A(I)=B(I)*SCALE
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVADDV(A,B,C,N)
      REAL*8 A(1),B(1),C(1)
C
C  A = B + C
C
      DO 10 I=1,N
      A(I)=B(I)+C(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVNEGV(A,B,C,N)
      REAL*8 A(1),B(1),C(1)
C
C  A = B - C
C
      DO 10 I=1,N
      A(I)=B(I)-C(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVCOPY(A,B,N)
      REAL*8 A(1),B(1)
C
C  COPIES VECTOR B INTO A
C
      DO 10 I=1,N
      A(I)=B(I)
   10 CONTINUE
C
      RETURN
      END
      FUNCTION DVTV(A,B,N)
      REAL*8 A(1),B(1)
C
C  DVTV = A' * B
C
      DVTV=0.0D0
      DO 10 I=1,N
      DVTV=DVTV+A(I)*B(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DNEGV(A,N)
      REAL*8 A(1)
C
C  A = -A
C
      DO 10 I=1,N
      A(I)=-A(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMDOTV(A,B,C,N)
      REAL*8 A(1),B(50,1),C(1)
      DATA ZERO/0.0D0/
C
C  A = B * C
C
      DO 10 I=1,N
      A(I)=ZERO
      DO 10 J=1,N
      A(I)=A(I)+B(I,J)*C(J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMCOPY(A,B,N)
      REAL*8 A(50,1),B(50,1)
C
C  COPIES MATRIX B INTO A
C
      DO 10 I=1,N
      DO 10 J=1,N
      A(I,J)=B(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMSYMM(A,N)
      REAL*8 A(50,1)
      DATA HALF/0.5D0/
C
C  SYMMETRIZES A MATRIX A
C
      DO 10 I=2,N
      DO 10 J=1,I-1
      A(I,J)=HALF*(A(I,J)+A(J,I))
      A(J,I)=A(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMPRNT(A,N,IOUT)
      REAL*8 A(50,1)
C
C  PRINTS OUT THE MATRIX A
C
      LOW=1
      NUP=6
   10 NUP=MIN0(NUP,N)
      WRITE(IOUT,1000) (I,I=LOW,NUP)
      DO 20 I=1,N
      WRITE(IOUT,2000) I,(A(I,J),J=LOW,NUP)
   20 CONTINUE
      NUP=NUP+6
      LOW=LOW+6
      IF(LOW.LT.N) GO TO 10
C
      RETURN
C
1000  FORMAT(1X,6I12)
C
2000  FORMAT(1X,I3,6F12.6)
C
      END
      subroutine convgd(A,B,ireslt)
      real*8 a,b
      character*3 ireslt
c
c  A < B ?
c
      if(a.lt.b) then
          ireslt = 'YES'
          else
          ireslt = ' NO'
          endif
      return
c
      end
      subroutine aclear(n,a)
      real*8 a(n)
c
c  A = 0
c
      do 10 i=1,n
 10   a(i) = 0.0d0
      return
c
      end
