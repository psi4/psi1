C BMATIN3     FINAL MODIFIED VERSION OF PULAY'S BMATIN PROGRAM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER AI*80,WKEY1*4,WKEY2*4
      INTEGER INP,IOUT,INP2,IPUN,IGMUP
      COMMON /GANZ/ NA,LOPT(16)
      PARAMETER(INP=30,IOUT=6,INP2=32,IPUN=33,IGMUP=5)
      PARAMETER(WKEY1='BMAT',WKEY2='STOP')
c
      call drum
      open (unit=inp,file='bmat.dat',status='old')
      open (unit=ipun,file='bmat.punch',status='unknown')
      call wind(ipun)
      open (unit=inp2,file='bmat.inp2',status='unknown')
c
      DO 60 I=1,16
         LOPT(I)=0
   60 CONTINUE
   30 READ (INP,100) AI
      WRITE(IOUT,105) AI
         IF (AI(1:4).EQ.WKEY1) GO TO 50
      GO TO 80
   50 CONTINUE
      CALL FIFTH (INP,IOUT,INP2,IPUN,IGMUP)
      GO TO 30
   80 CONTINUE
 
  100 FORMAT (A80)
  105 FORMAT ('1',///,1X,A80)
 
      END
C     //////////////////////////////////////////////////////////
      SUBROUTINE FIFTH(INP,IOUT,INP2,IPUN,IGMUP)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER INP,IOUT,INP2,IPUN,IGMUP
      INTEGER P,Q,NR
      CHARACTER WO*4,WK(16)*4,W1*2
      INTEGER INDI(4,50),INDT(4)
      LOGICAL WRIT
      DIMENSION CCIN(4,50),CIN(4),CCC(75),ETA(4),ENERGY(4)
      DIMENSION CI(9),AE(3)
      DIMENSION SYMB(25)
      DIMENSION LFLAG(4)
      DIMENSION QQQ(69),FII(69)
      DIMENSION WW(2)
      DIMENSION L(69), M(69), KI(75), IA(25)
      DIMENSION IFIX(20),IBOHR(40)
      COMMON /ENER/ TITLE(16)
      COMMON /GANZ/ NA,LOPT(16)
      COMMON BL(1),C(4761),F(75),FI(69),CC(75),XA(25),YA(25),ZA(25),XM(7
     15),XY(75),QQ1(75),QQ(69),B(75,69)
      EQUIVALENCE (B(1,1),WW(1))
      PARAMETER(ZERO=0.0D0,HALF=0.5D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER(THREE=3.0D0,FOUR=4.0D0,FIVE=5.0D0,TEN=10.0D0)
      PARAMETER(ANG=1.889726664D0,GDYN=8.2388575D0)
      PARAMETER(FSUMT=1.0D-7,CRTTOL=1.0D-12,MXITER=40)
      PARAMETER(RADC=57.29577951308D0)
      DATA (WK(I),I=1,6)/'CARD','FMAT','DISP','OLDF','PUNC','PRIN'/
      DATA (WK(I),I=7,12)/'ANGS','FIXC','FINT','FLT1','EXFI','BOHR'/
      DATA (WK(I),I=13,16)/'FLT2','GDYN','OLDH','DEGR'/
      DATA XNIST/2HN=/
      REWIND INP2
      IX=INP
      NMAX=25
      NCMAX=3*NMAX
      NQMAX=NCMAX-6
      LFLAG(1)=0
      NFIX=0
C
C     DIMENSION OF THE B MATRIX MUST CONFORM TO B(NCMAX,NQMAX)
C
C1................................................................
   10 READ(INP,500) WO,NR
      DO 20 I=1,16
         IF (WK(I).EQ.WO) GO TO 30
   20 CONTINUE
      BACKSPACE INP
      GO TO 40
   30 LOPT(I)=1
      WRITE(IOUT,510) WO,NR
   32 IF(I.EQ.1) NA=NR
      IF (I.EQ.3) LOPT(3)=NR
      IF (I.EQ.3.AND.LOPT(3).EQ.0) LOPT(3)=1
      IF(I.EQ.8) THEN
           NFIX=NFIX+1
           IFIX(NFIX)=NR
      END IF
      IF(I.EQ.10) THEN
           BACKSPACE INP
           READ(INP,505) WO,ETA(1),ETA(2),ETA(3),ETA(4)
      END IF
      IF(I.EQ.13) THEN
           BACKSPACE INP
           READ(INP,506) WO,(ETA(K),ENERGY(K),K=1,3)
           WRITE(IOUT,853) WO,(ETA(K),ENERGY(K),K=1,3)
           LOPT(10)=1
      END IF
      GO TO 10
C2.............................................................
   40 CONTINUE
      IF(LOPT(11).EQ.0) GO TO 44
      DO 43 I=1,NA
      READ(INP2,511)W1
      IF(W1.NE.'N=') THEN
         WRITE(IOUT,512) W1
         RETURN
      END IF
   43 CONTINUE
C.............................................................
   44 CONTINUE
      IF (NA.GT.0.AND.NA.LE.NMAX) GO TO 50
      WRITE (IOUT,520)  NA
      RETURN
   50 CONTINUE
      N=NA
      IF (LOPT(1).NE.1) GO TO 140
C3..............................................................
      WRITE( IOUT,530)
      DO 70 I=1,NA
         I3=3*I
         READ(INP,540) SYMB(I),IA(I),XA(I),YA(I),ZA(I),XM(I3)
      IF  (XM(I3).EQ.ZERO) XM(I3)=ONE
      IF (LOPT(7).EQ.1) GO TO 60
      XA(I)=XA(I)/ANG
      YA(I)=YA(I)/ANG
      ZA(I)=ZA(I)/ANG
   60 CONTINUE
      XXWA=XA(I)*ANG
      YYWA=YA(I)*ANG
      ZZWA=ZA(I)*ANG
      WRITE( IOUT,550) I,IA(I),XXWA,YYWA,ZZWA,XM(I3)
      XM(I3)=ONE/XM(I3)
      XM(I3-1)=XM(I3)
      XM(I3-2)=XM(I3)
   70 CONTINUE
C4.............................................................
      NEK=3*NA
      IF (LOPT(3).GT.0) GO TO 90
      IF (LOPT(9).GT.0) GO TO 140
C5..............................................................
      READ (INP,560) (F(I),I=1,NEK)
      IF(LOPT(14).EQ.1) GO TO 74
      DO 72  I=1,NEK
      F(I)=-F(I)*GDYN
   72 CONTINUE
   74 CONTINUE
      WRITE(IOUT,570)
      WRITE(IOUT,580) (F(I),I=1,NEK)
C6.............................................................
      XFQX=F(1)
      DO 80 I=2,NEK
   80 XFQX=XFQX+F(I)
      IF(DABS(XFQX).GT.FSUMT) WRITE (IOUT,590) XFQX
      IF(LOPT(3).LE.0) GO TO 140
   90 CONTINUE
C7......................................................................
      NDI=LOPT(3)
      DO 100 I=1,NDI
  100    READ (INP,600) (INDI(J,I),CCIN(J,I),J=1,4)
      IF(LOPT(12).NE.1) GO TO 140
      NBOHR=0
      IQ=0
      KB=0
  102 KB=KB+1
      READ(INP,601) WO,W1
      IF(WO(1:1).NE.'K'.AND.WO.NE.'    ') GO TO 110
      IF(WO(1:1).EQ.'K')THEN
           IQ=IQ+1
           IF(W1.EQ.'ST')THEN
           NBOHR=NBOHR+1
           IBOHR(NBOHR)=IQ
           END IF
      END IF
      GO TO 102
  110 DO 112  I=1,KB
  112 BACKSPACE INP
      DO 114  K=1,NBOHR
      DO 114  I=1,NDI
      DO 114  J=1,4
         IF(INDI(J,I).EQ.IBOHR(K))THEN
         CCIN(J,I)=CCIN(J,I)/ANG
         ELSE IF (LOPT(16).EQ.1) THEN
         CCIN(J,I)=CCIN(J,I)/RADC
         END IF
  114 CONTINUE
  140 CONTINUE
C8......................................................................
      WRIT=.FALSE.
      IF (LOPT(6).EQ.1) WRIT=.TRUE.
      CALL MACHB (NEK,B,NCMAX,NQMAX,XA,YA,ZA,QQ,N,IX,IOUT,NQ,WRIT,.FALSE
     1.,NCARD)
      IF(LOPT(5).NE.1) GO TO 151
      WRITE(IPUN,802)
      WRITE (IPUN,610)
      DO 150 I=1,NQ
          WRITE (IPUN,615) I
          WRITE (IPUN,620) (B(J,I),J=1,NEK)
  150 CONTINUE
C9......................................................................
  151 CONTINUE
      I1=0
      DO 170 I=1,NQ
      DO 170 J=1,NQ
      I1=I1+1
      S=ZERO
      DO 160 K=1,NEK
  160 S=S+B(K,I)*B(K,J)*XM(K)
  170 C(I1)=S
      TOL=1.0D-8
      CALL OSINV1 (C,NQ,D,TOL,L,M)
C10.....................................................................
      WRITE (IOUT,630) D
      IF (LOPT(3).GT.0) GO TO 320
C11.....................................................................
      WRITE( IOUT,640)
      DO 190 I=1,NQ
         T=ZERO
         DO 180 J=1,NEK
  180      T=T+B(J,I)*F(J)*XM(J)
  190 CC(I)=T
C12.....................................................................
      IJ=0
      DO 203 I=1,NQ
         T=ZERO
      IF(LOPT(9).GT.0) GO TO 201
         DO 200 J=1,NQ
            IJ=IJ+1
  200    T=T+C(IJ)*CC(J)
         FI(I)=T
C13.....................................................................
  201 IF(LOPT(9).LE.0) GO TO 202
      READ(INP,560) FI(I)
      NCARD=NCARD+1
  202 CONTINUE
      WRITE (IOUT,650) I,QQ(I),FI(I)
      QQQ(I)=QQ(I)
      FII(I)=FI(I)
  203 CONTINUE
      WRITE(IPUN,660) (FI(I),I=1,NQ)
      IF(LOPT(10).GE.1.AND.LOPT(13).LT.1) WRITE(IOUT,818)
      IF(LOPT(13).GE.1) WRITE(IOUT,815)
  226 CONTINUE
C14.....................................................................
      IF (LOPT(2).LT.1) GO TO 490
      IF(LOPT(10).GE.1) THEN
           WRITE(IOUT,672)
      ELSE
           WRITE(IOUT,670)
      END IF
      IF(LOPT(11).GT.0) IX=INP2
      DO 228 I=1,NQ
      READ(IX,660)(F(J),J=1,I)
         WRITE (IOUT,710) (F(J),J=1,I)
      IF (LOPT(11).GT.0) GO TO 227
      NCARD=NCARD+1+(I-1)/8
  227 CONTINUE
C15............................................................
      DO 228 J=1,I
      IJ=(I-1)*NQ+J
      JI=(J-1)*NQ+I
      C(JI)=F(J)
      C(IJ)=C(JI)
  228 CONTINUE
      IX=INP
      CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
C16............................................................
      IF (LOPT(4).LT.1.AND.LOPT(15).LT.1) GO TO 270
C17............................................................
      WRITE(IOUT,680)
      IF(LOPT(11).GT.0) IX=INP2
      DO 230 I=1,NQ
      READ(IX,655)CC(I),F(I)
      WRITE (IOUT,650) I,CC(I),F(I)
      IF(LOPT(11).GT.0) GO TO 229
      NCARD=NCARD+1
  229 CONTINUE
         CC(I)=QQ(I)-CC(I)
         F(I)=FI(I)-F(I)
  230 CONTINUE
C18................................................................
      IX=INP
      IF(LOPT(15).GE.1) GO TO 261
      S1=ZERO
      IJ=0
      DO 250 I=1,NQ
         S=ZERO
         DO 240 J=1,NQ
            IJ=IJ+1
            S=S+C(IJ)*F(J)
  240 CONTINUE
         CC(I)=CC(I)+S
         S1=S1+CC(I)*F(I)
  250 CONTINUE
      S1=ONE/S1
      IJ=0
      DO 260 I=1,NQ
      DO 260 J=1,NQ
         IJ=IJ+1
         C(IJ)=C(IJ)-CC(I)*CC(J)*S1
  260 CONTINUE
  261 IF(LOPT(4).GE.1) GO TO 270
      IJ=0
      DO 262  I=1,NQ
      S=ZERO
      DO 263  J=1,NQ
      IJ=IJ+1
  263 S=S-C(IJ)*F(J)
  262 CCC(I)=S
      S=ZERO
      S1=ZERO
      DO 264  I=1,NQ
      S=S-CC(I)*F(I)
  264 S1=S1+CCC(I)*F(I)
      IJ=0
      DO 265  I=1,NQ
      DO 265  J=1,NQ
      IJ=IJ+1
  265 C(IJ)=C(IJ)+CC(I)*CC(J)/S+CCC(I)*CCC(J)/S1
  270 CONTINUE
C19..............................................................
      IJ=0
      DO 290 I=1,NQ
        S=ZERO
         DO 280 J=1,NQ
         IJ=IJ+1
         S=S+C(IJ)*FI(J)
  280    CONTINUE
         QQ1(I)=S
  290 CONTINUE
C20..............................................................
      IF(NFIX.EQ.0) GO TO 298
      DO 295  I=1,NFIX
  295  QQ1(IFIX(I))=ZERO
C21.............................................................
  298 IF(LOPT(10).GE.1) THEN
      WRITE(IOUT,692)
      ELSE
      WRITE(IOUT,690)
      END IF
      FLAMDA=0.0D0
      DO 300 I=1,NQ
      FLAMDA=FLAMDA+QQ1(I)*FII(I)
         QQ(I)=QQ(I)+QQ1(I)
         WRITE (IOUT,650) I,QQ1(I),QQ(I)
      QQ(I)=QQ(I)-QQ1(I)
      CC(I)=QQ1(I)
  300 CONTINUE
C22......................................................
      IF(LOPT(4).GT.0.OR.LOPT(15).GT.0) GO TO 301
      CALL OSINV1 (C,NQ,D,1.0E-8,L,M)
      REWIND INP2
      IJ=1
      DO 302 I=1,NQ
      IJ1=IJ+I-1
      WRITE(INP2,720)(C(J),J=IJ,IJ1)
      IJ=IJ+NQ
  302 CONTINUE
      IF(LOPT(10).GT.0) GO TO 309
      IF(LOPT(4).LT.1) GO TO 361
C23.......................................................
  301 WRITE(IOUT,700)
      CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
      REWIND INP2
      IJ=1
      IF(LOPT(5).EQ.1) WRITE(IPUN,670)
      DO 310 I=1,NQ
         IJ1=IJ+I-1
      WRITE(IOUT,710) (C(J),J=IJ,IJ1)
      WRITE(INP2,720)(C(J),J=IJ,IJ1)
      IF (LOPT(5).EQ.1) WRITE(IPUN,720) (C(J),J=IJ,IJ1)
         IJ=IJ+NQ
  310 CONTINUE
      IF(LOPT(4).GE.1) GO TO 361
  309 DO 311  I=1,NQ
  311 CCC(I)=QQ1(I)
      IF(LOPT(13).EQ.1) GO TO 314
      IFLT=1
  312 IF(ETA(IFLT).EQ.ZERO) GO TO 484
      DO 313  I=1,NQ
      QQ(I)=QQQ(I)
      QQ1(I)=ETA(IFLT)*CCC(I)
  313 CC(I)=QQ1(I)
      WRITE(IOUT,820) ETA(IFLT)
      GO TO 361
  314 IJ=1
      IF(ENERGY(3).GE.0.0D0) GO TO 321
      DO 315  I=1,3
      CI(IJ)=1
      CI(IJ+1)=ETA(I)
      CI(IJ+2)=ETA(I)**2
  315 IJ=IJ+3
      CALL OSINV1(CI,3,D,1.0E-8,L,M)
      IJ=0
      DO 316  I=1,3
      S=ZERO
      DO 317  J=1,3
      IJ=IJ+1
  317 S=S+CI(IJ)*ENERGY(J)
  316 AE(I)=S
      ETA(4)=-AE(2)/(TWO*AE(3))
      ENERGY(4)=ETA(4)*(ETA(4)*AE(3)+AE(2)) +AE(1)
      GO TO 322
  321 WRITE(IOUT,*) 'FLAMDA=',FLAMDA
      FLAMDA=FLAMDA*ANG/GDYN
      ELAMDA=(ENERGY(1)-ENERGY(2))/ETA(1)+FLAMDA
      ETA(4)=FLAMDA*ETA(1)/(2.0D0*ELAMDA)
      ENERGY(4)=ENERGY(2)-FLAMDA*ETA(4)/2.0D0
  322 IFLT=4
      DO 319  I=1,NQ
      QQ(I)=QQQ(I)
      QQ1(I)=ETA(IFLT)*CCC(I)
  319 CC(I)=QQ1(I)
      WRITE(IOUT,830) ENERGY(4)
      WRITE(IOUT,832) ETA(4)
      GO TO 361
C24...............................................................
  320 CONTINUE
        WRITE(IOUT,730)
         WRITE(IOUT,740) (QQ(J),J=1,NQ)
      II=0
  325 II=II+1
         DO 330 J=1,4
            INDT(J)=INDI(J,II)
  330       CIN(J)=CCIN(J,II)
      WRITE(IOUT,802)
      WRITE(IOUT,750) (INDT(J),CIN(J),J=1,4)
      DO 340 J=1,NQ
         CC(J)=ZERO
  340 CONTINUE
      DO 350 J=1,4
      J1=INDT(J)
        IF (J1.LE.0) GO TO 350
      CC(J1) = CIN(J)
  350 CONTINUE
      DO 360 J=1,NQ
  360   QQ1(J)=CC(J)
      GO TO 362
C25..................................................................
  361 DO 363 I=1,NCARD
      BACKSPACE INP
  363 CONTINUE
C26..................................................................
      CALL MACHB(NEK,B,NCMAX,NQMAX,XA,YA,ZA,QQ,N,IX,IOUT,NQ,.FALSE.,
     1 .FALSE.,NCARD)
      I1=0
      DO 364 I=1,NQ
      DO 364 J=1,NQ
      I1=I1+1
      S=ZERO
      DO 365 K=1,NEK
  365 S=S+B(K,I)*B(K,J)*XM(K)
  364 C(I1)=S
      CALL OSINV1(C,NQ,D,TOL,L,M)
  362 CONTINUE
C27...................................................................
         IREP=0
         I3=0
         DO 370 I=1,N
            XY(I)=XA(I)
         J=I+N
         XY(J)=YA(I)
         J=J+N
         XY(J)=ZA(I)
  370    CONTINUE
C28.....................................................................
  380    CONTINUE
      IREP=IREP+1
         IJ=0
         DO 400 I=1,NQ
            S=ZERO
         DO 390 J=1,NQ
               IJ=IJ+1
               S=S+C(IJ)*QQ1(J)
  390 CONTINUE
         FI(I)=S
  400 CONTINUE
C29.....................................................................
         DO 420 I=1,NEK
            S=ZERO
            DO 410 J=1,NQ
               S=S+B(I,J)*FI(J)
  410       CONTINUE
         QQ1(I)=S*XM(I)
  420    CONTINUE
         I3=0
C30..................................................................
         DO 430 I=1,N
            I3=I3+3
            XY(I)=XY(I)+QQ1(I3-2)
            J=I+N
            XY(J)=XY(J)+QQ1(I3-1)
            J=J+N
            XY(J)=XY(J)+QQ1(I3)
  430   CONTINUE
         I2=2*N+1
         DO 440 I=1,NCARD
            BACKSPACE INP
  440 CONTINUE
C31...................................................................
         CALL MACHB (NEK,B,NCMAX,NQMAX,XY(1),XY(N+1),XY(I2),QQ1,N,IX,IOU
     1   T,NQ,.FALSE.,.TRUE.,NCARD)
          WRITE (IOUT,760) IREP
         WRITE  (IOUT,740)  (QQ1(I),I=1,NQ)
         QMAX=ZERO
         DO 450 I=1,NQ
            QQ1(I)=QQ(I)+CC(I)-QQ1(I)
            IF  (QMAX.LT.DABS(QQ1(I)))  QMAX=ABS(QQ1(I))
  450    CONTINUE
         IF (IREP.LT.MXITER.AND.QMAX.GT.CRTTOL) GO TO 380
C32....................................................................
         IF (QMAX.GT.CRTTOL) WRITE(IOUT,801)
         WRITE(IOUT,770)
  460    CONTINUE
         I3=0
         DO 470 I=1,N
            I3=I3+3
            YM=ONE/XM(I3)
            J=I+N
            J1=J+N
            X=XY(I)-XA(I)
            Y=XY(J)-YA(I)
            Z=XY(J1)-ZA(I)
            WRITE (IOUT,790) I,IA(I),X,Y,Z,YM
  470    CONTINUE
         WRITE(IOUT,803)
      I3=0
      DO 472  I=1,N
           J=I+N
           J1=J+N
           I3=I3+3
           YM=ONE/XM(I3)
           WRITE(IOUT,790) I,IA(I),XY(I),XY(J),XY(J1),YM
  472 CONTINUE
C33...................................................................
      IF(LOPT(2).EQ.1) GO TO 482
  480 CONTINUE
      IF(II.LT.NDI) GO TO 479
C34..............................................................
  482 REWIND INP2
      IF(LOPT(3).GT.0) GO TO 483
      JJ=1
      DO 481 I=1,NQ
      IJ1=JJ + I -1
      READ(INP2,720)(C(J),J=JJ,IJ1)
      JJ=JJ+NQ
  481 CONTINUE
C35...............................................................
  483 REWIND INP2
  479 WRITE(IOUT,772)
      CALL LOCATE (IGMUP,'# GEOML ##',IERRWA)
      BACKSPACE IGMUP
      WRITE(IGMUP,'(A10)') '# GEOMUP #'
      DO 484 I=1,N
      J=I+N
      J1=J+N
      X=XY(I)*ANG
      Y=XY(J)*ANG
      Z=XY(J1)*ANG
      WRITE(IGMUP,850) X,Y,Z
  491 WRITE(IOUT,792) I,IA(I),X,Y,Z
  484 CONTINUE
      WRITE(IGMUP,'(A10)')  '# GEOML ##'
      IF(II.LT.NDI) GO TO 325
      IF(LOPT(10).GE.1.AND.IFLT.LT.4) THEN
           IFLT=IFLT+1
           GO TO 312
      END IF
C36...........................................................
      IF(LOPT(3).GT.0) GO TO 487
      DO 497 I=1,N
      J=I+N
      J1=J+N
      X=XY(I)*ANG
      Y=XY(J)*ANG
      Z=XY(J1)*ANG
      WRITE(INP2,800)SYMB(I),IA(I),X,Y,Z
  497 CONTINUE
      JJ=1
      DO 485 I=1,NQ
      IJ1=JJ+I-1
      WRITE(INP2,720)(C(J),J=JJ,IJ1)
      JJ=JJ+NQ
  485 CONTINUE
      DO 486 I=1,NQ
  486 WRITE(INP2,655) QQQ(I),FII(I)
  487 CONTINUE
      REWIND INP2
  490 RETURN
C
  500 FORMAT (A4,6X,I2)
  502 FORMAT(10X,2F10.3)
  505 FORMAT(A4,6X,4F6.0)
  506 FORMAT(A4,8X,3(F6.0,F16.10))
  510 FORMAT(1X,A4,2X,13HOPTION IS ON ,I2)
  511 FORMAT(1X,A2)
  512 FORMAT(1X,'EXFI READ ERROR--',A2)
  520 FORMAT (1X,16HTOO MANY NUCLEI ,I5)
  530 FORMAT (20X,28HNUCLEAR COORDINATES IN BOHRS    ,/)
  540 FORMAT(2X,A4,4X,I2,4X,3F16.12,F10.5)
  550 FORMAT (3X,I2,3X,I2,3(F16.12,2X),F12.6)
  560 FORMAT (3F16.12)
  570 FORMAT (//,1X,6HFORCES,/)
  580 FORMAT (1X,3F16.12)
  590 FORMAT (/,1X,26HFORCES DO NOT VANISH, SUM=,F15.7,/)
  600 FORMAT (4(I2,2X,F12.8,2X))
  601 FORMAT (A4,22X,A2)
  610 FORMAT (1X,9HB MATRIX ,//)
  615 FORMAT ('I=',I2)
  620 FORMAT (5F16.12)
  630 FORMAT(/,5X,16H DETERMINANT  = , E16.5)
  640 FORMAT (/,1X,32HINTERNAL COORDINATES AND FORCES ,/)
  650 FORMAT (2X,I2,4X,2F16.12)
  652 FORMAT (' INVERSE HESSIAN MATRIX ILL DEFINED')
  655 FORMAT(2F16.12)
  660 FORMAT (8F10.7)
  670 FORMAT (1X,16HFORCE CONSTANTS ,/)
  672 FORMAT (1X,'FLETCHER POWELL FORCE CONSTANTS',/)
  680 FORMAT (/1X,24HOLD GEOMETRY AND FORCES ,/)
  690 FORMAT(/1X,44HGEOMETRY CHANGE AND NEW INTERNAL COORDINATES,/)
  692 FORMAT(/1X,'FLETCHER POWELL DIRECTION VECTOR AND NEW INTERNAL COOR
     1DINATES FOR ETA=1',/)
  700 FORMAT (/,1X,31HIMPROVED FORCE CONSTANT MATRIX ,/)
  710 FORMAT (1X,8F10.7)
  720 FORMAT (8F10.7)
  772 FORMAT(/' CARTESIAN COORDINATES IN A.U.'/)
  730 FORMAT(/1X,30HORIGINAL INTERNAL COORDINATES ,/)
  740 FORMAT (2X,5F16.12)
  750 FORMAT(120('-'),/,' INTERNAL DISPLACEMENT',/,4(I2,2X,F12.8,4X),/)
  760 FORMAT (1X,5HSTEP=,I4)
  770 FORMAT (/,1X,'  CARTESIAN DISPLACEMENTS AND NEW CARTESIAN COORDINA
     1TES IN ANGSTROMS',/)
  780 FORMAT (1X,7HDISPL. ,4(F3.0,1H,,F6.4),3X,3(A4,A6))
  790 FORMAT(1X,I3,4H   N,I4,3F16.12,F12.6)
  792 FORMAT(1X,I3,4H   N,I4,3F16.12)
  800 FORMAT(1X,'N=',A4,4X,I2,3F16.12)
  801 FORMAT(/,1X,47H*****CAUTION,WITHIN 9 STEPS NO CONVERGENCE*****/)
  802 FORMAT(///)
  803 FORMAT(//)
  818 FORMAT(//,1X,'FLETCHER-POWELL OPTIMIZATION  PART 1',/,120('-'))
  820 FORMAT(80('-'),/,1X,'ETA= ',F14.10,/)
  815 FORMAT(//,1X,'FLETCHER-POWELL OPTIMIZATION  PART 2',/,120('-'))
  830 FORMAT(80('-'),/,1X,'PREDICTED ENERGY = ',F16.10)
  832 FORMAT(1X,'ETA= ',F14.10,/)
  850 FORMAT(3F20.10)
  853 FORMAT(1X,A4,8X,3(F6.3,F16.10))
C
      END
C     ////////////////////////////////////////////////////
      SUBROUTINE NOM (U)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3)
      Y=SCALAR(U,U)
      X = 1.0D0/DSQRT(Y)
      DO 10 I=1,3
         U(I) = U(I)*X
   10 CONTINUE
      RETURN
      END
C     /////////////////////////////////////////////////
      FUNCTION S2(X)
      IMPLICIT REAL*8 (A-H,O-Z)
      Y = 1.0D0-X*X
      S2 = DSQRT(Y)
      RETURN
      END
C     ///////////////////////////////////////
      FUNCTION SCALAR(U,V)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3) , V(3)
      SCALAR = 0.0D0
      DO 10 I=1,3
          SCALAR = SCALAR + U(I)*V(I)
   10 CONTINUE
      RETURN
      END
C     ////////////////////////////////////////////////
      SUBROUTINE NORMAL (U,V,W)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3),V(3),W(3)
C..... W WIRD EIN SENKRECHT AUF DIE EBENE (U,V) STEHENDER EINHEITSVECTOR
      W(1)=U(2)*V(3)-U(3)*V(2)
      W(2)=U(3)*V(1)-U(1)*V(3)
      W(3) = U(1)*V(2)-U(2)*V(1)
      CALL NOM  (W)
      RETURN
      END
C     /////////////////////////////////////////////////
      FUNCTION ARCOS(X)
      IMPLICIT REAL*8 (A-H,O-Z)
      DOUBLE PRECISION ZERO,ONE,PI,PIH,X,Y,X1,ARCOS,S
      PARAMETER(ZERO=0.0D0,ONE=1.0D0,PI=3.14159265358979D0)
      PARAMETER(PIH=1.57079632679490D0,XTOL=1.0D-12)
      Y=DABS(ONE-X)
      IF (X.GE.ONE.OR.Y.LE.XTOL) GO TO 10
      Y=DABS(ONE+X)
      IF(X.LE.-ONE.OR.Y.LE.XTOL) GO TO 20
      Y=ONE-X*X
      X1= DSQRT(Y)
      IF(DABS(X).LT.1.0D-11) GO TO 30
      S=DATAN(X1/X)
      IF (X.LT.ZERO) S=S+PI
      ARCOS=S
      RETURN
   10 ARCOS=ZERO
      RETURN
   20 ARCOS=PI
      RETURN
   30 ARCOS=PIH
      RETURN
      END
C     ///////////////////////////////////////////////////////
      SUBROUTINE VEKTOR (U,R,I,J,XA,YA,ZA)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3), XA(1), YA(1), ZA(1)
C
C        BILDET DEN NORMIERTEN ENTFERNUNGSVECTOR VON KERN J NACH KERN I
C        UND DIE ENTFERNUNG R
C
      U(1)=XA(I)-XA(J)
      U(2)=YA(I)-YA(J)
      U(3)=ZA(I)-ZA(J)
      Y = SCALAR(U,U)
      R = DSQRT(Y)
      CALL NOM (U)
      RETURN
      END
C     //////////////////////////////////////////////////////////////
      SUBROUTINE OSINV1 (A,N,D,TOL,L,M)
C
C     PARAMETERS   A - INPUT MATRIX , DESTROYED IN COMPUTATION AND
C                      REPLACED BY RESULTANT INVERSE
C                  N - ORDER OF MATRIX A
C                  D - RESULTANT DETERMINANT
C            L AND M - WORK VECTORS OF LENGHT N
C                TOL - IF PIVOT ELEMENT IS LESS THAN THIS PARAMETER THE
C                      MATRIX IS TAKEN FOR SINGULAR (USUALLY 1.0E-8)
C     A DETERMINANT OF ZERO INDICATES THAT THE MATRIX IS SINGULAR
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(1), M(1), L(1)
      PARAMETER(ONE=1.0D0,ZERO=0.0D0)
      D=ONE
      NK=-N
      DO 180 K=1,N
      NK=NK+N
      L(K)=K
      M(K)=K
      KK=NK+K
      BIGA=A(KK)
      DO 20 J=K,N
      IZ=N*(J-1)
      DO 20 I=K,N
      IJ=IZ+I
      IF (DABS(BIGA)-DABS(A(IJ))) 10,20,20
   10 BIGA=A(IJ)
      L(K)=I
      M(K)=J
   20 CONTINUE
      J=L(K)
      IF(J-K) 50,50,30
   30 KI=K-N
      DO 40 I=1,N
      KI=KI+N
      HOLO=-A(KI)
      JI=KI-K+J
      A(KI)=A(JI)
   40 A(JI)=HOLO
   50 I=M(K)
      IF(I-K) 80,80,60
   60 JP=N*(I-1)
      DO 70 J=1,N
      JK=NK+J
      JI=JP+J
      HOLO=-A(JK)
      A(JK)=A(JI)
   70 A(JI)=HOLO
   80 IF(DABS(BIGA)-TOL) 90,100,100
   90 D=ZERO
      RETURN
  100 DO 120 I=1,N
      IF(I-K) 110,120,110
  110 IK=NK+I
      A(IK)=A(IK)/(-BIGA)
  120 CONTINUE
      DO 150 I=1,N
      IK=NK+I
      IJ=I-N
      DO 150 J=1,N
      IJ=IJ+N
      IF(I-K) 130,150,130
  130 IF(J-K) 140,150,140
  140 KJ=IJ-I+K
      A(IJ)=A(IK)*A(KJ)+A(IJ)
  150 CONTINUE
      KJ=K-N
      DO 170 J=1,N
      KJ=KJ+N
      IF(J-K) 160,170,160
  160 A(KJ)=A(KJ)/BIGA
  170 CONTINUE
      D=D*BIGA
      A(KK)=ONE/BIGA
  180 CONTINUE
      K=N
  190 K=K-1
      IF(K) 260,260,200
  200 I=L(K)
      IF(I-K) 230,230,210
  210 JQ=N*(K-1)
      JR=N*(I-1)
      DO 220 J=1,N
      JK=JQ+J
      HOLO=A(JK)
      JI=JR+J
      A(JK)=-A(JI)
  220 A(JI)=HOLO
  230 J=M(K)
      IF (J-K) 190,190,240
  240 KI=K-N
      DO 250 I=1,N
      KI=KI+N
      HOLO=A(KI)
      JI=KI+J-K
      A(KI)=-A(JI)
  250 A(JI)=HOLO
      GO TO 190
  260 RETURN
      END
C     ///////////////////////////////////////////////////////////////
      SUBROUTINE MACHB (NEK,BMAT,NCMAX,NQMAX,XA,YA,ZA,QQ,N,INP,IOUT,NQ,W
     1RI,QONLY,NCARD)
C     ********************************
C     TAKEN FROM PULAY'S PROGRAM TEXAS
C     ********************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DOUBLE PRECISION ARCOS
      LOGICAL WRI,QONLY
C
C     NQ IST DIE ZAHL DER INNEREN KOORDINATEN
C     NEK IST 3* DIE ZAHL DER KERNE FUER DIE KRAFTE BERECHNET WERDEN
C     BMAT IS THE TRANSPOSE B MATRIX
C     DATENANGABE FUER JEDE KOORDINATE EINE KARTE TYP AND DIE ATOME
C     TYP KANN SEIN STRETCH,BEND,OUT,TORSION,LINEAR1,LINRAR2 LINKS GE-
C     BUENDELT ZU SCHREIBEN. BEI STRETCH 2, BEI BEND 3, BEI DEN ANDEREN
C     4 ATOME IN FORMAT F10.3, DIE NUMMERN DER ATOME
C
      DIMENSION QQ(1)
      DIMENSION TIPUS(6)
      DIMENSION WORT(3)
      DIMENSION A(4), IA(4), U(3), V(3), W(3), Z(3), X(3), UU(3), VV(3),
     1 WW(3), ZZ(3), UV(12)
      DIMENSION BMAT(NCMAX,NQMAX), XA(1), YA(1), ZA(1)
      EQUIVALENCE (KA,IA(1)), (KB,IA(2)), (KC,   IA(3)), (KD,IA(4))
      EQUIVALENCE (UV(1),UU(1)), (UV(4),VV(1)), (UV(7),WW(1)), (UV(10),Z
     1Z(1))
      PARAMETER(ONE=1.0D0,ZERO=0.0D0,PI=3.14159265358979D0)
      PARAMETER(PIH=1.57079632679490D0,TPI=6.28318530717959D0)
      DATA TIPUS/4HSTRE,4HBEND,4HOUT ,4HTORS,4HLIN1,4HLIN2/
      DATA WORT/4HK   ,4H    ,4HF   /
      ANULL=ONE
      NCARD=0
      O=ONE
      NAB=NEK
      NAB=NAB/3.0+0.1
      I=0
      C1=ZERO
      MATF=0
      IF (WRI) WRITE(IOUT,330)
   10 READ(INP,340) WE
      BACKSPACE INP
      DO 20 K=1,3
      IF  (WE.EQ.WORT(K))  GO TO 50
   20 CONTINUE
   30 CONTINUE
      C1=DSQRT(ONE/C1)/ANULL
      QQ(I)=QQ(I)*C1
      IF(QONLY) GO TO 310
      DO 40 K=1,NEK
      BMAT(K,I)=BMAT(K,I)*C1
   40 CONTINUE
      GO TO 310
   50 CONTINUE
      NCARD=NCARD+1
      READ(INP,350) WE,C,TYP,IA
      IF (C.EQ.0.0) C=ONE
      IF (WE.EQ.WORT(2)) C1=C1+C**2
      IF (WE.NE.WORT(1)) GO TO 100
      IF(I.EQ.0) GO TO 80
      IF(WRI) WRITE(IOUT,360)
      C1=DSQRT(ONE/C1)/ANULL
      IF (QONLY) GO TO 70
      DO 60 K=1,NEK
      BMAT(K,I)=BMAT(K,I)*C1
   60 CONTINUE
   70 QQ(I)=QQ(I)*C1
   80 I=I+1
      QQ(I)=ZERO
      C1=C**2
      IF (QONLY) GO TO 100
      DO 90 J=1,NEK
         BMAT(J,I)=ZERO
   90 CONTINUE
  100 IF (WE.NE.WORT(3)) GO TO 110
      MATF=1
      GO TO 30
  110 CONTINUE
C 110 DO 120 K=1,4
C        IA(K)=A(K)+0.1
  120 CONTINUE
      DO 130 K=1,6
         IF (TYP.EQ.TIPUS(K)) GO TO 140
  130 CONTINUE
      ERROR=7
      WRITE (IOUT,370) I
      GO TO 320
  140 IF (WRI) WRITE(IOUT,380) I,TYP,IA,C
      IF (KA.LT.1.OR.KA.GT.NAB.OR.KB.LT.1.OR.KB.GT.NAB) GO TO 300
      IF (K.GT.1.AND.(KC.LT.1.OR.KC.GT.NAB)) GO TO 300
      IF (K.GT.2.AND.(KD.LT.1.OR.KD.GT.NAB)) GO TO 300
      GO TO (150,160,180,210,230,250), K
C
C     ..... STRETCH
C
  150 CALL VEKTOR (UU,R1,KA,KB,XA,YA,ZA)
      UU(1)=UU(1)*ANULL
      UU(2)=UU(2)*ANULL
      UU(3)=UU(3)*ANULL
      VV(1)=-UU(1)
      VV(2)=-UU(2)
      VV(3)=-UU(3)
      IA(3)=0
      IA(4)=0
      QQ(I) = QQ(I) + R1*C
      GO TO 270
C
C     .....BENDING
C
  160 CALL VEKTOR (U,R1,KA,KC,XA,YA,ZA)
      CALL VEKTOR (V,R2,KB,KC,XA,YA,ZA)
      CO=SCALAR(U,V)
      SI=S2(CO)
      DO 170 L=1,3
         UU(L)=(CO*U(L)-V(L))/(SI*R1)
      VV(L)=(CO*V(L)-U(L))/(SI*R2)
      WW(L)=-UU(L)-VV(L)
  170 CONTINUE
      IA(4)=0
      QQ(I)=QQ(I)+C*ARCOS(CO)
      GO TO 270
C
C     .....OUT OF PLANE
C
  180 CALL VEKTOR (U,R1,KA,KD,XA,YA,ZA)
      CALL VEKTOR (V,R2,KB,KD,XA,YA,ZA)
      CALL VEKTOR (W,R3,KC,KD,XA,YA,ZA)
      CALL NORMAL (V,W,Z)
      STETA=SCALAR(U,Z)
      CTETA=S2(STETA)
      CFI1=SCALAR(V,W)
      SFI1=S2(CFI1)
      CFI2=SCALAR(W,U)
      CFI3=SCALAR(V,U)
      DEN=CTETA*SFI1**2
      ST2=(CFI1*CFI2-CFI3)/(R2*DEN)
      ST3=(CFI1*CFI3-CFI2)/(R3*DEN)
      DO 190 L=1,3
         VV(L)=Z(L)*ST2
      WW(L)=Z(L)*ST3
  190 CONTINUE
      CALL NORMAL(Z,U,X)
      CALL NORMAL(U,X,Z)
      DO 200 L=1,3
         UU(L)=Z(L)/R1
         ZZ(L)=-UU(L)-VV(L)-WW(L)
  200 CONTINUE
      CX=-C
      IF (STETA.LT.ZERO) CX=C
      QQ(I)=QQ(I)-CX*ARCOS(CTETA)
      GO TO 270
C
C     ..... TORSION
C
  210 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KC,KB,XA,YA,ZA)
      CALL VEKTOR (W,R3,KC,KD,XA,YA,ZA)
      CALL NORMAL (U,V,Z)
      CALL NORMAL (W,V,X)
      CO=SCALAR(U,V)
      CO2=SCALAR(V,W)
      SI=S2(CO)
      SI2=S2(CO2)
      DO 220 L=1,3
         UU(L)=Z(L)/(R1*SI)
         ZZ(L)=X(L)/(R3*SI2)
         VV(L)=(R1*CO/R2-ONE)*UU(L)-R3*CO2/R2*ZZ(L)
         WW(L)=-UU(L)-VV(L)-ZZ(L)
  220 CONTINUE
      CO=SCALAR(Z,X)
      U(1)=Z(2)*X(3)-Z(3)*X(2)
      U(2)=Z(3)*X(1)-Z(1)*X(3)
      U(3)=Z(1)*X(2)-Z(2)*X(1)
      CO2=SCALAR(U,V)
      S=ARCOS(-CO)
      IF(CO2.LT.ZERO) S=-S
      IF (S.GT.PIH) S=S-TPI
      QQ(I)=QQ(I)-C*S
C
C     .... REMEMBER THAT THE RANGE OF THIS COORDINATE IS -PI/2 TO 3*PI/2
C     .... IN ORDER TO SHIFT THE DISCONTINUITY OFF THE PLANAR POSITION
C
      GO TO 270
C
C     .....LINEAR COMPLANAR BENDING
C
  230 CALL VEKTOR (U,R1,KA,KC,XA,YA,ZA)
      CALL VEKTOR (V,R2,KD,KC,XA,YA,ZA)
      CALL VEKTOR (X,R2,KB,KC,XA,YA,ZA)
      CO=SCALAR(V,U)
      CO2=SCALAR(X,V)
      QQ(I)=QQ(I)+C*(PI-ARCOS(CO)-ARCOS(CO2))
      CALL NORMAL (V,U,W)
      CALL NORMAL (U,W,Z)
      CALL NORMAL(X,V,W)
      CALL NORMAL (W,X,U)
C
C     ..... COORDINATE POSITIVE IF ATOM A MOVES TOWARDS ATOM D
C
      DO 240 L=1,3
         UU(L)=Z(L)/R1
      VV(L)=U(L)/R2
      WW(L)=-UU(L)-VV(L)
  240 CONTINUE
      IA(4)=0
      GO TO 270
C
C     ..... LINEAR PERPENDICULAR BENDING
C
  250 CALL VEKTOR (U,R1,KA,KC,XA,YA,ZA)
      CALL VEKTOR (V,R2,KD,KC,XA,YA,ZA)
      CALL VEKTOR (Z,R2,KB,KC,XA,YA,ZA)
      CALL NORMAL (V,U,W)
      CALL NORMAL (Z,V,X)
      DO 260 L=1,3
         UU(L)=W(L)/R1
      VV(L)=X(L)/R2
         WW(L)=-UU(L)-VV(L)
  260 CONTINUE
      IA(4)=0
      CO=SCALAR(U,W)
      CO2=SCALAR(Z,W)
      QQ(I)=QQ(I)+C*(PI-ARCOS(CO)-ARCOS(CO2))
  270 IF (QONLY) GO TO 10
      DO 290 J=1,4
         M=IA(J)
      IF (M.LE.0) GO TO 290
         M=M-1
      J1=3*(J-1)
         DO 280 L=1,3
            M1=3*M+L
            L1=J1+L
            BMAT(M1,I)=UV(L1)*C+BMAT(M1,I)
  280    CONTINUE
  290 CONTINUE
      GO TO 10
  300 ERROR=6
      WRITE (IOUT,390) I
  310 NQ=I
  320 RETURN
C
  330 FORMAT(//,1X,34HDEFINITION OF INTERNAL COORDINATES,//)
  340 FORMAT(A4)
  350 FORMAT(A4,6X,F16.12,A4,6X,5I3)
  360 FORMAT(1X)
  370 FORMAT(/,1X,38HUNDEFINED INT.COORDINATE TYPE AT NO.  ,I3,/,10(4H**
     1**))
  380 FORMAT(1X,I3,'.',A8,4I3,F16.12)
  390 FORMAT(/,1X,41HATOMS ERRONOUSLY DEFINED,COORDINATE NO.  ,I3,/,1X,
     110(4H****))
      END
C BMATIN6     FINAL MODIFIED VERSION OF PULAY'S BMATIN PROGRAM
C***********************************************************************
C   NOTICE OF PROGRAM MODIFICATION                                     *
C***********************************************************************
C      BY:  TPH                                                        *
C    DATE:  JUNE 13,1988                                               *
C  REASON:  PUT IN INVERSE BOND LENGTH AS A COORDINATE  -  INVR        *
C      BY:  TPH                                                        *
C    DATE:  JUNE 3,1988                                                *
C  REASON:  CHANGE SO THAT DUMMY ATOMS CAN BE USED FOR LINEAR BEND     *
C           DISPLACEMENTS.  THE PROGRAM ZOOMS THE DUMMY ATOMS TO A     *
C           DISTANCE OF 1 BILLION SO THAT LIN1 AND LIN2 ARE EQUIVALENT *
C           FOR LINEAR MOLECULES.                                      *
C           ALSO SCALE DISPLACEMENT ONCE IN GEOMETRY OPTIMIZATIONS     *
C      BY:  TPH                                                        *
C    DATE:  APRIL 25, 1988                                             *
C  REASON:  CHANGE SOME OF THE DEFAULTS. NO LONGER HAVE OLDF, OLDH,    *
C           AND EXFI.  THE PROGRAM WILL READ THEM AND NOT CRASH.       *
C           NOUP AND NOEX MUST BE SPECIFIED TO SUPRESS HESSIAN UPDATE  *
C           AND READING IN FROM INP2, WHICH ARE NOW DEFAULT.           *
C           MURT MUST BE USED TO NOT HAVE POWELL OR BFGS UPDATES       *
C      BY:  TPH                                                        *
C    DATE:  APRIL 23, 1988                                             *
C  REASON:  CHANGE MACHB TO USE INTERNAL COORDINATES SPECIFICATION     *
C           THE SAME AS IN INTDER. (BEND,OUT,LIN1,LIN2)                *
C      BY:  TPH                                                        *
C    DATE:  FEBRUARY 26, 1988                                          *
C  REASON:  PUT PARTS BRIAN YATES CHANGED IN HIS VERSION,              *
C           KEEPING JON BAKER'S OPTEFC NEARLY THE SAME AS IN           *
C           GAUSSIAN82, AND USING AN INTERFACE CALLED EFC.             *
C      BY:  TPH                                                        *
C    DATE:  FEBRUARY 8, 1988                                           *
C  REASON:  PUT COMMENTS IN PROGRAM FIFTH, RENUMBER                    *
C           INDICATING WHERE CHANGES IN THE NEAR FUTURE WILL BE MADE   *
C      BY:  TPH                                                        *
C    DATE:  OCTOBER 26, 1987                                           *
C  REASON:  PUT IN EIGENVECTOR FOLLOWING ROUTINE OF JON BAKER,         *
C           POWELL UPDATE OF THE HESSIAN, AND DIIS FOR GEOMETRY OPT.   *
C           BESSLER PREVIOUSLY PUT IN BFGS AND DAVIDON-FLETCHER-POWELL *
C           UPDATES.  FILE INP4 HAS INTERNAL FORCES PREVIOUS STEPS.    *
C           FILE INP3 HAS THE EIGENVECTOR FROM PREVIOUS STEP IN OPTEFC.*
C***********************************************************************
C***********************************************************************
C   FUTURE NEEDS FOR BMAT: TAKE CARE OF DISCONTINUITY IN ANGULAR       *
C           COORDINATES (FOR NOW CHANGING ANGLE DEFINITIONS MAY HELP), *
C           FIX GDIIS,   PRINT RMS GRADIENT,                           *
C           AUTOMATIC ROTATION SO THAT ONE COORDINATE IS AT ORIGIN     *
C           OR SYMMETRY PLANE PRESERVED ETC.,                          *
C           CALCULATION OF # OF TOTALLY SYMMETRIC MODES FOR WARNINGS   *
C***********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER AI*80,WKEY1*4,WKEY2*4
      INTEGER INP,IOUT,INP2,IPUN,IGMUP
      COMMON /IOP/ IOP(50)
      COMMON /GANZ/ NA,LOPT(26)
      PARAMETER(INP=30,IOUT=31,INP2=32,IPUN=33,IGMUP=5)
      PARAMETER(WKEY1='BMAT',WKEY2='STOP')
C....................................................................
C     THIS IS WRITTEN SO THAT SEVERAL BMAT SECTIONS IN THE BMAT     .
C     INPUT FILE CAN BE RUN, SHOULD THE NEED ARISE                  .
C....................................................................
cets  CALL NOUNFL
      call drum
      open (unit=inp,file='bmat.dat',status='old')
      open (unit=ipun,file='resul3',status='unknown')
      call wind(ipun)
      open (unit=inp2,file='resul2',status='unknown')
      open (unit=iout,file='resul1',status='unknown')
c
   10 READ (INP,50) AI
      IF (AI(1:4).NE.WKEY1) GO TO 40
      WRITE(IOUT,60)
      WRITE(IOUT,70) AI
      DO 20 I=1,50
         IOP(I)=0
   20 CONTINUE
      DO 30 I=1,26
         LOPT(I)=0
   30 CONTINUE
      CALL FIFTH (INP,IOUT,INP2,IPUN,IGMUP)
      GO TO 10
   40 CONTINUE
   50 FORMAT (A80)
   60 FORMAT (9(8H********))
   70 FORMAT (//,1X,A80)
      END
C     //////////////////////////////////////////////////////////
      SUBROUTINE FIFTH(INP,IOUT,INP2,IPUN,IGMUP)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER INP,IOUT,INP2,IPUN,IGMUP
      INTEGER P,Q,NR
      CHARACTER WO*4,WK(26)*4,W1*2
      INTEGER INDI(4,50),INDT(4)
      LOGICAL WRIT,IFSTRE(50),SFIRST,FIRSTD
      REAL*8 NV,N2V,N3V
      DIMENSION CCIN(4,50),CIN(4),CCC(75),ETA(4),ENERGY(4)
      DIMENSION CI(9),AE(3),DUMX(10),DUMY(10),DUMZ(10)
      DIMENSION SYMB(25)
      DIMENSION LFLAG(4)
      DIMENSION QQQ(69),FII(69)
      DIMENSION WW(2)
      DIMENSION L(69),M(69), KI(75), IA(25)
      DIMENSION IFIX(20),IBOHR(40)
      COMMON/MODOUT/VMODE(50)
      COMMON /ENER/ TITLE(16)
      COMMON /GANZ/ NA,LOPT(26)
      COMMON /IO/ IIN,IIOUT,IINP2,IIPUN,IIGMUP
      COMMON /IOP/ IOP(50)
      COMMON/DISCON/SSS(100),SFIRST
      COMMON /BMAT/ BL(1),C(4761),F(75),FI(69),CC(75)
     &,XA(25),YA(25),ZA(25)
     &,XM(75),XY(75),QQ1(75),QQ(69),B(75,69)
     &,NV(75),HE(69,69),HN(69,69)
     &,N2V(69),DV(69),N3V(69),GRC(69),GEC(69),A(4761),QD(69,69)
     &,FD(69,69)
      EQUIVALENCE (B(1,1),WW(1))
      PARAMETER(ZERO=0.0D0,HALF=0.5D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER(THREE=3.0D0,FOUR=4.0D0,FIVE=5.0D0,TEN=10.0D0)
      PARAMETER(ANG=1.889726664D0,GDYN=8.2388575D0)
      PARAMETER(FSUMT=1.0D-7,CRTTOL=1.0D-12,MXITER=40)
      PARAMETER(RADC=57.29577951308D0)
      DATA (WK(I),I=1,6)/'CARD','FMAT','DISP','OLDF','PUNC','PRIN'/
      DATA (WK(I),I=7,12)/'ANGS','FIXC','FINT','FLT1','EXFI','BOHR'/
      DATA (WK(I),I=13,18)/'FLT2','GDYN','OLDH','DEGR','DFLP','BFGS'/
      DATA (WK(I),I=19,23)/'POWL','EIGF','DIIS','MODE','DUMB'/
      DATA (WK(I),I=24,26)/'NOUP','NOEX','MURT'/
      DATA XNIST/2HN=/
      REWIND INP2
      SFIRST=.TRUE.
      FIRSTD=.TRUE.
      IIN=INP
      IIOUT=IOUT
      IINP2=INP2
      IIPUN=IPUN
      IIGMUP=IGMUP
      IOP(5)=1
      IX=INP
      NDUM=0
      NMAX=25
      NCMAX=3*NMAX
      NQMAX=NCMAX-6
      LFLAG(1)=0
      NFIX=0
C
C     DIMENSION OF THE B MATRIX MUST CONFORM TO B(NCMAX,NQMAX)
C.................................................................
C     READ IN INPUT OPTIONS                                      .
C.................................................................
   10 READ(INP,2000) WO,NR
      DO 20 I=1,26
         IF (WK(I).EQ.WO) GO TO 30
   20 CONTINUE
      BACKSPACE INP
      GO TO 40
   30 LOPT(I)=1
      IF(I.EQ.1) NA=NR
      IF (I.EQ.3) LOPT(3)=NR
      IF (I.EQ.3.AND.LOPT(3).EQ.0) LOPT(3)=1
      IF(I.EQ.8) THEN
           NFIX=NFIX+1
           IFIX(NFIX)=NR
      END IF
      IF(I.EQ.10) THEN
           BACKSPACE INP
           READ(INP,2020) WO,ETA(1),ETA(2),ETA(3),ETA(4)
           WRITE(IOUT,2025) WO,ETA(1),ETA(2),ETA(3),ETA(4)
           GO TO 10
      END IF
      IF(I.EQ.13) THEN
           BACKSPACE INP
           READ(INP,2030) WO,(ETA(K),ENERGY(K),K=1,3)
           WRITE(IOUT,2035) WO,(ETA(K),ENERGY(K),K=1,3)
           LOPT(10)=1
           GO TO 10
      END IF
      IF(I.EQ.20) THEN
           BACKSPACE INP
           READ(INP,2040) WO,IOP(5),IOP(7),IOP(8),IOP(13),IOP(16),
     &                    IOP(17),IOP(19),IOP(33),IOP(34)
           WRITE(IOUT,2045) WO,IOP(5),IOP(7),IOP(8),IOP(13),IOP(16),
     &                    IOP(17),IOP(19),IOP(33),IOP(34)
           GO TO 10
      END IF
      IF(I.EQ.22) THEN
           BACKSPACE INP
           READ(INP,2050) WO,MODE1,MODE2
           WRITE(IOUT,2055) WO,MODE1,MODE2
           GO TO 10
      END IF
      IF(I.EQ.23) THEN
           BACKSPACE INP
           NDUM=NDUM+1
           READ(INP,2060) WO,DUMX(NDUM),DUMY(NDUM),DUMZ(NDUM)
           WRITE(IOUT,2065) WO,DUMX(NDUM),DUMY(NDUM),DUMZ(NDUM)
           GO TO 10
      END IF
      WRITE(IOUT,2010) WO,NR
      GO TO 10
C..................................................................
C     CHECK THE NUMBER OF ITERATIONS                              .
C..................................................................
   40 CONTINUE
      READ(INP2,2070) NGEO,NUMIT
C..................................................................
C     SET THE DEFAULTS HERE                                       .
C..................................................................
      IF(LOPT(3).GT.0.OR.LOPT(10).GT.0.OR.LOPT(13).GT.0) FIRSTD=.FALSE.
      IF(LOPT(10).GT.0) THEN
         LOPT(15)=1
         IF(LOPT(24).NE.0) LOPT(15)=0
      ELSE
         LOPT(4)=1
         IF(LOPT(24).NE.0) LOPT(4)=0
      ENDIF
      IF(LOPT(25).GT.0) THEN
         LOPT(11)=0
      ELSE
         LOPT(11)=1
      ENDIF
      IF(LOPT(17).EQ.0.AND.LOPT(18).EQ.0.AND.LOPT(19).EQ.0.AND.
     &   LOPT(26).EQ.0) THEN
         IF(IOP(5).EQ.1) LOPT(18)=1
         IF(IOP(5).EQ.0) LOPT(19)=1
      ENDIF
C     WRITE(IOUT,1234) (LOPT(I),I=1,26)
C1234 FORMAT(26I3)
C..................................................................
C     TURN OFF HESSIAN UPDATING IN OPTEFC UNLESS BFGS WITH        .
C     POSITIVE DEFINITENESS IS GUARANTEED.                        .
C..................................................................
      IF(LOPT(18).EQ.1 .AND. IOP(13).EQ.2) THEN
         LOPT(24) = 1
      ELSE
         IOP(13) = -1
      ENDIF
      IF(LOPT(11).EQ.0.OR.NUMIT.LT.1) GO TO 60
C..................................................................
C     CHECK THE NUMBER OF ATOMS IN INP2 IS EQUAL NA (EXFI OPTION) .
C..................................................................
      DO 50 I=1,NA
      READ(INP2,2080) W1
      IF(W1.NE.'N=') THEN
         WRITE(IOUT,2090) W1
         RETURN
      END IF
   50 CONTINUE
   60 CONTINUE
C..................................................................
C     CHECK THAT NA IS NOT LARGER THAN NMAX                       .
C..................................................................
      IF (NA.GT.0.AND.NA.LE.NMAX) GO TO 70
      WRITE (IOUT,2100)  NA
      RETURN
   70 CONTINUE
CTPH  N=NA
      IF (LOPT(1).NE.1) THEN
         WRITE(IOUT,2105)
         STOP
      ENDIF
C..................................................................
C     READ GEOMETRY IN FROM BMAT FILE                             .
C..................................................................
      WRITE( IOUT,2110)
      DO 90 I=1,NA
         I3=3*I
         READ(INP,2120) SYMB(I),IA(I),XA(I),YA(I),ZA(I),XM(I3)
C..................................................................
C     DEFAULT MASS IS ONE                                         .
C..................................................................
      IF  (XM(I3).EQ.ZERO) XM(I3)=ONE
      IF (LOPT(7).EQ.1) GO TO 80
C..................................................................
C     CONVERT BOHR TO ANGSTROMS                                   .
C..................................................................
      XA(I)=XA(I)/ANG
      YA(I)=YA(I)/ANG
      ZA(I)=ZA(I)/ANG
   80 CONTINUE
C..................................................................
C     CONVERT ANGSTROMS TO BOHR FOR PRINTING                      .
C..................................................................
      XXWA=XA(I)*ANG
      YYWA=YA(I)*ANG
      ZZWA=ZA(I)*ANG
      WRITE(IOUT,2130) I,IA(I),XXWA,YYWA,ZZWA,XM(I3)
C..................................................................
C     PUT INVERSE MASS IN XM                                      .
C..................................................................
      XM(I3)=ONE/XM(I3)
      XM(I3-1)=XM(I3)
      XM(I3-2)=XM(I3)
   90 CONTINUE
C..................................................................
      NEK=3*NA
      IF (LOPT(3).GT.0) GO TO 130
      IF (LOPT(9).GT.0) GO TO 190
C..................................................................
C     READ FORCES IN FROM BMAT FILE                               .
C..................................................................
      READ (INP,2140) (F(I),I=1,NEK)
      IF(LOPT(14).EQ.1) GO TO 110
C..................................................................
C     CONVERT GRADIENTS IN ATOMIC UNITS TO FORCES IN MDYN         .
C..................................................................
      DO 100 I=1,NEK
         F(I)=-F(I)*GDYN
  100 CONTINUE
  110 CONTINUE
      WRITE(IOUT,2150)
      WRITE(IOUT,2160) (F(I),I=1,NEK)
C..................................................................
C     CHECK THAT FORCES ADD TO ZERO                               .
C..................................................................
      XFQX=F(1)
      DO 120 I=2,NEK
  120 XFQX=XFQX+F(I)
      IF(DABS(XFQX).GT.FSUMT) WRITE (IOUT,2170) XFQX
      IF(LOPT(3).LE.0) GO TO 190
C..................................................................
C     READ IN DISPLACEMENTS                                       .
C..................................................................
  130 CONTINUE
      NDI=LOPT(3)
      DO 140 I=1,NDI
  140    READ (INP,2180) (INDI(J,I),CCIN(J,I),J=1,4)
      IF(LOPT(12).NE.1) GO TO 190
C..................................................................
C     CHANGE DISPLACEMENTS TO BOHR INSTEAD OF ANGSTROMS           .
C..................................................................
      NBOHR=0
      IQ=0
      KB=0
  150 KB=KB+1
      READ(INP,2190) WO,W1
      IF(WO(1:1).NE.'K'.AND.WO.NE.'    ') GO TO 160
      IF(WO(1:1).EQ.'K')THEN
           IQ=IQ+1
           IF(W1.EQ.'ST')THEN
           NBOHR=NBOHR+1
           IBOHR(NBOHR)=IQ
           END IF
      END IF
      GO TO 150
  160 DO 170  I=1,KB
  170 BACKSPACE INP
      DO 180  K=1,NBOHR
      DO 180  I=1,NDI
      DO 180  J=1,4
         IF(INDI(J,I).EQ.IBOHR(K))THEN
         CCIN(J,I)=CCIN(J,I)/ANG
         ELSE IF (LOPT(16).EQ.1) THEN
         CCIN(J,I)=CCIN(J,I)/RADC
         END IF
  180 CONTINUE
C....................................................................
C     PUT DUMMY ATOM COORDINATES IN XA,YA,ZA (NOT COMPLETELY TESTED).
C....................................................................
  190 CONTINUE
      NADT=NA
      IF (LOPT(3) .NE. 0) THEN
         NADT=NADT+NDUM
         BILION = 1000000000.0D0
         IF(NADT.GT.NMAX) STOP 'NA+NDUM GREATER THAN NMAX'
         DO 200 I=1,NDUM
            DUNORM = DSQRT(DUMX(I)**2 + DUMY(I)**2 + DUMZ(I)**2)
            XA(NA+I)=DUMX(I)*BILION/DUNORM
            YA(NA+I)=DUMY(I)*BILION/DUNORM
            ZA(NA+I)=DUMZ(I)*BILION/DUNORM
            NEK = NEK+3
  200    CONTINUE
      ENDIF
      WRIT=.FALSE.
      IF (LOPT(6).EQ.1) WRIT=.TRUE.
C....................................................................
C     CHECK THE TYPE OF INTERNAL COORDINATE FOR OPTEFC CONVERSION   .
C     OF ANGSTROMS TO BOHRS                                         .
C....................................................................
      IQ=0
      KB=0
  205 KB=KB+1
      READ(INP,2190) WO,W1
      IF(WO(1:1).NE.'K' .AND. WO.NE.'    ') GO TO 206
      IF(WO(1:1).EQ.'K') THEN
         IQ=IQ+1
         IFSTRE(IQ) = W1.EQ.'ST'
      ENDIF
      GO TO 205
  206 CONTINUE
      DO 207 I=1,KB
         BACKSPACE INP
  207 CONTINUE
C....................................................................
C     MAKE B MATRIX                                                 .
C....................................................................
      CALL MACHB (NEK,B,NCMAX,NQMAX,XA,YA,ZA,QQ,NADT,IX,IOUT,NQ,WRIT,
     1.FALSE.,NCARD)
      IF(LOPT(5).EQ.0) GO TO 220
C....................................................................
C     PUNCH B MATRIX                                                .
C....................................................................
      WRITE(IPUN,2200)
      WRITE (IPUN,2210)
      DO 210 I=1,NQ
          WRITE (IPUN,2220) I
          WRITE (IPUN,2230) (B(J,I),J=1,NEK)
  210 CONTINUE
  220 CONTINUE
C....................................................................
C     INVERT B*M*B+  (SEE PULAY'S ARTICLE IN VOL 4, P 166)          .
C....................................................................
      I1=0
      DO 240 I=1,NQ
      DO 240 J=1,NQ
      I1=I1+1
      S=ZERO
      DO 230 K=1,NEK
  230 S=S+B(K,I)*B(K,J)*XM(K)
  240 C(I1)=S
      TOL=1.0D-8
      CALL OSINV1 (C,NQ,D,TOL,L,M)
C....................................................................
      WRITE (IOUT,2240) D
      IF (LOPT(3).GT.0) GO TO 1150
C....................................................................
C     FORM B*M*F                                                    .
C....................................................................
      WRITE( IOUT,2250)
      DO 260 I=1,NQ
         T=ZERO
         DO 250 J=1,NEK
  250      T=T+B(J,I)*F(J)*XM(J)
  260 CC(I)=T
C....................................................................
C     FORM (B*M*B+)-1 * B*M*F = INTERNAL FORCES                     .
C....................................................................
      IJ=0
      DO 300 I=1,NQ
         T=ZERO
      IF(LOPT(9).GT.0) GO TO 280
         DO 270 J=1,NQ
            IJ=IJ+1
  270    T=T+C(IJ)*CC(J)
         FI(I)=T
  280 IF(LOPT(9).LE.0) GO TO 290
C....................................................................
C     READ IN INTERNAL FORCES INSTEAD                               .
C....................................................................
      READ(INP,2140) FI(I)
      NCARD=NCARD+1
  290 CONTINUE
C....................................................................
C     WRITE OUT COORDINATE NUMBER, INTERNAL COORDINATE AND FORCE    .
C....................................................................
      WRITE (IOUT,2260) I,QQ(I),FI(I)
      QQQ(I)=QQ(I)
      FII(I)=FI(I)
  300 CONTINUE
C....................................................................
C     PUNCH INTERNAL FORCES                                         .
C....................................................................
      WRITE(IPUN,2270) (FI(I),I=1,NQ)
      IF(LOPT(10).GE.1.AND.LOPT(13).LT.1) WRITE(IOUT,2280)
      IF(LOPT(13).GE.1) WRITE(IOUT,2290)
      IF (LOPT(2).LT.1) GO TO 1530
C....................................................................
C     READ INTERNAL FORCE CONSTANT MATRIX FROM BMAT FILE OR INP2    .
C....................................................................
      IF(LOPT(10).GE.1) THEN
           WRITE(IOUT,2300)
      ELSE
           WRITE(IOUT,2310)
      END IF
      IF(LOPT(11).GT.0.AND.NUMIT.GT.0) IX=INP2
      DO 320 I=1,NQ
      READ(IX,2270)(F(J),J=1,I)
         WRITE (IOUT,2320) (F(J),J=1,I)
      IF (LOPT(11).GT.0.AND.NUMIT.GT.0) GO TO 310
C....................................................................
C     NCARD KEEPS TRACK OF HOW MANY CARDS IT TAKES IN BMAT FILE     .
C     TO READ IN THE FORCE CONSTANT MATRIX, FOR LATER USE           .
C....................................................................
      NCARD=NCARD+1+(I-1)/8
  310 CONTINUE
C....................................................................
C     PUT FORCE CONSTANT IN SQUARE MATRIX C, TAKE THE INVERSE       .
C....................................................................
      DO 320 J=1,I
      IJ=(I-1)*NQ+J
      JI=(J-1)*NQ+I
      C(JI)=F(J)
      C(IJ)=C(JI)
  320 CONTINUE
      IX=INP
      CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
      IF(NUMIT.LT.1) GO TO 870
C....................................................................
C     READ IN OLD INTERNAL COORDINATES, FORCES, AND DISPLACEMENTS   .
C     FROM INP2 OR INP                                              .
CTPH  INP2 SHOULD HAVE THIS WHETHER EXFI IS USED OR NOT             .
C....................................................................
      IF(LOPT(11).GT.0) IX=INP2
      DO 340 I=1,NQ
         READ(IX,2340) CC(I),F(I),GEC(I)
         IF(LOPT(11).GT.0.AND.NUMIT.GT.0) GO TO 330
         NCARD=NCARD+1
  330 CONTINUE
  340 CONTINUE
      MODE= 0
      IF(NUMIT.GT.0.AND.LOPT(11).GT.0) READ(INP2,2620) MODE
      IX=INP
      IF (LOPT(4).LT.1.AND.LOPT(15).LT.1) GO TO 870
C....................................................................
C     UPDATE THE HESSIAN UNLESS IT IS THE FIRST OPTIMIZATION CYCLE  .
C     ALL UPDATES ARE THE POWELL UPDATE THE INVERSE HESSIAN         .
C....................................................................
      WRITE(IOUT,2330)
CTPH  IF(LOPT(11).GT.0) IX=INP2
      DO 345 I=1,NQ
         WRITE (IOUT,2260) I,CC(I),F(I)
  345 CONTINUE
CTPH  IX=INP
C..................................................................
      IF(LOPT(15).GE.1) GO TO 820
      IF(LOPT(17) .EQ. 1) GOTO 420
      IF(LOPT(18) .EQ. 1) GOTO 520
      IF(LOPT(19) .EQ. 1) GOTO 620
C....................................................................
C     MURTAGH-SARGENT UPDATE                                        .
C....................................................................
      WRITE(IOUT,2350)
      DO 350 I=1,NQ
      GRC(I)=-FI(I)+F(I)
  350 CONTINUE
C 350 GEC(I)=QQ(I)-CC(I)
      IJ=0
      DO 360 I=1,NQ
      DO 360 J=1,NQ
      IJ=IJ+1
  360 HE(I,J)=C(IJ)
      DO 370 I=1,NQ
      NV(I)=0.D0
      DO 370 J=1,NQ
  370 NV(I)=NV(I)+HE(I,J)*GRC(J)
      DO 380 I=1,NQ
  380 NV(I)=GEC(I)-NV(I)
      DN=0.D0
      DO 390 I=1,NQ
  390 DN=DN+NV(I)*GRC(I)
      DO 400 I=1,NQ
      DO 400 J=1,NQ
  400 HE(I,J)=HE(I,J)+NV(I)*NV(J)/DN
      IJ=0
      DO 410 I=1,NQ
      DO 410 J=1,NQ
      IJ=IJ+1
  410 C(IJ)=HE(J,I)
      GOTO 820
  420 CONTINUE
C....................................................................
C     DAVIDON-FLETCHER-POWELL (DFP) UPDATE                          .
C....................................................................
      WRITE(IOUT,2360)
      DO 430 I=1,NQ
      GRC(I)=-FI(I)+F(I)
  430 CONTINUE
C 430 GEC(I)=QQ(I)-CC(I)
      IJ=0
      DO 440 I=1,NQ
      DO 440 J=1,NQ
      IJ=IJ+1
  440 HE(I,J)=C(IJ)
      DN=0.D0
      DO 450 I=1,NQ
  450 DN=DN+GEC(I)*GRC(I)
      DO 460 I=1,NQ
      DO 460 J=1,NQ
  460 HN(I,J)=GEC(I)*GEC(J)/DN
      DO 470 I=1,NQ
      DV(I)=0.D0
      DO 470 J=1,NQ
  470 DV(I)=DV(I)+HE(I,J)*GRC(J)
      DN=0.D0
      DO 480 I=1,NQ
  480 DN=DN+GRC(I)*DV(I)
      DO 490 I=1,NQ
      N2V(I)=0.D0
      DO 490 J=1,NQ
  490 N2V(I)=N2V(I)+GRC(I)*HE(I,J)
      DO 500 I=1,NQ
      DO 500 J=1,NQ
  500 HE(I,J)=HE(I,J)+HN(I,J)-DV(I)*N2V(J)/DN
      IJ=0
      DO 510 I=1,NQ
      DO 510 J=1,NQ
      IJ=IJ+1
  510 C(IJ)=HE(I,J)
      GOTO 820
  520 CONTINUE
C....................................................................
C     BFGS UPDATE                                                   .
C....................................................................
      WRITE(IOUT,2370)
      DO 530 I=1,NQ
      GRC(I)=-FI(I)+F(I)
  530 CONTINUE
C 530 GEC(I)=QQ(I)-CC(I)
      IJ=0
      DO 540 I=1,NQ
      DO 540 J=1,NQ
      IJ=IJ+1
  540 HE(I,J)=C(IJ)
      DN=0.D0
      DO 550 I=1,NQ
  550 DN=DN+GEC(I)*GRC(I)
      DO 560 I=1,NQ
      NV(I)=0.D0
      DO 560 J=1,NQ
  560 NV(I)=NV(I)+GRC(J)*HE(I,J)
      SU=0.D0
      DO 570 I=1,NQ
  570 SU=SU+NV(I)*GRC(I)
      SU=1.D0+SU/DN
      DO 580 I=1,NQ
      DO 580 J=1,NQ
  580 HN(I,J)=HN(I,J)+SU/DN*GEC(I)*GEC(J)
      DO 590 I=1,NQ
      N2V(I)=0.D0
      DO 590 J=1,NQ
  590 N2V(I)=N2V(I)+GRC(J)*HE(I,J)
      DO 600 I=1,NQ
      DO 600 J=1,NQ
  600 HE(I,J)=HE(I,J)+HN(I,J)-GEC(I)*N2V(J)/DN-NV(I)*GEC(J)/DN
      IJ=0
      DO 610 I=1,NQ
      DO 610 J=1,NQ
      IJ=IJ+1
  610 C(IJ)=HE(I,J)
      GO TO 820
  620 CONTINUE
C......................................................................
C     POWELL UPDATE (SYMMETRIC BROYDEN)                               .
C     INVERT C TO REGAIN THE HESSIAN, UPDATE, THEN RESTORE THE INVERSE.
C......................................................................
      CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
      WRITE(IOUT,2380)
      IJ=0
      DO 630 I=1,NQ
      DO 630 J=1,NQ
      IJ=IJ+1
  630 HE(I,J)=C(IJ)
CTPH  DO 640 I=1,NQ
CTPH    GEC(I)=QQ(I)-CC(I)
C 640 CONTINUE
      DO 660 I=1,NQ
      N2V(I)=0.0D0
         DO 650 J=1,NQ
            N2V(I)=N2V(I)+HE(I,J)*GEC(J)
  650    CONTINUE
      GRC(I)=-FI(I)+F(I)-N2V(I)
  660    CONTINUE
      DN=0.D0
      DO 670 I=1,NQ
  670 DN=DN+GEC(I)*GEC(I)
      SU=0.D0
      DO 680 I=1,NQ
  680 SU=SU+GEC(I)*GRC(I)
      SU=SU/DN
      DABSSU=DABS(SU)
C....................................................................
C     YOU MAY NOT WANT TO DO THE UPDATE IF THE DISPLACEMENT IS SMALL.
C....................................................................
CTPH  IF(DN.LT.0.000001D0) GO TO 700
      DO 690 I=1,NQ
      DO 690 J=1,I
      TEMP=GEC(I)*GRC(J)+GEC(J)*GRC(I)-GEC(I)*SU*GEC(J)
      HE(I,J)=HE(I,J)+TEMP/DN
      HE(J,I)=HE(I,J)
  690 CONTINUE
  700 CONTINUE
      IJ=0
      DO 710 I=1,NQ
      DO 710 J=1,NQ
      IJ=IJ+1
  710 C(IJ)=HE(I,J)
      CALL OSINV1 (C,NQ,D,1.0E-8,L,M)
C....................................................................
C     THE OPTIMALLY CONDITIONED UPDATE SHOULD GO HERE               .
C....................................................................
  820 IF(LOPT(4).GE.1) GO TO 870
C....................................................................
C     UPDATE THE FLETCHER POWELL FORCE CONSTANTS                    .
C....................................................................
      IJ=0
      DO 840  I=1,NQ
      S=ZERO
      DO 830  J=1,NQ
      IJ=IJ+1
  830 S=S-C(IJ)*F(J)
  840 CCC(I)=S
      S=ZERO
      S1=ZERO
      DO 850  I=1,NQ
      S=S-CC(I)*F(I)
  850 S1=S1+CCC(I)*F(I)
      IJ=0
      DO 860  I=1,NQ
      DO 860  J=1,NQ
      IJ=IJ+1
  860 C(IJ)=C(IJ)+CC(I)*CC(J)/S+CCC(I)*CCC(J)/S1
  870 CONTINUE
C....................................................................
C     CALCULATE THE NEW COORDINATES IN ONE OF THREE WAYS:           .
C    (A) EIGENVECTOR FOLLOWING  (B) DIIS  (C) NEWTON-RAPHSON        .
C....................................................................
      IF(LOPT(20).GE.1) THEN
C....................................................................
C    (A)  EIGENVECTOR FOLLOWING, EFC IS AN INTERFACE BETWEEN        .
C         BMATIN6 AND OPTEFC WRITTEN BY BRIAN YATES                 .
C         THE HESSIAN IS NEEDED INSTEAD OF ITS INVERSE              .
C....................................................................
CTPH  MODE = 0
         IF(LOPT(22).EQ.1 .AND. NUMIT.LT.1) THEN
            IF(MODE1.EQ.1) MODE = MODE2
            IF(MODE1.EQ.0) MODE = MODE2 + NQ
         ENDIF
         CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
C         WRITE(6,666) (C(I),I=1,NQ*NQ)
C 666 FORMAT('HESS  ',6F10.7)
C         WRITE(6,668) (QQ(I),I=1,NQ)
C 668 FORMAT('QQ  ',6F10.7)
         CALL EFC(NUMIT,NQ,F,QQ,FI,C,MODE,QQ1,IFSTRE,GEC)
C         WRITE(6,666) (C(I),I=1,NQ*NQ)
C         WRITE(6,667) (QQ1(I),I=1,NQ)
C 667 FORMAT('QQ1  ',6F10.7)
C         WRITE(6,668) (QQ(I),I=1,NQ)
         CALL OSINV1 (C,NQ,D,1.0D-8,L,M)
      ELSE
         IF(LOPT(21).GT.0) NGEO=NGEO+1
         IF(NGEO.GT.1.AND.LOPT(21).GT.0) THEN
C....................................................................
C (B) DIIS WITH THE POSSIBILITY OF UPDATING THE HESSIAN; THEREFORE  .
C     THE ERROR VECTORS MUST BE RECALCULATED FROM THE PREVIOUS AND  .
C     PRESENT GRADIENTS, USING THE NEW HESSIAN  E = (H)-1*G         .
C....................................................................
C....................................................................
C     READ IN PAST COORDINATES AND GRADIENTS INTO QD AND FD         .
C....................................................................
            IF(NGEO.GE.NQ) NGEO = NQ-1
            DO 880 J=1,NGEO-1
               DO 880 I=1,NQ
                  READ(INP2,2390) QD(I,J),FD(I,J)
  880       CONTINUE
            M1=NGEO+1
            MM1=NQ
            MNQ=NMAX
            DO 890 I=1,NQ
               FD(I,NGEO)=FI(I)
               QD(I,NGEO)=QQ(I)
  890       CONTINUE
      CALL GDIIS(MM1,NQMAX,M1,NQ,QD,FD,C,A,NV,N2V,QQ,FI,DV,XLAM,IER)
CTPH.................................................................
C     EXTRAPOLATED COORDINATES AND FORCES IN QQ AND FI, THEN RELAX  .
C     PRINTING OF DIIS MATRIX FOR DEBUGGING, TO BE CHANGED LATER    .
CTPH.................................................................
            WRITE(IOUT,2401)
 2401       FORMAT('INVERSE HESSIAN')
            DO 901 I=1,NQ
               J1=(I-1)*NQ+1
               JN=(I-1)*NQ+I
               WRITE(IOUT,2270) (C(J), J=J1,JN)
  901       CONTINUE
            WRITE(IOUT,2400)
            DO 900 I=1,M1
               J1=(I-1)*M1+1
               JN=(I-1)*M1+I
               WRITE(IOUT,2270) (A(J), J=J1,JN)
  900       CONTINUE
            IF (IER.EQ.0) GO TO 910
CTPH.................................................................
C     ERROR SECTION, TO BE CHANGED LATER TO STOP PROGRAM            .
CTPH.................................................................
            WRITE(IOUT,2405)
            RETURN
  910       CONTINUE
C....................................................................
C     PUT INTERNAL DISPLACEMENTS AND OLD INT. COORDINATES IN QQ1, QQ.
C....................................................................
CC    DO 930 I=1,NQ
CC       QQ1(I)=QQ(I)-QD(I,NGEO)
CC       QQ(I)=QD(I,NGEO)
CC930 CONTINUE
            WRITE(IOUT,2320) (QQ(I),I=1,NQ)
            WRITE(IOUT,2320) (FI(I),I=1,NQ)
            WRITE(IOUT,2410) (DV(I),I=1,NGEO)
            WRITE(IOUT,2420) XLAM
         ENDIF
C....................................................................
C    (C)  NEWTON RAPHSON STEP WHICH IS THE DEFAULT                  .
C....................................................................
         IJ=0
         DO 950 I=1,NQ
            S=ZERO
            DO 940 J=1,NQ
               IJ=IJ+1
               S=S+C(IJ)*FI(J)
  940       CONTINUE
            QQ1(I)=S
  950    CONTINUE
C         WRITE(6,668) (QQ(I),I=1,NQ)
C         WRITE(6,667) (QQ1(I),I=1,NQ)
      ENDIF
C....................................................................
C     CALCULATE FLAMBDA FOR FLETCHER PROCEDURE, PRINT NEW INTERNAL  .
C     COORDINATES AND DISPLACEMENTS, PUT DISPLACEMENTS IN GEC FOR   .
C     WRITING TO RESUL2 LATER                                       .
C....................................................................
      IF(LOPT(10).GE.1) THEN
      WRITE(IOUT,2430)
      ELSE
      WRITE(IOUT,2440)
      END IF
      FLAMDA=0.0D0
      DO 960 I=1,NQ
         FLAMDA=FLAMDA+QQ1(I)*FII(I)
         QQ(I)=QQ(I)+QQ1(I)
         IF(NGEO.GT.1.AND.LOPT(21).GT.0) QQ1(I) = QQ(I) - QD(I,NGEO)
         GEC(I)=QQ1(I)
         WRITE (IOUT,2260) I,QQ1(I),QQ(I)
         QQ(I)=QQ(I)-QQ1(I)
         CC(I)=QQ1(I)
  960 CONTINUE
      IF(NFIX.EQ.0) GO TO 980
C....................................................................
C     SET CERTAIN DISPLACEMENTS TO ZERO (FIXC OPTION)               .
C....................................................................
      DO 970  I=1,NFIX
       CC(IFIX(I))=ZERO
  970  QQ1(IFIX(I))=ZERO
C....................................................................
C     REGAIN THE HESSIAN FROM THE INVERSE                           .
C....................................................................
  980 CALL OSINV1 (C,NQ,D,1.0E-8,L,M)
      IF(LOPT(4).GT.0.OR.LOPT(15).GT.0) GO TO 1010
C....................................................................
C     CHECK THE FORCE CONSTANTS TO SEE WHICH FORMAT TO USE, PRINT   .
C     IN FILE INP2                                                  .
C....................................................................
      REWIND INP2
      JTRI=NQ*(NQ+1)/2
      IBIG=0
      DO 990 J=1,JTRI
         IF(C(J).LE.-10.0D0.OR.C(J).GE.100.0D0) IBIG=1
  990 CONTINUE
      IJ=1
      DO 1000 I=1,NQ
         IJ1=IJ+I-1
         IF(IBIG.EQ.1) THEN
            WRITE(INP2,2320)(C(J),J=IJ,IJ1)
         ELSE
            WRITE(INP2,2450)(C(J),J=IJ,IJ1)
            WRITE(IOUT,2450)(C(J),J=IJ,IJ1)
         ENDIF
         IJ=IJ+NQ
 1000 CONTINUE
C....................................................................
      IF(LOPT(10).GT.0) GO TO 1040
      IF(LOPT(4).LT.1) GO TO 1210
C....................................................................
C     CHECK THE FORCE CONSTANTS TO SEE WHICH FORMAT TO USE, PRINT   .
C     IN FILE IPUN,IOUT,INP2                                        .
C....................................................................
 1010 IF(NUMIT.GT.0) WRITE(IOUT,2460)
      REWIND INP2
      JTRI=NQ*(NQ+1)/2
      IBIG=0
      DO 1020 J=1,JTRI
         IF(C(J).LE.-10.0D0.OR.C(J).GE.100.0D0) IBIG=1
 1020 CONTINUE
      IJ=1
      IF(LOPT(5).NE.0) WRITE(IPUN,2310)
      DO 1030 I=1,NQ
         IJ1=IJ+I-1
         IF(IBIG.EQ.1) THEN
       IF(NUMIT.GE.1.AND.LOPT(24).EQ.0) WRITE(IOUT,2320) (C(J),J=IJ,IJ1)
            WRITE(INP2,2320)(C(J),J=IJ,IJ1)
            IF (LOPT(5).GT.0) WRITE(IPUN,2320) (C(J),J=IJ,IJ1)
         ELSE
       IF(NUMIT.GE.1.AND.LOPT(24).EQ.0) WRITE(IOUT,2450) (C(J),J=IJ,IJ1)
            WRITE(INP2,2450)(C(J),J=IJ,IJ1)
            IF (LOPT(5).GT.0) WRITE(IPUN,2450) (C(J),J=IJ,IJ1)
         ENDIF
         IJ=IJ+NQ
 1030 CONTINUE
      IF(LOPT(4).GE.1) GO TO 1210
C....................................................................
C     FIRST PART OF THE FLETCHER POWELL PROCEDURE (FLT1)            .
C....................................................................
 1040 DO 1050  I=1,NQ
 1050 CCC(I)=QQ1(I)
      IF(LOPT(13).EQ.1) GO TO 1080
      IFLT=1
C....................................................................
C     CHECK TO SEE IF LAST STEP ALONG FLETCHER-POWELL VECTOR IS MADE.
C....................................................................
 1060 IF(ETA(IFLT).EQ.ZERO) GO TO 1450
      DO 1070  I=1,NQ
      QQ(I)=QQQ(I)
      QQ1(I)=ETA(IFLT)*CCC(I)
 1070 CC(I)=QQ1(I)
      WRITE(IOUT,2470) ETA(IFLT)
      GO TO 1210
C....................................................................
C     SECOND PART OF THE FLETCHER POWELL PROCEDURE (FLT2)           .
C....................................................................
 1080 IJ=1
      IF(ENERGY(3).GE.0.0D0) GO TO 1120
      DO 1090 I=1,3
      CI(IJ)=1
      CI(IJ+1)=ETA(I)
      CI(IJ+2)=ETA(I)**2
 1090 IJ=IJ+3
      CALL OSINV1(CI,3,D,1.0E-8,L,M)
      IJ=0
      DO 1110 I=1,3
      S=ZERO
      DO 1100 J=1,3
      IJ=IJ+1
 1100 S=S+CI(IJ)*ENERGY(J)
 1110 AE(I)=S
      ETA(4)=-AE(2)/(TWO*AE(3))
      ENERGY(4)=ETA(4)*(ETA(4)*AE(3)+AE(2)) +AE(1)
      GO TO 1130
 1120 WRITE(IOUT,*) 'FLAMDA=',FLAMDA
      FLAMDA=FLAMDA*ANG/GDYN
      ELAMDA=(ENERGY(1)-ENERGY(2))/ETA(1)+FLAMDA
      ETA(4)=FLAMDA*ETA(1)/(2.0D0*ELAMDA)
      ENERGY(4)=ENERGY(2)-FLAMDA*ETA(4)/2.0D0
 1130 IFLT=4
      DO 1140 I=1,NQ
      QQ(I)=QQQ(I)
      QQ1(I)=ETA(IFLT)*CCC(I)
 1140 CC(I)=QQ1(I)
      WRITE(IOUT,2480) ENERGY(4)
      WRITE(IOUT,2490) ETA(4)
      GO TO 1210
 1150 CONTINUE
C....................................................................
C     WRITE OUT ORIGINAL INTERNAL COORDINATES, DISPLACEMENTS        .
C     FOR ONE DISTORTED GEOMETRY AT A TIME (DISP OPTION)            .
C     THE PROGRAM LOOPS BACK TO 1160 UNTIL II = # DISPLACEMENTS     .
C....................................................................
      WRITE(IOUT,2500)
      WRITE(IOUT,2510) (QQ(J),J=1,NQ)
      II=0
 1160 II=II+1
         DO 1170 J=1,4
            INDT(J)=INDI(J,II)
 1170       CIN(J)=CCIN(J,II)
      WRITE(IOUT,2200)
      WRITE(IOUT,2520) (INDT(J),CIN(J),J=1,4)
      DO 1180 J=1,NQ
         CC(J)=ZERO
 1180 CONTINUE
      DO 1190 J=1,4
      J1=INDT(J)
        IF (J1.LE.0) GO TO 1190
      CC(J1) = CIN(J)
 1190 CONTINUE
      DO 1200 J=1,NQ
 1200   QQ1(J)=CC(J)
      GO TO 1250
C....................................................................
C     MAKE B MATRIX, THEN (B*M*B+)-1  IN C                          .
C....................................................................
 1210 DO 1220 I=1,NCARD
      BACKSPACE INP
 1220 CONTINUE
      CALL MACHB(NEK,B,NCMAX,NQMAX,XA,YA,ZA,QQ,NADT,IX,IOUT,NQ,.FALSE.,
     1 .FALSE.,NCARD)
      I1=0
      DO 1240 I=1,NQ
      DO 1240 J=1,NQ
      I1=I1+1
      S=ZERO
      DO 1230 K=1,NEK
 1230 S=S+B(K,I)*B(K,J)*XM(K)
 1240 C(I1)=S
      CALL OSINV1(C,NQ,D,TOL,L,M)
 1250 CONTINUE
C....................................................................
C     NOW MAKE TRANSFORM THE INTERNAL DISPLACEMENTS TO CARTESIAN    .
C     DISPLACEMENTS BY DELTA X = (B*M*B+)-1 * B*M * (DELTA Q)       .
C     THIS IS THE SAME TRANSFORMATION USED TO CONVERT CARTESIAN     .
C     FORCES TO INTERNAL FORCES, AND CAN BE USED BECAUSE THE        .
C     DERIVATIVE WITH RESPECT TO A COORDINATE AND A COORDINATE ARE  .
C     CONTRAVARIANT                                                 .
C....................................................................
         IREP=0
         I3=0
         DO 1260 I=1,NADT
            XY(I)=XA(I)
         J=I+NADT
         XY(J)=YA(I)
         J=J+NADT
         XY(J)=ZA(I)
 1260    CONTINUE
C...........................................................
 1270    CONTINUE
      IREP=IREP+1
         IJ=0
         DO 1290 I=1,NQ
            S=ZERO
         DO 1280 J=1,NQ
               IJ=IJ+1
               S=S+C(IJ)*QQ1(J)
 1280 CONTINUE
         FI(I)=S
 1290 CONTINUE
C...........................................................
         DO 1310 I=1,NEK
            S=ZERO
            DO 1300 J=1,NQ
               S=S+B(I,J)*FI(J)
 1300       CONTINUE
         QQ1(I)=S*XM(I)
 1310    CONTINUE
C....................................................................
C     UPDATE THE CARTESIAN COORDINATES                              .
C....................................................................
         I3=0
         DO 1320 I=1,NADT
            I3=I3+3
            XY(I)=XY(I)+QQ1(I3-2)
            J=I+NADT
            XY(J)=XY(J)+QQ1(I3-1)
            J=J+NADT
            XY(J)=XY(J)+QQ1(I3)
 1320   CONTINUE
C....................................................................
C     RECALCULATE THE INTERNALS AT THE NEW CARTESIAN COORDINATES    .
C     USING THE SAME OLD B MATRIX                                   .
C....................................................................
         I1=NADT+1
         I2=2*NADT+1
         DO 1330 I=1,NCARD
            BACKSPACE INP
 1330 CONTINUE
         CALL MACHB (NEK,B,NCMAX,NQMAX,XY(1),XY(I1),XY(I2),QQ1,NADT,IX,
     1               IOUT,NQ,.FALSE.,.TRUE.,NCARD)
C....................................................................
C     THE INTERNAL COORDINATES CORRESPONDING TO THE PRESENT         .
C     CARTESIAN COORDINATES ARE NOW IN QQ1                          .
C....................................................................
          WRITE (IOUT,2530) IREP
         WRITE  (IOUT,2510)  (QQ1(I),I=1,NQ)
         QMAX=ZERO
         DO 1340 I=1,NQ
            QQ1(I)=QQ(I)+CC(I)-QQ1(I)
            IF  (QMAX.LT.DABS(QQ1(I)))  QMAX=ABS(QQ1(I))
 1340    CONTINUE
         IF (IREP.LT.MXITER.AND.QMAX.GT.CRTTOL) GO TO 1270
C....................................................................
C     IF QQ1 MATCHES THE DESIRED FINAL SET OF INTERNAL COORDINATES  .
C     GO ON, ELSE DO ANOTHER ITERATIVE CYCLE                        .
C....................................................................
         IF (QMAX.GT.CRTTOL) THEN
            WRITE(IOUT,2540) MXITER
C....................................................................
C     IF FIRST DISPLACEMENT TRY, SCALE AND TRY ONCE MORE            .
C....................................................................
            IF(FIRSTD) THEN
               FIRSTD=.FALSE.
               WRITE(IOUT,2545)
               DO 1345 I=1,NQ
                  QQ1(I)=0.3D0*CC(I)
                  CC(I) = QQ1(I)
 1345          CONTINUE
               GO TO 1250
            ENDIF
         ENDIF
         WRITE(IOUT,2550)
 1350    CONTINUE
C....................................................................
C     PRINT THE DISPLACEMENTS IN CARTESIAN COORDINATES              .
C....................................................................
         I3=0
         DO 1360 I=1,NA
            I3=I3+3
            YM=ONE/XM(I3)
            J=I+NADT
            J1=J+NADT
            X=XY(I)-XA(I)
            Y=XY(J)-YA(I)
            Z=XY(J1)-ZA(I)
            WRITE (IOUT,2560) I,IA(I),X,Y,Z,YM
 1360    CONTINUE
C....................................................................
C     PRINT THE NEW CARTESIAN COORDINATES                           .
C....................................................................
         WRITE(IOUT,2570)
      I3=0
      DO 1370 I=1,NA
           J=I+NADT
           J1=J+NADT
           I3=I3+3
           YM=ONE/XM(I3)
           WRITE(IOUT,2560) I,IA(I),XY(I),XY(J),XY(J1),YM
 1370 CONTINUE
C.................................................................
      IF(LOPT(2).EQ.1) GO TO 1390
 1380 CONTINUE
      IF(II.LT.NDI) GO TO 1420
 1390 REWIND INP2
      IF(LOPT(3).GT.0) GO TO 1410
C....................................................................
C     READ FORCE CONSTANT MATRIX BACK IN FROM INP2                  .
C....................................................................
      JJ=1
      DO 1400 I=1,NQ
      IJ1=JJ + I -1
      READ(INP2,2450)(C(J),J=JJ,IJ1)
      JJ=JJ+NQ
 1400 CONTINUE
C.................................................................
 1410 REWIND INP2
 1420 WRITE(IOUT,2580)
C....................................................................
C     WRITE NEW GEOMETRY IN ATOMIC UNITS TO IGMUP                   .
C....................................................................
      CALL LOCATE (IGMUP,'# GEOML ##',IERRWA)
      BACKSPACE IGMUP
      WRITE(IGMUP,'(A10)') '# GEOMUP #'
      DO 1440 I=1,NA
      J=I+NADT
      J1=J+NADT
      X=XY(I)*ANG
      Y=XY(J)*ANG
      Z=XY(J1)*ANG
      WRITE(IGMUP,2590) X,Y,Z
 1430 WRITE(IOUT,2600) I,IA(I),X,Y,Z
 1440 CONTINUE
 1450 CONTINUE
      WRITE(IGMUP,'(A10)')  '# GEOML ##'
C....................................................................
C     IF NOT THE LAST DISPLACEMENT USING DISP OPTION, DO ANOTHER    .
C....................................................................
      IF(II.LT.NDI) GO TO 1160
C....................................................................
C     IF NOT THE LAST STEP ALONG FLETCHER-POWELL VECTOR (FLT1) DO   .
C     THE NEXT                                                      .
C....................................................................
      IF(LOPT(10).GE.1.AND.IFLT.LT.4) THEN
           IFLT=IFLT+1
           GO TO 1060
      END IF
      IF(LOPT(3).GT.0) GO TO 1520
C....................................................................
C  WRITE OUT NGEO AND NUMIT                                         .
C....................................................................
      REWIND INP2
      WRITE(INP2,2070) NGEO,NUMIT+1
C....................................................................
C     WRITE CARTESIAN COORDINATES IN ATOMIC UNITS IN INP2           .
C....................................................................
      DO 1460 I=1,NA
      J=I+NADT
      J1=J+NADT
      X=XY(I)*ANG
      Y=XY(J)*ANG
      Z=XY(J1)*ANG
      WRITE(INP2,2610)SYMB(I),IA(I),X,Y,Z
 1460 CONTINUE
C....................................................................
C     WRITE FORCE CONSTANTS IN INTERNAL COORDINATES IN INP2, AFTER  .
C     CHECKING TO SEE WHICH FORMAT TO USE                           .
C....................................................................
      JTRI=NQ*(NQ+1)/2
      IBIG=0
      DO 1470 J=1,JTRI
         IF(C(J).LE.-10.0D0.OR.C(J).GE.100.0D0) IBIG=1
 1470 CONTINUE
      JJ=1
      DO 1480 I=1,NQ
         IJ1=JJ+I-1
         IF(IBIG.EQ.1) THEN
            WRITE(INP2,2320)(C(J),J=JJ,IJ1)
         ELSE
            WRITE(INP2,2450)(C(J),J=JJ,IJ1)
         ENDIF
         JJ=JJ+NQ
 1480 CONTINUE
C....................................................................
C     WRITE OUT INTERNAL FORCES, COORDINATES, AND DISPLACEMENTS;    .
C     THEN MODE1
C....................................................................
      DO 1490 I=1,NQ
 1490 WRITE(INP2,2340) QQQ(I),FII(I),GEC(I)
      WRITE(INP2,2620) MODE
C....................................................................
C     WRITE OUT INTERNAL COORDINATES AND FORCES FOR ALL PREVIOUS    .
C     GEOMETRIES, STARTING WITH THE OLDEST FOR GDIIS                .
C....................................................................
      IF(LOPT(21).GT.0) THEN
         IF(NUMIT.GE.1) THEN
            JS=1
            IF(NGEO.GE.NQ-1) JS=2
            DO 1500 J=JS,NGEO
               DO 1500 I=1,NQ
                  WRITE(INP2,2390) QD(I,J),FD(I,J)
 1500       CONTINUE
         ELSE
            DO 1505 I=1,NQ
               WRITE(INP2,2390) QQQ(I),FII(I)
 1505       CONTINUE
         ENDIF
      ENDIF
C....................................................................
C     WRITE OUT THE MODE NUMBER OF THE MODE MOST LIKE THE PREVIOUS  .
C     ONE, THEN THE EIGENMODE OF THE HESSIAN ITSELF                 .
C....................................................................
      IF(LOPT(20).GT.0) THEN
         DO 1510 I=1,NQ
            WRITE(INP2,2630) VMODE(I)
 1510 CONTINUE
      ENDIF
 1520 CONTINUE
      REWIND INP2
 1530 RETURN
C
 2000 FORMAT (A4,1X,I5)
 2010 FORMAT(1X,A4,2X,13HOPTION IS ON ,I5)
 2020 FORMAT(A4,6X,4F6.0)
 2025 FORMAT(1X,A4,2X,13HOPTION IS ON ,4F6.0)
 2030 FORMAT(A4,8X,3(F6.0,F16.10))
 2035 FORMAT(1X,A4,8X,3(F6.3,F16.10))
 2040 FORMAT(A4,1X,9I5)
 2045 FORMAT(1X,A4,2X,13HOPTION IS ON ,9I5)
 2050 FORMAT(A4,1X,2I5)
 2055 FORMAT(1X,A4,2X,13HOPTION IS ON ,2I5)
 2060 FORMAT(A4,12X,3F16.10)
 2065 FORMAT(1X,A4,1X,4H IS ,3(F16.2,2X))
 2070 FORMAT(2I5)
 2080 FORMAT(1X,A2)
 2090 FORMAT(1X,'EXFI READ ERROR--',A2)
 2100 FORMAT (1X,'TOO MANY NUCLEI, EXPECTING ',I5)
 2105 FORMAT (1X,'CARD OPTION MISSING, PLEASE TELL ME HOW MANY ATOMS
     &        THERE ARE!')
 2110 FORMAT (20X,28HNUCLEAR COORDINATES IN BOHRS    ,/)
 2120 FORMAT(1X,A5,2X,I2,6X,3F16.12,F10.5)
 2130 FORMAT (3X,I2,3X,I2,3(F16.12,2X),F12.6)
 2140 FORMAT (3F16.12)
 2150 FORMAT (//,1X,6HFORCES,/)
 2160 FORMAT (1X,3F16.12)
 2170 FORMAT (/,1X,26HFORCES DO NOT VANISH, SUM=,F15.7,/)
 2180 FORMAT (4(I2,2X,F12.8,2X))
 2190 FORMAT (A4,22X,A2)
 2200 FORMAT(///)
 2210 FORMAT (1X,9HB MATRIX ,//)
 2220 FORMAT ('I=',I2)
 2230 FORMAT (5F16.12)
 2240 FORMAT(/,5X,16H DETERMINANT  = , E16.5)
 2250 FORMAT (/,1X,32HINTERNAL COORDINATES AND FORCES ,/)
 2260 FORMAT (2X,I2,4X,2F16.12)
 2270 FORMAT (8F10.7)
 2280 FORMAT(//,1X,'FLETCHER-POWELL OPTIMIZATION  PART 1',/,120('-'))
 2290 FORMAT(//,1X,'FLETCHER-POWELL OPTIMIZATION  PART 2',/,120('-'))
 2300 FORMAT (1X,'FLETCHER POWELL FORCE CONSTANTS',/)
 2310 FORMAT (1X,16HFORCE CONSTANTS ,/)
 2320 FORMAT (8F10.6)
 2330 FORMAT (/1X,24HOLD GEOMETRY AND FORCES ,/)
 2340 FORMAT(3F16.12)
 2350 FORMAT (1X,'MURTAGH-SARGENT HESSIAN UPDATE',/)
 2360 FORMAT (1X,'DAVIDON-FLETCHER-POWELL HESSIAN UPDATE',/)
 2370 FORMAT (1X,'BFGS HESSIAN UPDATE',/)
 2380 FORMAT (1X,'POWELL HESSIAN UPDATE',/)
 2390 FORMAT(2F16.9)
 2400 FORMAT(1X,'DIIS MATRIX')
 2405 FORMAT(/1X,'ERROR IN DIIS',/1X,'PROBABLY GRADIENTS ARE PARALLEL',
     1 /)
 2410 FORMAT(/1X,'DIIS COEFFICIENTS',/1X,1(10F10.4,/))
 2420 FORMAT(/1X,'LAMBDA =',E12.4)
 2430 FORMAT(/1X,'FLETCHER POWELL DIRECTION VECTOR AND NEW INTERNAL COOR
     1DINATES FOR ETA=1',/)
 2440 FORMAT(/1X,44HGEOMETRY CHANGE AND NEW INTERNAL COORDINATES,/)
 2450 FORMAT (8F10.7)
 2460 FORMAT (/,1X,31HIMPROVED FORCE CONSTANT MATRIX ,/)
 2470 FORMAT(80('-'),/,1X,'ETA= ',F14.10,/)
 2480 FORMAT(80('-'),/,1X,'PREDICTED ENERGY = ',F16.10)
 2490 FORMAT(1X,'ETA= ',F14.10,/)
 2500 FORMAT(/1X,30HORIGINAL INTERNAL COORDINATES ,/)
 2510 FORMAT (2X,5F16.12)
 2520 FORMAT(120('-'),/,' INTERNAL DISPLACEMENT',/,4(I2,2X,F12.8,4X),/)
 2530 FORMAT (1X,5HSTEP=,I4)
 2540 FORMAT(/,1X,'*****CAUTION,WITHIN',I3,'STEPS NO CONVERGENCE*****'/)
 2545 FORMAT(/,1X,'***** TRYING TO SCALE BACK DISPLACEMENT ONCE *****'/)
 2550 FORMAT (/,1X,'  CARTESIAN DISPLACEMENTS AND NEW CARTESIAN COORDINA
     1TES IN ANGSTROMS',/)
 2560 FORMAT(1X,I3,4H   N,I4,3F16.12,F12.6)
 2570 FORMAT(//)
 2580 FORMAT(/' CARTESIAN COORDINATES IN A.U.'/)
 2590 FORMAT(3F20.10)
 2600 FORMAT(1X,I3,4H   N,I4,3F16.12)
 2610 FORMAT(1X,'N=',A4,4X,I2,3F16.12)
 2620 FORMAT(I5)
 2630 FORMAT(8F10.4)
      END
C     ////////////////////////////////////////////////////
      SUBROUTINE NOM (U)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3)
      Y=SCALAR(U,U)
      X = 1.0D0/DSQRT(Y)
      DO 10 I=1,3
         U(I) = U(I)*X
   10 CONTINUE
      RETURN
      END
C     /////////////////////////////////////////////////
      FUNCTION S2(X)
      IMPLICIT REAL*8 (A-H,O-Z)
      Y = 1.0D0-X*X
      S2 = DSQRT(Y)
      RETURN
      END
C     ///////////////////////////////////////
      FUNCTION SCALAR(U,V)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3) , V(3)
      SCALAR = 0.0D0
      DO 10 I=1,3
          SCALAR = SCALAR + U(I)*V(I)
   10 CONTINUE
      RETURN
      END
C     ////////////////////////////////////////////////
      SUBROUTINE NORMAL (U,V,W)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3),V(3),W(3)
C..... W WIRD EIN SENKRECHT AUF DIE EBENE (U,V) STEHENDER EINHEITSVECTOR
      W(1)=U(2)*V(3)-U(3)*V(2)
      W(2)=U(3)*V(1)-U(1)*V(3)
      W(3) = U(1)*V(2)-U(2)*V(1)
      CALL NOM  (W)
      RETURN
      END
C     /////////////////////////////////////////////////
      FUNCTION ARCOS(X)
      IMPLICIT REAL*8 (A-H,O-Z)
      DOUBLE PRECISION ZERO,ONE,PI,PIH,X,Y,X1,ARCOS,S
      PARAMETER(ZERO=0.0D0,ONE=1.0D0,PI=3.14159265358979D0)
      PARAMETER(PIH=1.57079632679490D0,XTOL=1.0D-12)
      Y=DABS(ONE-X)
      IF (X.GE.ONE.OR.Y.LE.XTOL) GO TO 10
      Y=DABS(ONE+X)
      IF(X.LE.-ONE.OR.Y.LE.XTOL) GO TO 20
      Y=ONE-X*X
      X1= DSQRT(Y)
      IF(DABS(X).LT.1.0D-11) GO TO 30
      S=DATAN(X1/X)
      IF (X.LT.ZERO) S=S+PI
      ARCOS=S
      RETURN
   10 ARCOS=ZERO
      RETURN
   20 ARCOS=PI
      RETURN
   30 ARCOS=PIH
      RETURN
      END
C     ///////////////////////////////////////////////////////
      SUBROUTINE VEKTOR (U,R,I,J,XA,YA,ZA)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION U(3), XA(1), YA(1), ZA(1)
C
C        BILDET DEN NORMIERTEN ENTFERNUNGSVECTOR VON KERN J NACH KERN I
C        UND DIE ENTFERNUNG R
C
      U(1)=XA(I)-XA(J)
      U(2)=YA(I)-YA(J)
      U(3)=ZA(I)-ZA(J)
      Y = SCALAR(U,U)
      R = DSQRT(Y)
      CALL NOM (U)
      RETURN
      END
C     //////////////////////////////////////////////////////////////
      SUBROUTINE OSINV1 (A,N,D,TOL,L,M)
C
C     PARAMETERS   A - INPUT MATRIX , DESTROYED IN COMPUTATION AND
C                      REPLACED BY RESULTANT INVERSE
C                  N - ORDER OF MATRIX A
C                  D - RESULTANT DETERMINANT
C            L AND M - WORK VECTORS OF LENGHT N
C                TOL - IF PIVOT ELEMENT IS LESS THAN THIS PARAMETER THE
C                      MATRIX IS TAKEN FOR SINGULAR (USUALLY 1.0E-8)
C     A DETERMINANT OF ZERO INDICATES THAT THE MATRIX IS SINGULAR
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(1), M(1), L(1)
      PARAMETER(ONE=1.0D0,ZERO=0.0D0)
      D=ONE
      NK=-N
      DO 180 K=1,N
      NK=NK+N
      L(K)=K
      M(K)=K
      KK=NK+K
      BIGA=A(KK)
      DO 20 J=K,N
      IZ=N*(J-1)
      DO 20 I=K,N
      IJ=IZ+I
      IF (DABS(BIGA)-DABS(A(IJ))) 10,20,20
   10 BIGA=A(IJ)
      L(K)=I
      M(K)=J
   20 CONTINUE
      J=L(K)
      IF(J-K) 50,50,30
   30 KI=K-N
      DO 40 I=1,N
      KI=KI+N
      HOLO=-A(KI)
      JI=KI-K+J
      A(KI)=A(JI)
   40 A(JI)=HOLO
   50 I=M(K)
      IF(I-K) 80,80,60
   60 JP=N*(I-1)
      DO 70 J=1,N
      JK=NK+J
      JI=JP+J
      HOLO=-A(JK)
      A(JK)=A(JI)
   70 A(JI)=HOLO
   80 IF(DABS(BIGA)-TOL) 90,100,100
   90 D=ZERO
      RETURN
  100 DO 120 I=1,N
      IF(I-K) 110,120,110
  110 IK=NK+I
      A(IK)=A(IK)/(-BIGA)
  120 CONTINUE
      DO 150 I=1,N
      IK=NK+I
      IJ=I-N
      DO 150 J=1,N
      IJ=IJ+N
      IF(I-K) 130,150,130
  130 IF(J-K) 140,150,140
  140 KJ=IJ-I+K
      A(IJ)=A(IK)*A(KJ)+A(IJ)
  150 CONTINUE
      KJ=K-N
      DO 170 J=1,N
      KJ=KJ+N
      IF(J-K) 160,170,160
  160 A(KJ)=A(KJ)/BIGA
  170 CONTINUE
      D=D*BIGA
      A(KK)=ONE/BIGA
  180 CONTINUE
      K=N
  190 K=K-1
      IF(K) 260,260,200
  200 I=L(K)
      IF(I-K) 230,230,210
  210 JQ=N*(K-1)
      JR=N*(I-1)
      DO 220 J=1,N
      JK=JQ+J
      HOLO=A(JK)
      JI=JR+J
      A(JK)=-A(JI)
  220 A(JI)=HOLO
  230 J=M(K)
      IF (J-K) 190,190,240
  240 KI=K-N
      DO 250 I=1,N
      KI=KI+N
      HOLO=A(KI)
      JI=KI+J-K
      A(KI)=-A(JI)
  250 A(JI)=HOLO
      GO TO 190
  260 RETURN
      END
C     ///////////////////////////////////////////////////////////////
      SUBROUTINE MACHB (NEK,BMAT,NCMAX,NQMAX,XA,YA,ZA,QQ,N,INP,IOUT,NQ,W
     1RI,QONLY,NCARD)
C     ********************************
C     TAKEN FROM PULAY'S PROGRAM TEXAS
C     ********************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DOUBLE PRECISION ARCOS
      LOGICAL WRI,QONLY,SFIRST
C
C     NQ IS THE NUMBER OF INTERNAL COORDINATES
C     NEK IS 3* THE NUMBER OF ATOMS
C     BMAT IS THE TRANSPOSE OF THE B MATRIX, DIMENSIONED AS
C       B(NCMAX,NQMAX) IN THE CALLING PROGRAM
C     XA,YA,AND ZA ARE THE X,Y,Z COORDINATES OF THE ATOMS IN ANGSTROMS
C     QONLY IS TRUE IF ONLY INTERNAL COORDINATES ARE DESIRED,
C       NOT THE B MATRIX
C     THE INTERNAL COORDINATE TYPES CAN BE STRETCH, BEND, TORSION, OUT-
C     OF PLANE BENDING, LINEAR1, LINEAR2, AND INVERSE BOND LENGTH
C     THE ORDER OF THE ATOMS FOR BEND, LIN1, AND LIN2 HAVE BEEN CHANGED
C     SO THAT THE CENTER ATOM IS IN THE SECOND POSITION INSTEAD OF 3RD
C     THE TORSION COORDINATE RANGE IS -PI/2 TO 3PI/2
C     THE SIMPLE INTERNAL COORDINATES ARE PRINTED NOW
C
      DIMENSION QQ(1)
      DIMENSION TIPUS(7)
      DIMENSION WORT(3)
      DIMENSION A(4), IA(4), U(3), V(3), W(3), Z(3), X(3), UU(3), VV(3),
     1 WW(3), ZZ(3), UV(12)
      DIMENSION BMAT(NCMAX,NQMAX), XA(1), YA(1), ZA(1)
      COMMON/DISCON/SSS(100),SFIRST
      EQUIVALENCE (KA,IA(1)), (KB,IA(2)), (KC,   IA(3)), (KD,IA(4))
      EQUIVALENCE (UV(1),UU(1)), (UV(4),VV(1)), (UV(7),WW(1)), (UV(10),Z
     1Z(1))
      PARAMETER(ONE=1.0D0,ZERO=0.0D0,PI=3.14159265358979D0)
      PARAMETER(PIH=1.57079632679490D0,TPI=6.28318530717959D0)
      DATA TIPUS/4HSTRE,4HBEND,4HOUT ,4HTORS,4HLIN1,4HLIN2,4HINVR/
      DATA WORT/4HK   ,4H    ,4HF   /
      RAD=180.0/PI
      ANULL=ONE
      NCARD=0
      O=ONE
      NAB=NEK
      NAB=NAB/3.0+0.1
      I=0
      ISS = 0
      C1=ZERO
      MATF=0
CTPH  WRITE(IOUT,330)
      IF (WRI) WRITE(IOUT,330)
   10 READ(INP,340) WE
      BACKSPACE INP
      DO 20 K=1,3
      IF  (WE.EQ.WORT(K))  GO TO 50
   20 CONTINUE
   30 CONTINUE
      C1=DSQRT(ONE/C1)/ANULL
      QQ(I)=QQ(I)*C1
      IF(QONLY) GO TO 310
      DO 40 K=1,NEK
      BMAT(K,I)=BMAT(K,I)*C1
   40 CONTINUE
      GO TO 310
   50 CONTINUE
      NCARD=NCARD+1
      READ(INP,350) WE,C,TYP,IA
      IF (C.EQ.0.0) C=ONE
      IF (WE.EQ.WORT(2)) C1=C1+C**2
      IF (WE.NE.WORT(1)) GO TO 100
      IF(I.EQ.0) GO TO 80
      IF(WRI) WRITE(IOUT,360)
      C1=DSQRT(ONE/C1)/ANULL
      IF (QONLY) GO TO 70
      DO 60 K=1,NEK
      BMAT(K,I)=BMAT(K,I)*C1
   60 CONTINUE
   70 QQ(I)=QQ(I)*C1
   80 I=I+1
      QQ(I)=ZERO
      C1=C**2
      IF (QONLY) GO TO 100
      DO 90 J=1,NEK
         BMAT(J,I)=ZERO
   90 CONTINUE
  100 IF (WE.NE.WORT(3)) GO TO 110
      MATF=1
      GO TO 30
  110 CONTINUE
C 110 DO 120 K=1,4
C        IA(K)=A(K)+0.1
  120 CONTINUE
      DO 130 K=1,7
         IF (TYP.EQ.TIPUS(K)) GO TO 140
  130 CONTINUE
      ERROR=7
      WRITE (IOUT,370) I
      GO TO 320
  140 CONTINUE
      IF (KA.LT.1.OR.KA.GT.NAB.OR.KB.LT.1.OR.KB.GT.NAB) GO TO 300
      IF (K.EQ.7) GO TO 145
      IF (K.GT.1.AND.(KC.LT.1.OR.KC.GT.NAB)) GO TO 300
      IF (K.GT.2.AND.(KD.LT.1.OR.KD.GT.NAB)) GO TO 300
  145 GO TO (150,160,180,210,230,250,265), K
C
C     ..... STRETCH
C
  150 CALL VEKTOR (UU,R1,KA,KB,XA,YA,ZA)
      UU(1)=UU(1)*ANULL
      UU(2)=UU(2)*ANULL
      UU(3)=UU(3)*ANULL
      VV(1)=-UU(1)
      VV(2)=-UU(2)
      VV(3)=-UU(3)
      IA(3)=0
      IA(4)=0
      QQ(I) = QQ(I) + R1*C
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,R1
      GO TO 270
C
C     .....BENDING
C
  160 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KC,KB,XA,YA,ZA)
      CO=SCALAR(U,V)
      SI=S2(CO)
      DO 170 L=1,3
         UU(L)=(CO*U(L)-V(L))/(SI*R1)
      WW(L)=(CO*V(L)-U(L))/(SI*R2)
      VV(L)=-UU(L)-WW(L)
  170 CONTINUE
      IA(4)=0
      QQ(I)=QQ(I)+C*ARCOS(CO)
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,RAD*ARCOS(CO)
CTPH  IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,ARCOS(CO)
      GO TO 270
C
C     .....OUT OF PLANE
C
  180 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KC,KB,XA,YA,ZA)
      CALL VEKTOR (W,R3,KD,KB,XA,YA,ZA)
      CALL NORMAL (V,W,Z)
      STETA=SCALAR(U,Z)
      CTETA=S2(STETA)
      CFI1=SCALAR(V,W)
      SFI1=S2(CFI1)
      CFI2=SCALAR(W,U)
      CFI3=SCALAR(V,U)
      DEN=CTETA*SFI1**2
      ST2=(CFI1*CFI2-CFI3)/(R2*DEN)
      ST3=(CFI1*CFI3-CFI2)/(R3*DEN)
      DO 190 L=1,3
         WW(L)=Z(L)*ST2
      ZZ(L)=Z(L)*ST3
  190 CONTINUE
      CALL NORMAL(Z,U,X)
      CALL NORMAL(U,X,Z)
      DO 200 L=1,3
         UU(L)=Z(L)/R1
         VV(L)=-UU(L)-WW(L)-ZZ(L)
  200 CONTINUE
      CX=-C
      IF (STETA.LT.ZERO) CX=C
      QQ(I)=QQ(I)-CX*ARCOS(CTETA)
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,-RAD*CX*ARCOS(CTETA)/C
CTPH  IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,-CX*ARCOS(CTETA)/C
      GO TO 270
C
C     ..... TORSION
C
  210 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KC,KB,XA,YA,ZA)
      CALL VEKTOR (W,R3,KC,KD,XA,YA,ZA)
      CALL NORMAL (U,V,Z)
      CALL NORMAL (W,V,X)
      CO=SCALAR(U,V)
      CO2=SCALAR(V,W)
      SI=S2(CO)
      SI2=S2(CO2)
      DO 220 L=1,3
         UU(L)=Z(L)/(R1*SI)
         ZZ(L)=X(L)/(R3*SI2)
         VV(L)=(R1*CO/R2-ONE)*UU(L)-R3*CO2/R2*ZZ(L)
         WW(L)=-UU(L)-VV(L)-ZZ(L)
  220 CONTINUE
      CO=SCALAR(Z,X)
      U(1)=Z(2)*X(3)-Z(3)*X(2)
      U(2)=Z(3)*X(1)-Z(1)*X(3)
      U(3)=Z(1)*X(2)-Z(2)*X(1)
      CO2=SCALAR(U,V)
      S=ARCOS(-CO)
      IF(CO2.LT.ZERO) S=-S
C     THE FOLLOWING THREE LINES PREVENT DISCONTINUITY DURING THE
C     TRANSFORMATION TO THE NEW CARTESIAN COORDINATES.  SSS CONTAINS
C     THE INITIAL VALUES OF THE SIMPLE INTERNAL TORSIONAL COORDINATES.
      ISS = ISS + 1
      IF(SFIRST) SSS(ISS) = S
CBFY  IF (S.GT.PIH) S=S-TPI
      IF (SSS(ISS).GT.PIH) S=S-TPI
      QQ(I)=QQ(I)-C*S
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,-RAD*S
CTPH  IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,-S
C
C     .... REMEMBER THAT THE RANGE OF THIS COORDINATE IS -PI/2 TO 3*PI/2
C     .... IN ORDER TO SHIFT THE DISCONTINUITY OFF THE PLANAR POSITION
C
      GO TO 270
C
C     .....LINEAR COPLANAR BENDING
C
  230 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KD,KB,XA,YA,ZA)
      CALL VEKTOR (X,R2,KC,KB,XA,YA,ZA)
      CO=SCALAR(V,U)
      CO2=SCALAR(X,V)
      QQ(I)=QQ(I)+C*(PI-ARCOS(CO)-ARCOS(CO2))
      CALL NORMAL (V,U,W)
      CALL NORMAL (U,W,Z)
      CALL NORMAL(X,V,W)
      CALL NORMAL (W,X,U)
C
C     ..... COORDINATE POSITIVE IF ATOM A MOVES TOWARDS ATOM D
C
      DO 240 L=1,3
         UU(L)=Z(L)/R1
      WW(L)=U(L)/R2
      VV(L)=-UU(L)-WW(L)
  240 CONTINUE
      IA(4)=0
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,RAD*(PI-ARCOS(CO)-ARCOS(CO2))
CTPH  IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,PI-ARCOS(CO)-ARCOS(CO2)
      GO TO 270
C
C     ..... LINEAR PERPENDICULAR BENDING
C
  250 CALL VEKTOR (U,R1,KA,KB,XA,YA,ZA)
      CALL VEKTOR (V,R2,KD,KB,XA,YA,ZA)
      CALL VEKTOR (Z,R2,KC,KB,XA,YA,ZA)
      CALL NORMAL (V,U,W)
      CALL NORMAL (Z,V,X)
      DO 260 L=1,3
         UU(L)=W(L)/R1
      WW(L)=X(L)/R2
         VV(L)=-UU(L)-WW(L)
  260 CONTINUE
      IA(4)=0
      CO=SCALAR(U,W)
      CO2=SCALAR(Z,W)
      QQ(I)=QQ(I)+C*(PI-ARCOS(CO)-ARCOS(CO2))
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,RAD*(PI-ARCOS(CO)-ARCOS(CO2))
CTPH  IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,PI-ARCOS(CO)-ARCOS(CO2)
      GO TO 270
C
C     ..... INVERSE BOND LENGTH
C
  265 CALL VEKTOR (UU,R1,KA,KB,XA,YA,ZA)
      RM1=ONE/R1
      RM2=RM1*RM1
      UU(1)=-RM2*UU(1)*ANULL
      UU(2)=-RM2*UU(2)*ANULL
      UU(3)=-RM2*UU(3)*ANULL
      VV(1)=-UU(1)
      VV(2)=-UU(2)
      VV(3)=-UU(3)
      IA(3)=0
      IA(4)=0
      QQ(I) = QQ(I) + RM1*C
      IF (WRI) WRITE(IOUT,380) I,TYP,IA,C,RM1
  270 IF (QONLY) GO TO 10
      DO 290 J=1,4
         M=IA(J)
      IF (M.LE.0) GO TO 290
         M=M-1
      J1=3*(J-1)
         DO 280 L=1,3
            M1=3*M+L
            L1=J1+L
            BMAT(M1,I)=UV(L1)*C+BMAT(M1,I)
  280    CONTINUE
  290 CONTINUE
      GO TO 10
  300 ERROR=6
      WRITE (IOUT,390) I
  310 NQ=I
      SFIRST = .FALSE.
  320 RETURN
C
  330 FORMAT(//,1X,'DEFINITION OF INTERNAL COORDINATES          VALUE (A
     &NGS. OR DEGR.)' ,//)
  340 FORMAT(A4)
  350 FORMAT(A4,6X,F16.12,A4,6X,5I3)
  360 FORMAT(1X)
  370 FORMAT(/,1X,38HUNDEFINED INT.COORDINATE TYPE AT NO.  ,I3,/,10(4H**
     1**))
  380 FORMAT(1X,I3,'.',A8,4I3,F16.12,4X,F18.12)
  390 FORMAT(/,1X,41HATOMS ERRONOUSLY DEFINED,COORDINATE NO.  ,I3,/,1X,
     110(4H****))
c
c
      END
      SUBROUTINE GDIIS (MM1,MNQ,M1,NQ,Q,G,H,A,LL,MM,DQ,DG,C,XLAM,IER)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Q(MNQ,MM1), G(MNQ,MM1), A(M1,M1), LL(NQ), MM(NQ),
     1DQ(NQ), DG(NQ), C(M1), H(NQ,NQ)
      COMMON /IO/ IN,IOUT,INP2,IPUN,IGMUP
C
C     CONSTRUCTS AND SOLVE DIIS EQUATIONS
C
C     PARAMETERS
C     M1 = NUMBER OF POINTS +1
C          (NQ.GE.M1 AND M1.GE.3 MUST BE HOLD)
C     MM1= MAXIMAL VALUE OF M1
C     NQ = NUMBER OF VARIABLES(COORDINATES)
C          (DIMENSION OF THE Q AND G VECTORS)
C     MNQ= MAXIMAL VALUE OF NQ
C     Q  = VECTORS OF THE VARIABLES
C          STORED COLUMNWISE AS ((Q(I,J),J=1,NQ),J=1,M)
C     G  = VECTORS OF GRADIENTS (FIRST DERIVATIVES)
C          STORED SIMILARLY TO Q
C     H  = INVERSE OF THE HESSIAN (SECOND DERIVATIVES)
C     A  = DIIS MATRIX
C     DQ = VECTOR OF PREDICTED VARIABLES
C     DG = VECTOR OF PREDICTED GRADIENTS AT DQ
C     C  = VECTOR OF DIIS COEFFICIENTS
C     XLAM= LAGRANGIAN MULTIPLIER
C     IER= ERROR CODE
C        =0 NO ERROR
C        =1 THE DIIS MATRIX IS SINGULAR
C           (THE GRADIENTS ARE LINEARLY DEPENDENT)
C
C     METHOD
C     P.PULAY,CHEM.PHYS.LETT.,23,393(1980)
C     P.PULAY, J. COMP. CHEM., 3 (1982) 556-560
C     P.CSASZAR AND P. PULAY, J. MOL. STRUCTURE 114,(1984) 31-34
C
C
      IER=0
      M=M1-1
C
C     CONSTRUCT DIIS MATRIX
C
      DO 121 I=1,NQ
         IK=I*NQ-NQ
         WRITE(IOUT,122) I
         WRITE(IOUT,123) (H(I,J), J=1,NQ)
  121 CONTINUE
  122 FORMAT('HESSIAN ROW #',I2)
  123 FORMAT(8F10.7)
      DO 124 I=1,M
         WRITE(IOUT,125) I
         WRITE(IOUT,123) (G(K,I), K=1,NQ)
  124 CONTINUE
  125 FORMAT('GRADIENT #',I2)
      DO 70 I=1,M
         DO 20 II=1,NQ
            S=0.0D0
            DO 10 K=1,NQ
               IIK=(K-1)*NQ+II
   10       S=S+H(II,K)*G(K,I)
   20    DQ(II)=S
         WRITE(IOUT,126) I
         WRITE(IOUT,123) (DQ(K), K=1,NQ)
  126    FORMAT('DQ #',I2)
         DO 60 J=1,I
            DO 40 II=1,NQ
               S=0.0D0
               DO 30 K=1,NQ
                  IIK=(K-1)*NQ+II
   30          S=S+H(II,K)*G(K,J)
   40       DG(II)=S
         WRITE(IOUT,127) J
         WRITE(IOUT,123) (DG(K), K=1,NQ)
  127    FORMAT('DG #',I2)
            S=0.0D0
            DO 50 K=1,NQ
   50       S=S+DQ(K)*DG(K)
            A(I,J)=S
            A(J,I)=S
   60    CONTINUE
         A(I,M1)=-1.0
         A(M1,I)=-1.0
   70 CONTINUE
      A(M1,M1)=0.0
      WRITE(IOUT,860)
  860 FORMAT(1X,'DIIS MATRIX')
      DO 277 I=1,M1
         WRITE(IOUT,660) (A(I,J), J=1,M1)
  277 CONTINUE
  660 FORMAT(8F10.5)
C
C     SCALE A MATRIX BEFORE INVERSION
C
      DO 80 I=1,M
   80 DQ(I)=1.0/DSQRT(DABS(A(I,I)))
      DO 90 I=1,M1
   90 CONTINUE
      DQ(M1)=1.0
      SMIN=1.E10
      DO 100 I=1,M1
      DO 100 J=I,M1
C
C     DQ(J)=1.0
C
         A(I,J)=A(I,J)*DQ(I)*DQ(J)
         A(J,I)=A(I,J)
         IF (DABS(A(I,J)).LT.SMIN.AND.I.NE.J) SMIN=A(I,J)
  100 CONTINUE
      TOL=DABS(SMIN)*1.E-10
      IF (TOL.EQ.0.0) TOL=1.E-8
      CALL OSINV1(A,M1,DET,TOL,LL,MM)
      DO 110 I=1,M
      DO 110 J=I,M
         A(I,J)=A(I,J)*DQ(I)*DQ(J)
  110 A(J,I)=A(I,J)
      IF (DET.NE.0.0) GO TO 120
      IER=1
      RETURN
  120 CONTINUE
C
C     DIIS COEFFICIENTS AND THE LAGRANGIAN
C
      DO 130 I=1,M
  130 C(I)=-A(I,M1)*DQ(I)
      XLAM=-A(M1,M1)
C
C     PREDICTED VARIABLES AND GRADIENTS
C
      DO 150 I=1,NQ
         SI=0.0
         SJ=0.0
         DO 140 J=1,M
            SI=SI+C(J)*Q(I,J)
  140    SJ=SJ+C(J)*G(I,J)
         DQ(I)=SI
         DG(I)=SJ
  150 CONTINUE
      DO 160 I=1,M1
         A(I,M1)=-C(I)
         A(M1,I)=-C(I)
  160 CONTINUE
      A(M1,M1)=-XLAM
      CALL OSINV1(A,M1,DET,TOL,LL,MM)
      RETURN
C
      END
C**********************************************************************
C     NOTIFICATION OF PROGRAM CHANGE:                                 *
C     BY:     TRACY HAMILTON                                          *
C     DATE:    JULY 18,1988                                           *
C     REASON:  SCALE FORCES CORRECTLY IN DO 20 LOOP                   *
C**********************************************************************
      SUBROUTINE EFC(NUMIT,NQ,F1,QQ,FI,C,MODEBM,QQ1,IFSTRE,GEC)
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  THIS ROUTINE SETS UP ALL THE COMMON BLOCKS NEEDED PRIOR TO CALLING
C  LINK 110.
C
      COMMON/MODOUT/VMODE1(50)
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
      COMMON/ASTRE/STRE(50)
      DIMENSION F1(1),QQ(1),FI(1),C(1),QQ1(1),CORE(1),IFSTRE(1),GEC(1)
      LOGICAL STRE,IFSTRE,dump
      DATA TOANG/0.52917706D0/, HARTRE/4.359813653D0/
      CONV1 = TOANG/HARTRE
      CONV2 = TOANG*CONV1
      DO 5 I=1,NQ
    5 STRE(I) = IFSTRE(I)
C
      NSTEP = NUMIT
      MODE = MODEBM
C
C     NUMBER OF SYMMETRY INTERNAL COORDINATES:
      NVAR = NQ
C
C     VALUES OF SYMMETRY INTERNAL COORDINATES:
      DO 10 I=1,NVAR
      X(I) = QQ(I)
C     CONVERT  ANG --> BOHR
      IF(STRE(I)) X(I) = X(I) / TOANG
   10 CONTINUE
C     WRITE(6,666) (X(I),I=1,NVAR)
C 666 FORMAT('X  ',6F10.7)
C
C     FORCES (CONVERT  MDYNE --> HARTREE/BOHR):
      DO 20 I=1,NVAR
         IF(STRE(I)) THEN
            F(I) = FI(I) * CONV1
         ELSE
            F(I) = FI(I) / HARTRE
         ENDIF
   20 CONTINUE
C     WRITE(6,667) (F(I),I=1,NVAR)
C 667 FORMAT('F  ',6F10.7)
C
C     HESSIAN:
      IJ = 0
      DO 31 I=1,NVAR
      DO 30 J=1,NVAR
      IJ = IJ+1
      HESS(I,J) = C(IJ)
      IF(STRE(I).AND.STRE(J)) THEN
C         MDYNE/ANG --> HARTREE/BOHR**2
          HESS(I,J) = HESS(I,J) * CONV2
      ELSE IF(STRE(I).OR.STRE(J)) THEN
C         MDYNE/RAD --> HARTREE/BOHR/RAD
          HESS(I,J) = HESS(I,J) * CONV1
      ELSE
C         MDYNE*ANG/RAD**2 --> HARTREE/RAD**2
          HESS(I,J) = HESS(I,J) / HARTRE
      ENDIF
   30 CONTINUE
C     WRITE(6,668) (HESS(I,J),J=1,NVAR)
C 668 FORMAT('HESS  ',6F10.7)
   31 CONTINUE
C
      IF(NSTEP.GT.0) THEN
C
C     OLD GRADIENT (NEGATIVE OF OLD FORCES) (CONVERT TO HARTREE/BOHR):
      DO 40 I=1,NVAR
   40 OLDF(I) = -F1(I) * CONV1
C     WRITE(6,669) (OLDF(I),I=1,NVAR)
C 669 FORMAT('OLDF  ',6F10.7)
C
C     SKIP OVER FIRST LINE IN INP4:
CTPH  READ(INP4,1000) DD
C
C     OLD STEP SIZE AND STEP:
CTPH  READ(INP4,1000) DD
CTPH  READ(INP4,1000) (D(I),I=1,NVAR)
      DD = 0.0D0
      DO 45 I=1,NVAR
         D(I) = GEC(I)
         IF(STRE(I)) D(I) = D(I) / TOANG
         DD = DD + D(I)**2
   45 CONTINUE
      DD = DSQRT(DD)
C     WRITE(6,670) (D(I),I=1,NVAR)
C 670 FORMAT('D  ',6F10.7)
C
C     POSSIBLY RECOVER OLD HESSIAN MODE:
      IF(MODE.GT.0) THEN
C         READ(INP3,1010) MODE
C         READ(INP3,1020) (VMODE(I),I=1,NVAR)
      DO 46 I=1,NVAR
         READ(INP2,1020) VMODE(I)
   46 CONTINUE
          IF(MODE.EQ.1) MODE=0
          ENDIF
      ENDIF
C
C
C
      CALL OPTEFC(CORE)
C
C
C
CTPH  REWIND INP4
CTPH  WRITE(INP4,1010) -1,NSTEP
C
C     SAVE STEP SIZE AND STEP:
CTPH  WRITE(INP4,1000) DD
CTPH  WRITE(INP4,1000) (D(I),I=1,NVAR)
C
C     SAVE MODE:
CTPH  REWIND INP3
CTPH  WRITE(INP3,1010) MODE
CTPH  WRITE(INP3,1020) (VMODE(I),I=1,NVAR)
C
C     PUT HESSIAN BACK INTO BMAT FORM:
      MODEBM = MODE
      DO 51 I=1,NVAR
         VMODE1(I) = VMODE(I)
  51  CONTINUE
      IJ = 0
      DO 70 I=1,NVAR
      DO 70 J=1,NVAR
      IJ = IJ+1
      IF(STRE(I).AND.STRE(J)) THEN
C         HARTREE/BOHR**2 --> MDYNE/ANG
          HESS(I,J) = HESS(I,J) / CONV2
      ELSE IF(STRE(I).OR.STRE(J)) THEN
C         HARTREE/BOHR/RAD --> MDYNE/RAD
          HESS(I,J) = HESS(I,J) / CONV1
      ELSE
C         HARTREE/RAD**2 --> MDYNE*ANG/RAD**2
          HESS(I,J) = HESS(I,J) * HARTRE
      ENDIF
   70 C(IJ) = HESS(I,J)
C     WRITE(6,671) (C(I),I=1,NVAR*NVAR)
C 671 FORMAT('C  ',6F10.7)
C
C     COPY DISPLACEMENTS INTO BMAT ARRAY (AND CONVERT BOHR --> ANG):
      DO 80 I=1,NVAR
      QQ1(I) = D(I)
      IF(STRE(I)) QQ1(I) = QQ1(I) * TOANG
   80 CONTINUE
C
      RETURN
C
 1000 FORMAT(F10.6)
 1010 FORMAT(2I5)
 1020 FORMAT(8F10.6)
C
      END
      SUBROUTINE OPTEFC(CORE)
      IMPLICIT REAL*8(A-H,O-Z)
C
C
C  **************************************************************
C  *                                                            *
C  *  DRIVER FOR EIGENVECTOR FOLLOWING TRANSITION STATE SEARCH  *
C  *  BASED ON "ON FINDING TRANSITION STATES" BY CERJAN AND     *
C  *  MILLER (J.CHEM.PHYS. 75 (1981) 2800);   "WALKING ON       *
C  *  POTENTIAL ENERGY SURFACES" BY SIMONS, JORGENSON, TAYLOR   *
C  *  AND OZMENT (J.PHYS.CHEM. 87 (1983) 2745)  AND  "SEARCH    *
C  *  FOR STATIONARY POINTS ON SURFACES" BY BANERJEE, ADAMS,    *
C  *  SIMONS AND SHEPARD (J.PHYS.CHEM. 89 (1985) 52).           *
C  *                                                            *
C  *  ORIGINAL VAX CODE BY JON BAKER          JB MARCH 1985     *
C  *                                                            *
C  **************************************************************
C
C
C  OPTIONS          COMMON/IOP/
C
C  IOP(5)     NATURE OF REQUIRED STATIONARY POINT
C             0    FIND A TS                            (DEFAULT)
C             1    FIND A MINIMUM
C
C  IOP(6)     MAXIMUM NUMBER OF STEPS ALLOWED
C             0    MIN(40,NVAR+20)                      (DEFAULT)
C                  (WHERE NVAR = NUMBER OF VARIABLES)
C             N    N STEPS
C
C  IOP(7)     CONVERGENCE CRITERIA ON RMS GRADIENT
C             0    0.0003                               (DEFAULT)
C             N    0.001/N
C             NOTE: THE OTHER CONVERGENCE CRITERIA ARE
C             MAXIMUM GRADIENT = 1.5 * RMS GRADIENT
C             RMS DISPLACEMENT = 4.0 * RMS GRADIENT
C             MAX DISPLACEMENT = 1.5 * RMS DISPLACEMENT
C
C  IOP(8)     MAXIMUM STEPSIZE ALLOWED DURING OPTIMIZATION
C             0    DMAX = 0.3                           (DEFAULT)
C             N    DMAX = 0.01*N
C
C  IOP(10)    INPUT OF INITIAL SECOND DERIVATIVE MATRIX
C             ALL VALUES MUST BE IN ATOMIC UNITS
C             0    ESTIMATE ENTIRE HESSIAN NUMERICALLY     (TS DEFAULT)
C                  ESTIMATE DIAGONAL ELEMENTS ONLY        (MIN DEFAULT)
C             1    READ IN FULL FRCNST MATRIX (LOWER TRIANGLE)
C                  FORMAT (8F10.6)
C             2    READ IN SELECTED ELEMENTS OF FRCNST
C                  READ I,J,FRCNST(I,J)        2I3, F20.0
C             3    READ FRCNST MATRIX FROM THE CHECKPOINT FILE
C             4    CALCULATE HESSIAN ANALYTICALLY
C             5    READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
C  IOP(11)    HESSIAN RECALCULATION
C             0    UPDATE THE HESSIAN ONLY              (DEFAULT)
C             N    RECALCULATE THE HESSIAN (ANALYTICALLY IF
C                  POSSIBLE, ELSE NUMERICALLY) EVERY N POINTS
C             (OBS!  IF THIS OPTION IS INVOKED, RESTARTS FROM THE
C              CHECKPOINT FILE SHOULD NOT BE ATTEMPTED EXCEPT VIA A
C              NON-STANDARD ROUTE. EXCEPTION: ANALYTICAL DERIVATIVES
C              AT ALL POINTS VIA "CALCALL" CAN BE RESTARTED)
C
C  IOP(13)    TYPE OF HESSIAN UPDATE
C             0    POWELL UPDATE                        (DEFAULT)
C             1    BFGS UPDATE (USED IN CONJUNCTION WITH MIN)
C             2    BFGS UPDATE WITH SAFEGUARDS TO ENSURE RETENTION
C                  OF POSITIVE DEFINITENESS
C
C  IOP(16)    MAXIMUM ALLOWABLE MAGNITUDE OF HESSIAN EIGENVALUES
C             IF THIS MAGNITUDE IS EXCEEDED, THE EIGENVALUE IS REPLACED
C             0    EIGMAX = 25.0                        (DEFAULT)
C             N    EIGMAX = 0.1*N
C
C  IOP(17)    MINIMUM ALLOWABLE MAGNITUDE OF HESSIAN EIGENVALUES
C             SIMILAR TO IOP(16)
C             0    EIGMIN = 0.0001                      (DEFAULT)
C             N    EIGMIN = 1.0/N
C
C  IOP(19)    SEARCH SELECTION
C             0    P-RFO OR RFO STEP ONLY               (DEFAULT)
C             1    P-RFO OR RFO STEP FOR "WRONG" HESSIAN
C                  OTHERWISE NEWTON-RAPHSON
C
C  IOP(21)    EXPERT SWITCH
C             0    NORMAL MODE                          (DEFAULT)
C             1    EXPERT MODE
C                  CERTAIN CUTOFFS TO CONTROL OPTIMIZATION RELAXED
C
C  IOP(33)    PRINT OPTION
C             0    ON                                   (DEFAULT)
C             1    OFF  TURNS OFF EXTRA PRINTING
C             (DEFAULT OF "ON" BY POPULAR REQUEST)
C
C  IOP(34)    DUMP OPTION
C             0    OFF                                  (DEFAULT)
C             1    ON   TURNS ON DEBUG PRINTING
C
C  IOP(35)    RESTART OPTION
C             0    NORMAL OPTIMIZATION                  (DEFAULT)
C             1    FIRST POINT OF A RESTART
C                  RECOVER GEOMETRY ETC.. FROM CHECKPOINT FILE
C
C  IOP(36)    CHECKPOINT OPTION
C             0    CHECKPOINTING AS NORMAL              (DEFAULT)
C             1    SUPPRESS CHECKPOINTING
C
C  IOP(37)    D2E CLEANUP OPTION
C             0    NO SPECIAL ACTION TAKEN              (DEFAULT)
C             1    THIS IS THE LAST POINT AT WHICH ANALYTICAL
C                  DERIVATIVES ARE AVAILABLE; CLEAN UP THE RWF
C
C
C  MODE FOLLOWING:  MODE FOLLOWING IS TURNED ON VIA THE IC ARRAY, WHICH
C  IS INPUT WITH THE Z-MATRIX VARIABLES IN LINK 101. ADDING 4 TO THE IC
C  ENTRY FOR A PARTICULAR VARIABLE WILL CAUSE A TRANSITION STATE SEARCH
C  TO FOLLOW THE HESSIAN MODE WITH THE LARGEST MAGNITUDE COMPONENT FOR
C  THAT VARIABLE. ADDING 10 TO THE IC ENTRY FOR THE KTH VARIABLE WILL
C  FOLLOW THE KTH HESSIAN MODE. ONLY ONE IC ENTRY SHOULD BE MODIFIED IN
C  THIS WAY  I.E. ONLY ONE MODE SHOULD BE FOLLOWED AT A TIME.
C
C
c     REAL*8 CORE(1)
      REAL*8 U(50,50),HESSC(50,50),EIGVAL(50),FX(50),TVEC(50),tvec2(50)
      LOGICAL PRNT,NRFLAG,DUMP,CNVGRD,last
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
      EQUIVALENCE (FX(1),TVEC(1))
C
c     DATA IGRDNT/511/,LGRDNT/1327/, IZSUBS/570/,LZSUBS/175/
c     DATA IOPTEF/575/,LOPTEF/2790/
      DATA ZERO/0.0D0/, ONE/1.0D0/
C
C
C  INITIALIZE THIS LINK
C  THE ILSW BIT WILL BE SET UNLESS THIS IS THE FIRST ENTRY TO
C  LINK 110, IN WHICH CASE WE'LL JUST DO SOME INITIALIZATION
C
c     CALL DRUM
      WRITE(IOUT,1000)
c     CALL ILSW(2,23,IGRD)
c     CALL ILSW(1,23,1)
c     IF(IGRD.EQ.1.OR.IOP(35).GT.0) GO TO 100
C
C  READ IN DATA AND INITIALIZE OPTIMIZATION
C
      IF(IOP(5).EQ.0) WRITE(IOUT,1005)
      IF(IOP(5).NE.0) WRITE(IOUT,1006)
c     WRITE(IOUT,1010)
      CALL INITEF(CORE)
c     CALL EXITEF(0)
c     RETURN
C
C  START LOOP FOR SECOND AND LATER CALLS TO LINK 110
C
C  RESTORE THE CHECKPOINTED INFORMATION IF THIS IS THE FIRST
C  POINT OF A RESTART FROM THE CHECKPOINT FILE
C
c 100 IF(IOP(35).EQ.1) CALL CHKPNT(1)
C
C  RECOVER COMMON BLOCKS FROM RWF
C
c     CALL TREAD(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     CALL TREAD(IGRDNT,ENERGY,LGRDNT,1,LGRDNT,1,0)
c     CALL TREAD(IOPTEF,X,LOPTEF,1,LOPTEF,1,0)
c     IF(NEGREQ.EQ.1) WRITE(IOUT,1005)
c     IF(NEGREQ.EQ.0) WRITE(IOUT,1006)
c     IF(IOP(6).NE.0) MXSTEP=IOP(6)
c     IF(IOP(36).EQ.0) CALL CHKPNT(0)
C
C  CONVERT FORCES TO GRADIENT
C
      CALL DNEGV(F,NVAR)
C
C  CHECK ON STATUS OF HESSIAN
C  THIS IS GIVEN BY THE INTEGER FLAG IHESS
C  IHESS=0    HESSIAN UNAVAILABLE
C             (BEING ESTIMATED NUMERICALLY)
C  IHESS=1    FIRST POINT WITH CONSTRUCTED HESSIAN
C  IHESS=N    NTH POINT WITH HESSIAN
C             (SHOULD BE UPDATED PRIOR TO USE)
C
c     IF(IHESS.LE.0) CALL HESSEF
C
C  IF HESSIAN STILL UNAVAILABLE UPDATE PARAMETER LIST AND EXIT
C
c     IF(IHESS.EQ.0) THEN
c     WRITE(IOUT,1015)
c     WRITE(IOUT,1020) NSTEP,IS
c     CALL EXITEF(0)
c     RETURN
c     ENDIF
C
C  UPDATE THE HESSIAN (UNLESS FIRST POINT)
c  (or unless already updated by BMAT or calculated analytically)
C
c     IF(IHESS.GT.1) CALL UPDATE(EIGVAL,TVEC)
      IF(nstep.gt.0 .and. iop(13).ge.0) CALL UPDATE(EIGVAL,TVEC)
C
C  IF THIS IS THE LAST POINT AT WHICH ANALYTICAL SECOND
C  DERIVATIVES WILL BE AVAILABLE, CLEAN UP THE RWF
C
c     IF(IOP(37).NE.0) CALL CLND2E
C
C  HESSIAN READY FOR USE
C  START OPTIMIZATION PROPER
C
      NSTEP=NSTEP+1
      WRITE(IOUT,1025) NSTEP
c     IHESS=IHESS+1
C
C  DIAGONALIZE HESSIAN
C  FIRST COPY HESS INTO HESSC SINCE HESSIAN IS DESTROYED
C  BY DIAGONALIZATION ROUTINE
C
c     CALL DMCOPY(HESSC,HESS,NVAR)
c     CALL DODIAG(NVAR,50,HESSC,U,EIGVAL,TVEC)
      call cntrct(hessc,hess,nvar)
      call rsp(50,nvar,2500,hessc,eigval,1,u,tvec,tvec2)
C
C  PRINT THE HESSIAN, ITS EIGENVECTORS AND EIGENVALUES IF
C  REQUESTED. VECTORS ARE IN U, EIGENVALUES IN EIGVAL
C
      IF(PRNT) THEN
      IF(DUMP) WRITE(IOUT,1030)
      IF(DUMP) CALL DMPRNT(HESS,NVAR,IOUT)
      WRITE(IOUT,1035)
c     CALL MATPRT(U,50,50,NVAR,NVAR,2,0,XNAME,XNAME,0,EIGVAL,1)
      last = .false.
      nstar = 1
   10 nend = nstar + 5
      if(nend.ge.nvar) then
         last = .true.
         nend = nvar
      endif
      write(iout,1045) (eigval(l),l=nstar,nend)
      write(iout,1045)
      do 997 i=1,nvar
      write(iout,1045) (u(i,l),l=nstar,nend)
  997 continue
      write(iout,1045)
      nstar = nend + 1
      if(.not.last) go to 10
C
      ELSE
C
      WRITE(IOUT,1040)
      WRITE(IOUT,1045) (EIGVAL(L),L=1,NVAR)
      ENDIF
C
C  CHECK FOR MAXIMUM AND MINIMUM ALLOWED MAGNITUDES
C  FOR THE HESSIAN EIGENVALUES
C
      CALL MAGCHK(EIGVAL,NVAR)
C
C  CALCULATE NEG, THE NUMBER OF NEGATIVE EIGENVALUES
C
      CALL FNDNEG(EIGVAL,NEG,NVAR)
C
C  FORM THE FX VECTOR
C  (THE COMPONENT OF F ALONG THE LOCAL EIGENDIRECTIONS U)
C
      DO 20 I=1,NVAR
cets  FX(I)=DVTV(U(1,I),F,NVAR)
      do 20 j=1,nvar
      fx(i)=fx(i)+u(j,i)*f(j)
   20 CONTINUE
C
C  IF WE ARE IN THE "RIGHT" REGION OF THE ENERGY SURFACE
C  I.E. THE HESSIAN HAS THE REQUIRED NUMBER OF NEGATIVE EIGENVALUES
C  AND NRFLAG IS ON, TAKE THE NEWTON-RAPHSON STEP
C
      IF(NRFLAG.AND.NEG.EQ.NEGREQ) THEN
      WRITE(IOUT,1050)
      CALL FORMNR(U,EIGVAL,FX,D,NVAR)
C
      ELSE
C
C  TAKE THE P-RFO STEP FOR A TS SEARCH AND
C  THE SIMPLE RFO STEP FOR A MINIMUM SEARCH
C
      IF(NEG.EQ.NEGREQ.AND.NEGREQ.EQ.1) WRITE(IOUT,1055)
      IF(NEG.EQ.NEGREQ.AND.NEGREQ.EQ.0) WRITE(IOUT,1056)
      IF(NEG.NE.NEGREQ.AND.NEGREQ.EQ.1) WRITE(IOUT,1057)
      IF(NEG.NE.NEGREQ.AND.NEGREQ.EQ.0) WRITE(IOUT,1058)
      CALL FORMD(U,EIGVAL,FX,NVAR)
      ENDIF
C
C  WE NOW HAVE A NEW STEP IN D
C  CHECK THAT THE STEPSIZE DOES NOT EXCEED DMAX
C  IF SO, SCALE
C
      CALL CHECKD(D,DMAX,DD,SKAL,NVAR)
C
C  PREDICT THE CHANGE IN ENERGY
C
      CALL ESTIME(EIGVAL,FX,DD,SKAL,CHNGE,NVAR)
C
C  TEST FOR CONVERGENCE AND PRINT OUT CURRENT PARAMETER VALUES
C
      CALL CONVEF(NEG,CNVGRD,TVEC)
      WRITE(IOUT,1060) CHNGE
C
C  IF CONVERGED THEN EXIT
C
      IF(CNVGRD) THEN
c     CALL EXITEF(1)
      write(iout,1000)
      RETURN
      ENDIF
C
C  FORM THE NEW X VECTOR AND SAVE THE CURRENT GRADIENT
C
c     CALL DVADDV(X,X,D,NVAR)
c     CALL DVCOPY(OLDF,F,NVAR)
C
C  CHECK IF THE HESSIAN IS TO BE RECALCULATED/REESTIMATED
C
c     IF(IHESS.GT.MXHESS) THEN
c     IHESS=0
c     IS=0
c     CALL GET202(ICHAIN,1)
c     CALL EXITEF(ICHAIN)
c     RETURN
c     ENDIF
C
C  AND EXIT
C
c     CALL EXITEF(0)
      write(iout,1000)
C
      RETURN
C
1000  FORMAT(/24('EF-'))
C
1005  FORMAT(//'EIGENVECTOR FOLLOWING TRANSITION STATE SEARCH')
C
1006  FORMAT(//'EIGENVECTOR FOLLOWING MINIMUM SEARCH')
C
1010  FORMAT(' INITIALIZATION PASS')
C
1015  FORMAT(//' NUMERICALLY ESTIMATING SECOND DERIVATIVES')
C
1020  FORMAT(' ITERATION ',I3,' VARIABLE ',I2)
C
1025  FORMAT(//'ITERATION ',I3)
C
1030  FORMAT(//' HESSIAN MATRIX')
C
1035  FORMAT('EIGENVECTORS AND EIGENVALUES'/)
C
1040  FORMAT(//'EIGENVALUES OF THE HESSIAN')
C
c1045  FORMAT(5X,6F12.6)
1045  FORMAT(6F12.6)
C
1050  FORMAT(' HESSIAN HAS REQUIRED LOCAL STRUCTURE'/
     $       ' TAKING NEWTON-RAPHSON STEP')
C
1055  FORMAT(' TS SEARCH. TAKING P-RFO STEP')
C
1056  FORMAT(' MINIMUM SEARCH. TAKING SIMPLE RFO STEP')
C
1057  FORMAT(' HESSIAN DOES NOT HAVE THE DESIRED LOCAL STRUCTURE'/
     $       ' TAKING P-RFO STEP')
C
1058  FORMAT(' HESSIAN DOES NOT HAVE THE DESIRED LOCAL STRUCTURE'/
     $       ' TAKING SIMPLE RFO STEP')
C
1060  FORMAT(' PREDICTED CHANGE IN ENERGY  ',F9.6)
C
      END
      SUBROUTINE CHECKD(D,DMAX,DD,SKAL,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 D(1)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
C
C  GET CURRENT STEPSIZE
C
cets  DD=DVTV(D,D,NVAR)
      do 199 i=1,nvar
      dd=dd+d(i)*d(i)
  199 continue
      DD=DSQRT(DD)
C
      IF(DD.GT.DMAX) THEN
      SKAL=DMAX/DD
      WRITE(IOUT,1000) SKAL
      CALL DVSKAL(D,D,SKAL,NVAR)
      DD=DMAX
      ENDIF
C
      WRITE(IOUT,1010) DD
      RETURN
C
1000  FORMAT(' CALCULATED STEP TOO LARGE. STEP SCALED BY ',F9.6)
C
1010  FORMAT(' STEP TAKEN. STEPSIZE IS ',F9.6)
C
      END
      SUBROUTINE CONVEF(NEG,CNVGRD,TVEC)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TVEC(1)
c     DIMENSION TVEC(1),IRESLT(3)
      character*3 ireslt
      LOGICAL PRNT,NRFLAG,DUMP,CNVGRD,stre
      common/astre/stre(50)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
c     COMMON/PHYCON/TOANG,PHYCON(29)
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVARRD
C
c     DATA IOZMAT/507/,LZMAT/351/
      data toang/0.52917706d0/, todeg/57.296d0/
C
C  PRINT OUT CURRENT X, CURRENT GRADIENTS, DISPLACEMENTS
C  AND NEWX
C
      WRITE(IOUT,1000)
      WRITE(IOUT,1010)
      DO 20 I=1,NVAR
      TVEC(I)=X(I)+D(I)
      if(stre(i)) then
          temp = tvec(i) * toang
      else
          temp = tvec(i) * todeg
      endif
      WRITE(IOUT,1020) I,X(I),F(I),D(I),TVEC(I),temp
   20 CONTINUE
C
C  FIND MAXIMUM AND RMS GRADIENTS AND DISPLACEMENTS
C
      FMAX=DABS(F(1))
      DXMAX=DABS(D(1))
      IF(NVAR.GT.1) THEN
      DO 30 I=2,NVAR
      IF(DABS(F(I)).GT.FMAX) FMAX=DABS(F(I))
      IF(DABS(D(I)).GT.DXMAX) DXMAX=DABS(D(I))
   30 CONTINUE
      ENDIF
C
cets  FSQ=DVTV(F,F,NVAR)
      do 31 i=1,nvar
      fsq=fsq+f(i)*f(i)
   31 continue
      FRMS=DSQRT(FSQ/NVAR)
      DXRMS=DSQRT(DD*DD/NVAR)
C
C  CHECK CONVERGENCE
C
      WRITE(IOUT,1030)
      CALL CONVGD(FMAX,CNVFMX,IRESLT)
      WRITE(IOUT,1032) FMAX,CNVFMX,IRESLT
      CALL CONVGD(FRMS,CONVF,IRESLT)
      WRITE(IOUT,1034) FRMS,CONVF,IRESLT
      CALL CONVGD(DXMAX,CNVXMX,IRESLT)
      WRITE(IOUT,1036) DXMAX,CNVXMX,IRESLT
      CALL CONVGD(DXRMS,CONVX,IRESLT)
      WRITE(IOUT,1038) DXRMS,CONVX,IRESLT
C
C  SET CONVERGENCE FLAG AND TEST FOR MAXIMUM ITERATIONS
C  EXCEEDED
C
      IF(FMAX.GT.CNVFMX.OR.FRMS.GT.CONVF.OR.
     $   DXMAX.GT.CNVXMX.OR.DXRMS.GT.CONVX) THEN
      CNVGRD=.FALSE.
c     IF(NSTEP.GE.MXSTEP) THEN
c     WRITE(IOUT,1040)
c     CALL ILSW(1,25,0)
c     CALL ILSW(1,27,1)
c     CNVGRD=.TRUE.
c     ENDIF
      RETURN
      ENDIF
C
C  CONVERGED. PRINT FINAL SOLUTION
C
      CNVGRD=.TRUE.
      WRITE(IOUT,1050)
C
C  TEST IF THE HESSIAN HAS THE REQUIRED NUMBER OF
C  NEGATIVE EIGENVALUES
C
      IF(NEG.NE.NEGREQ) WRITE(IOUT,1060)
C
C  PRINT FINAL PARAMETERS
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
c     DO 40 I=1,NVAR
c     IC(I)=99
c  40 CONTINUE
C
c     CALL PRMTBL(1,XNAME,X,IC,F,NVAR,LBL,NZ,TOANG)
C
      RETURN
C
1000  FORMAT(//'CURRENT PARAMETER VALUES (INTERNAL COORDINATES)',
     $       17x,'Angstrom')
C
1010  FORMAT(3X,'I',8X,'X',9X,'GRADIENT',4X,
     $       'DISPLACEMENT',7X,'NEWX',5x,'or degrees')
C
1020  FORMAT(I4,4(2X,F10.6,2X),3x,f9.4)
C
1030  FORMAT(//8X,4HITEM,15X,5HVALUE,5X,9HTHRESHOLD,2X,
     $       10HCONVERGED?)
C
1032  FORMAT(/14H MAXIMUM FORCE,12X,F8.6,5X,F8.6,5X,a3)
C
1034  FORMAT(14H RMS     FORCE,12X,F8.6,5X,F8.6,5X,a3)
C
1036  FORMAT(21H MAXIMUM DISPLACEMENT,5X,F8.6,5X,F8.6,5X,a3)
C
1038  FORMAT(21H RMS     DISPLACEMENT,5X,F8.6,5X,F8.6,5X,a3)
C
1040  FORMAT(//' ***********************************'/
     $         ' **     OPTIMIZATION STOPPED      **'/
     $         ' **  MAXIMUM ITERATIONS EXCEEDED  **'/
     $         ' ***********************************'//)
C
1050  FORMAT(//' *************************************************'/
     $         ' **  CONVERGENCE CRITERIA APPARENTLY SATISFIED  **'/
     $         ' *************************************************'//)
C
1060  FORMAT(//'|| WARNING: THE HESSIAN HAS THE WRONG NUMBER OF',
     $       ' NEGATIVE EIGENVALUES ||'/)
C
      END
c     SUBROUTINE ESTM
c     IMPLICIT REAL*8(A-H,O-Z)
c     LOGICAL PRNT,NRFLAG,DUMP
C
C  MAKES GUESSES AT THE DIAGONAL SECOND DERIVATIVES
C  THIS ROUTINE IS A MODIFIED VERSION OF THE GAUSSIAN 82 ROUTINE
C  OF THE SAME NAME USED IN LINK 103.
C
C  BENDING FORCE CONSTANTS ARE 1.35 FOR MINIMAL BASIS, ELSE 1.0.
C  FOR STRETCHES THE VALUE CHOSEN DEPENDS UPON THE INTERNUCLEAR
C  DISTANCE AND THE ROWS OF THE PERIODIC TABLE IN WHICH THE TWO
C  AFFECTED ATOMS RESIDE AS WELL AS THE BASIS.
C  DUMMIES ARE CONSIDERED THE SAME AS HYDROGEN.
C
c     DIMENSION AA(3,3),IROW(18),ISAVE(50),XANG(50)
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MAXSTP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVAR
C
c     DATA TOANG/0.52917706/, HARTRE/4.359814D0/
c     DATA A1,A2/5.38D0,4.0D0/, B1,B2/1.35D0,1.0D0/
c     DATA IROW/2*1,8*2,8*3/
c     DATA AA/-0.129D0,0.186D0,0.349D0,
c    $         0.186D0,0.574D0,0.805D0,
c    $         0.349D0,0.805D0,1.094D0/
c     DATA IOZMAT/507/,LZMAT/351/
C
C
C  RECOVER COMMON/ZMAT/
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
C
C  ALLOW FOR CHANGES IN HESS WITH BASIS
C
c     CALL ILSW(2,3,IA)
c     AAA=A1
c     IF(IA.NE.0) AAA=A2
c     BBB=B1
c     IF(IA.NE.0) BBB=B2
c     IF(NZ.LT.2) GO TO 50
C
C  CONVERT BOND LENGTHS TO ANGSTROMS
C
c     DO 15 I=1,NVAR
c     XANG(I)=X(I)
c     IF(NREP(I,LBL,NZ).NE.0) XANG(I)=XANG(I)*TOANG
c  15 CONTINUE
C
C  GUESS DIAGONAL 2ND DERIVATIVES IN MDYNE UNITS
C
c     DO 20 I=2,NZ
c     IVAR=IABS(LBL(I))
c     IF(IVAR.EQ.0) GO TO 20
c     IATNO=IANZ(I)
c     IA=IROW(IATNO)
c     IF(IATNO.LT.1.OR.IATNO.GT.18) IA=1
c     JATOM=IZ(I,1)
c     JATNO=IANZ(JATOM)
c     IB=IROW(JATNO)
c     IF(JATNO.LT.1.OR.JATNO.GT.18) IB=1
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR) = HESS(IVAR,IVAR)
c    $                       + AAA/( (XANG(IVAR)-AA(IA,IB))**3 )
c  20 CONTINUE
c     IF(NZ.LT.3) GO TO 50
C
c     DO 30 I=3,NZ
c     IVAR=IABS(LALPHA(I))
c     IF(IVAR.EQ.0) GO TO 30
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)+BBB
c  30 CONTINUE
c     IF(NZ.LT.4) GO TO 50
C
c     DO 40 I=4,NZ
c     IVAR=IABS(LBETA(I))
c     IF(IVAR.EQ.0) GO TO 40
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)+BBB
c  40 CONTINUE
C
c  50 CONTINUE
C
C  CONVERT TO ATOMIC UNITS
C
c     CONSTR=TOANG**2/HARTRE
c     CONBND=1.0D0/HARTRE
c     CALL ICLEAR(50,ISAVE)
c     NSAVE=0
c     DO 60 I=2,NZ
c     IVAR=IABS(LBL(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 60
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONSTR
c  60 CONTINUE
C
c     CALL ICLEAR(NSAVE,ISAVE)
c     NSAVE=0
c     DO 70 I=3,NZ
c     IVAR=IABS(LALPHA(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 70
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONBND
c  70 CONTINUE
C
c     DO 80 I=4,NZ
c     IVAR=IABS(LBETA(I))
c     IF(IVAR.EQ.0.OR.NREP(IVAR,ISAVE,NSAVE).NE.0) GO TO 80
c     NSAVE=NSAVE+1
c     ISAVE(NSAVE)=IVAR
c     IF(IC(IVAR).EQ.0) HESS(IVAR,IVAR)=HESS(IVAR,IVAR)*CONBND
c  80 CONTINUE
C
c     RETURN
c     END
      SUBROUTINE ESTIME(EIGVAL,FX,DD,SKAL,CHNGE,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1),FX(1)
      REAL*8 LAMDA,LAMDA0
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/LAMBDA/LAMDA,LAMDA0,IT
C
C  ESTIMATE THE LIKELY ENERGY CHANGE DUE TO THE STEP D
C
      CHNGE=0.0D0
      DO 10 I=1,NVAR
      DUMMY=LAMDA
      IF(I.EQ.IT) DUMMY=LAMDA0
      TEMP=FX(I)*FX(I)*(DUMMY-EIGVAL(I)/2)
      TEMP=TEMP/( (DUMMY-EIGVAL(I))*(DUMMY-EIGVAL(I)) )
      CHNGE=CHNGE+TEMP
   10 CONTINUE
C
      CHNGE=CHNGE/(1+DD*DD)
C
C  SCALE THE ENERGY, IN CASE THE STEP WAS SCALED
C  (A SCALED ENERGY CHANGE IS LIKELY TO BE AN OVERESTIMATE)
C
      CHNGE=CHNGE*SKAL
C
      RETURN
      END
c     SUBROUTINE EXITEF(ICHAIN)
c     IMPLICIT REAL*8(A-H,O-Z)
c     REAL*8 GEN(47)
c     LOGICAL PRNT,NRFLAG,DUMP
c     COMMON/IO/IN,IOUT
c     COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
C
c     DATA IRWGEN/501/,LRWGEN/47/,  IGRDNT/511/,LGRDNT/1327/
c     DATA IZSUBS/570/,LZSUBS/175/, IOPTEF/575/,LOPTEF/2790/
C
C  LET SYNOPSIS ROUTINES KNOW IF JOB IS TERMINATING
C  (BY SETTING APPROPIATE FLAG IN GEN)
C
c     IF(ICHAIN.EQ.1) THEN
c     CALL FILEIO(2,-IRWGEN,LRWGEN,GEN,0)
c     GEN(3)=2.0D0
c     CALL FILEIO(1,-IRWGEN,LRWGEN,GEN,0)
C
C  COPY HESS INTO FRCNST AT SAME TIME CONTRACTING FULL MATRIX
C  INTO LOWER TRIANGLE
C  (THIS IS SO SYNOPSIS HAS A COPY OF THE FINAL DERIVATIVES)
C
c     CALL CNTRCT(FRCNST,HESS,NVAR)
c     ENDIF
C
C  UPDATE THE RW FILES AND EXIT
C
c     CALL DVCOPY(VALUES,X,NVAR)
c     CALL TWRITE(IGRDNT,ENERGY,LGRDNT,1,LGRDNT,1,0)
c     CALL TWRITE(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     CALL TWRITE(IOPTEF,X,LOPTEF,1,LOPTEF,1,0)
C
c     WRITE(IOUT,1000)
c     CALL CHAINX(ICHAIN)
c     RETURN
C
c1000  FORMAT(/' ',24('EF-'))
C
c     END
      SUBROUTINE FORMD(U,EIGVAL,FX,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50),EIGVAL(1),FX(1)
      REAL*8 LAMDA,LAMDA0,LAMDA1,LAMDA2
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
      COMMON/LAMBDA/LAMDA,LAMDA0,IT
C
      DATA ZERO/0.0D0/, HALF/0.5D0/, TOLL/1.0D-8/
      DATA STEP/0.05D0/, BIG/1.0D+3/, MAXIT/999/
C
C
C  TS SEARCH    FORMS A STEP BY P-RFO THAT TRIES TO MAXIMIZE
C               ALONG THE DIRECTION OF A CHOSEN HESSIAN MODE
C               AND MINIMIZE ALONG ALL OTHER MODES
C  MIN SEARCH   FORMS A STEP BY SIMPLE RFO THAT ATTEMPTS TO
C               MINIMIZE ALONG ALL HESSIAN MODES
C
C
      NUMIT=0
      IT=0
      IF(NEGREQ.EQ.0) GO TO 10
C
C  (A) MAXIMIZATION ALONG ONE OF THE HESSIAN MODES
C
      IF(MODE.NE.0) THEN
      CALL OVRLAP(U,NMODE,NVAR)
C
C  ON RETURN FROM OVRLAP, NMODE IS THE MODE ALONG WHICH
C  THE ENERGY IS TO BE MAXIMIZED
C
      IF(NMODE.NE.MODE) WRITE(IOUT,1000) MODE,NMODE
      MODE=NMODE
      IF(PRNT) WRITE(IOUT,1010) MODE
      IT=MODE
C
C  IF THE MODE BEING FOLLOWED IS NOW THE LOWEST MODE,
C  THEN SWITCH OFF MODE FOLLOWING
C
      IF(MODE.EQ.1) THEN
      MODE=0
      WRITE(IOUT,1015)
      ENDIF
C
      ELSE
C
      IF(PRNT) WRITE(IOUT,1020)
      IT=1
      ENDIF
C
      LAMDA0=EIGVAL(IT)+DSQRT(EIGVAL(IT)**2 +4.0D0*FX(IT)**2)
      LAMDA0=HALF*LAMDA0
      IF(PRNT) WRITE(IOUT,1030) LAMDA0
      IF(NVAR.EQ.1) GO TO 40
C
C  (B) MINIMIZATION ALONG ALL OTHER MODES
C
   10 CONTINUE
      JT=1+IT
      IF(JT.GT.2) JT=1
C
      IF(PRNT.AND.NEGREQ.EQ.1) WRITE(IOUT,1040)
      IF(PRNT.AND.NEGREQ.EQ.0) WRITE(IOUT,1050)
C
C  SOLVE ITERATIVELY FOR LAMDA
C  INITIAL GUESS FOR LAMDA IS ZERO EXCEPT NOTE THAT
C  LAMDA SHOULD BE LESS THAH EIGVAL(JT)
C
      LAMDA=ZERO
      IF(EIGVAL(JT).LT.ZERO) THEN
      LAMDA=EIGVAL(JT)-STEP
      LAMDA1=EIGVAL(JT)
      LAMDA2=-BIG
      ENDIF
C
   20 NUMIT=NUMIT+1
      TEMP=ZERO
      DO 25 I=1,NVAR
      IF(I.EQ.IT) GO TO 25
      TEMP=TEMP+(FX(I)*FX(I))/(LAMDA-EIGVAL(I))
   25 CONTINUE
      IF(DUMP) WRITE(IOUT,1111) LAMDA,TEMP
C
C  CHECK FOR CONVERGENCE OF LAMDA
C
      IF(DABS(LAMDA-TEMP).LT.TOLL) GO TO 30
C
C  CHECK FOR MAXIMUM ITERATIONS EXCEEDED
C
      IF(NUMIT.GT.MAXIT) GO TO 91
C
C  (A) SIMPLE ITERATIVE SCHEME
C      (USED IF EIGVAL(JT) > ZERO)
C
      IF(EIGVAL(JT).GT.ZERO) THEN
      LAMDA=TEMP
      GO TO 20
C
      ELSE
C
C  (B) CAUTIOUS BRACKETING SCHEME
C      (USED IF EIGVAL(JT) < ZERO)
C
      IF(TEMP.LT.LAMDA) LAMDA1=LAMDA
      IF(TEMP.GT.LAMDA) LAMDA2=LAMDA
      IF(LAMDA2.GT.-BIG) LAMDA=HALF*(LAMDA1+LAMDA2)
      IF(LAMDA2.EQ.-BIG) LAMDA=LAMDA-STEP
      GO TO 20
      ENDIF
C
C  AT THIS POINT WE HAVE AN ACCEPTABLE VALUE FOR LAMDA
C  MAKE FINAL CHECK ON ACCEPTABILITY
C
   30 IF(PRNT) WRITE(IOUT,1030) LAMDA
      IF(LAMDA.GT.EIGVAL(JT)) GO TO 90
      IF(EIGVAL(JT).GT.ZERO.AND.LAMDA.GT.ZERO) GO TO 90
C
C  CALCULATE THE STEP
C
   40 CALL ACLEAR(NVAR,D)
      DO 50 I=1,NVAR
      TEMP=FX(I)/(LAMDA-EIGVAL(I))
      IF(I.EQ.IT) TEMP=FX(I)/(LAMDA0-EIGVAL(I))
      DO 60 J=1,NVAR
      D(J)=D(J)+TEMP*U(J,I)
   60 CONTINUE
   50 CONTINUE
C
      RETURN
C
C  ...........................................................
C    ERROR SECTION
C
   90 CONTINUE
      WRITE(IOUT,1060)
c     CALL LNK1E
      stop
   91 CONTINUE
      WRITE(IOUT,1070)
c     CALL LNK1E
      stop
C
1000  FORMAT(' WARNING!! MODE SWITCHING. WAS FOLLOWING MODE ',I3,
     $       ' NOW FOLLOWING MODE ',I3)
C
1010  FORMAT(' SEARCHING FOR LAMDA THAT MAXIMIZES ALONG MODE ',I3)
C
1015  FORMAT(' MODE FOLLOWING SWITCHED OFF')
C
1020  FORMAT(' SEARCHING FOR LAMDA THAT MAXIMIZES ALONG THE',
     $       ' LOWEST MODE')
C
1030  FORMAT(' VALUE TAKEN    LAMDA= ',F12.8)
C
1040  FORMAT(' SEARCHING FOR LAMDA THAT MINIMIZES ALONG ALL',
     $       ' OTHER MODES')
C
1050  FORMAT(' SEARCHING FOR LAMDA THAT MINIMIZES ALONG ALL MODES')
C
1060  FORMAT(//' *****************************************'/
     $         ' ** ERROR IN DETERMINING LAMDA IN FORMD **'/
     $         ' *****************************************'//)
C
1070  FORMAT(//' ****************************************'/
     $         ' ** UNABLE TO DETERMINE LAMDA IN FORMD **'/
     $         ' ****************************************'//)
C
1111  FORMAT(' IN ITERATIVE CYCLE:  LAMDA= ',F12.8,' TEMP= ',F12.8)
C
      END
      SUBROUTINE FORMNR(U,EIGVAL,FX,D,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50),EIGVAL(1),FX(1),D(1)
C
C  TAKE THE NEWTON-RAPHSON STEP
C  (I.E. SET LAMDA TO ZERO)
C
      CALL ACLEAR(NVAR,D)
      DO 10 I=1,NVAR
      TEMP=-FX(I)/EIGVAL(I)
      DO 20 J=1,NVAR
      D(J)=D(J)+TEMP*U(J,I)
   20 CONTINUE
   10 CONTINUE
C
      RETURN
      END
c     SUBROUTINE GET202(ICHAIN,N)
c     IMPLICIT INTEGER(A-Z)
c     COMMON/TMPRTE/NCHAIN,LL,NLINK,PAD,LNK(200)
c     COMMON/IO/IN,IOUT
c     DATA IRWLNK/999/, LRWLNK/102/
C
C
C  THIS ROUTINE DETERMINES THE CORRECT VALUE FOR ICHAIN
C  IN ORDER FOR CHAINX TO RETURN TO THE NTH OCCURANCE
C  OF LINK 202 IN THE ROUTE
C  GET202 IS USED IN LINKS 104, 109, 110 AND 111.
C  THE ARGUMENT N TAKES THE FOLLOWING VALUES:
C    L104   N=1
C    L109   N=1 OR 2
C    L110   N=1
C    L111   N=1, 2 OR 3
C  IN LINKS 104/110 THIS ENSURES THAT ANALYTICAL SECOND
C  DERIVATIVES ARE USED WHEN RESETTING THE HESSIAN;
C  IN LINKS 109/111 N CONTROLS WHETHER GRADIENTS ARE
C  CALCULATED OR SKIPPED FOR THE CURRENT POINT.
C  N=3 IN L111 IS A FORWARD JUMP LEADING TO JOB TERMINATION
C
C
C  FIRST READ IN "LNK" WHICH CONTAINS THE ROUTE
C  NLINK IS THE CURRENT POSITION IN "LNK"
C
c     CALL TREAD(IRWLNK,NCHAIN,LRWLNK,1,LRWLNK,1,0)
C
C  GO TO THE BEGINNING OF THE ROUTE AND FIND THE NTH
C  OCCURANCE OF LINK 202
C
c     FOUND=0
c     DO 5 I=1,200
c     IF(MOD(LNK(I),10000).EQ.202) FOUND=FOUND+1
c     IF(FOUND.EQ.N) GO TO 10
c   5 CONTINUE
C
c     WRITE(IOUT,1000)
c1000  FORMAT(//' ***********************************'/
c    $         ' **  ERROR IN SUBROUTINE GET202   **'/
c    $         ' ** LINK 202 IS NOT IN THE ROUTE! **'/
c    $         ' ***********************************'//)
C
c     CALL LNK1E
c  10 CONTINUE
C
C  CALCULATE THE NEW VALUE OF ICHAIN
C
c     ICHAIN=I-NLINK-100
c     IF(N.EQ.3) ICHAIN=ICHAIN+200
C
c     RETURN
c     END
c     SUBROUTINE HESSEF
c     IMPLICIT REAL*8(A-H,O-Z)
c     LOGICAL PRNT,NRFLAG,DUMP
C
C
C  ..............................................
C
C  HESSIAN INITIALIZATION ROUTINE
C  (PUT SECOND DERIVATIVES INTO HESS)
C
C  ..............................................
C
C
C  THE HESSIAN CAN BE CALCULATED ANALYTICALLY OR ESTIMATED
C  NUMERICALLY. IT CAN ALSO BE READ IN OR ONLY PARTLY
C  ESTIMATED. THE FLAG THAT CONTROLS THIS IS IOP(10)
C
C    0   FOR A TS SEARCH ESTIMATE PART OR ALL OF THE HESSIAN
C        NUMERICALLY  (DEFAULT ALL)
C        FOR A MIN SEARCH ESTIMATE THE DIAGONAL ELEMENTS ONLY
C    1   READ IN FULL HESSIAN (LOWER TRIANGLE)
C    2   READ IN SELECTED ELEMENTS OF THE HESSIAN MATRIX
C        (REMAINDER SET TO ZERO)
C    3   READ HESSIAN FROM THE CHECKPOINT FILE
C    4   CALCULATE HESSIAN ANALYTICALLY
C    5   READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
C
C  NUMERICAL
C
C  FOR NUMERICAL ESTIMATION OF THE HESSIAN, HESSEF WILL BE
C  ENTERED NVAR TIMES (WHERE NVAR IS THE NUMBER OF PARAMETERS
C  TO BE OPTIMIZED); EACH ENTRY WILL ESTIMATE DERIVATIVES FOR
C  ONE OF THE PARAMETERS I.E. FOR ONE COLUMN OF THE HESSIAN
C  MATRIX. NOTE THAT THE PARAMETERS ARE STEPPED BY AN AMOUNT
C  DELTA IN ONE DIRECTION ONLY. AFTER NVAR ENTRIES THE ENTIRE
C  HESSIAN WILL HAVE BEEN ESTIMATED; IT IS THEN SYMMETRIZED
C  AND THEREAFTER WILL BE UPDATED AT EACH CYCLE.
C
C  ON THE INITIALIZATION STEP IT IS POSSIBLE TO REQUEST ONLY A
C  PARTIAL ESTIMATION OF THE HESSIAN  I.E. ONLY CERTAIN COLUMNS
C  WILL BE ESTIMATED. THIS IS CONTROLLED BY THE IC ARRAY. IT IS
C  ALSO POSSIBLE TO READ IN SPECIFIC DIAGONAL ELEMENTS. ANY OFF
C  DIAGONAL ELEMENTS NOT CALCULATED OR READ IN ARE SET TO ZERO;
C  ANY DIAGONAL ELEMENTS NOT CALCULATED OR READ IN ARE ESTIMATED
C  VIA THE ROUTINE ESTM.
C
C
C  ANALYTICAL
C
C  IF ANALYTICAL DERIVATIVES ARE AVAILABLE, THEN HESSEF WILL
C  BE ENTERED ONCE ONLY. DERIVATIVES WILL BE COPIED FROM THE
C  FRCNST ARRAY IN COMMON/GRDNT/ INTO HESS - THUS THE FULL
C  HESSIAN IS AVAILABLE IMMEDIATELY.
C
C
C  REESTIMATION
C
C  REESTIMATION OF THE HESSIAN CAN OCCUR PERIODICALLY THROUGHOUT
C  THE COURSE OF THE OPTIMIZATION IF REQUESTED. THIS IS CONTROLLED
C  BY IOP(11). AFTER EVERY IOP(11) STEPS, THE ENTIRE HESSIAN IS
C  RECALCULATED (EITHER NUMERICALLY OR ANALYTICALLY).
C
C
c     COMMON/IO/IN,IOUT
c     COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
c     COMMON/OPTEF/X(50),XNAME(50),OLDF(50),OLDX(50),HESS(50,50),
c    $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
c    $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
c    $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
c     DATA DELTA/0.005D0/
C
C  THIS ROUTINE WILL ONLY BE ENTERED IF IHESS IS ZERO
C  I.E. THE HESSIAN IS NOT CURRENTLY AVAILABLE
C
C  CHECK IF ANALYTICAL DERIVATIVES ARE AVAILABLE
C
c     IF(IGETFC.EQ.4) THEN
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     IHESS=IHESS+1
c     WRITE(IOUT,1000)
c     RETURN
c     ENDIF
C
C  ESTIMATE CERTAIN COLUMNS OF THE HESSIAN NUMERICALLY
C  STORE CURRENT ENERGY, POSITION AND GRADIENTS
C  ESTIMATE ANY DIAGONAL ELEMENTS WHICH ARE NOT GOING
C  TO BE ESTIMATED NUMERICALLY BY CALLING ESTM
C
c     IF(IS.EQ.0) THEN
c     CALL ESTM
c     ES=ENERGY
c     CALL DVCOPY(OLDX,X,NVAR)
c     CALL DVCOPY(OLDF,F,NVAR)
c     ENDIF
C
C  ESTIMATION OF SECOND DERIVATIVES
C  UPDATE VARIABLES AND STEPLENGTH
C
c     IF(IS.GT.0) THEN
c     X(IS)=OLDX(IS)
c     DO 9 I=1,NVAR
c     HESS(IS,I)=(F(I)-OLDF(I))/DELTA
c   9 CONTINUE
c     ENDIF
C
C  NEXT POINT
C
c  10 IS=IS+1
c     IF(IS.LE.NVAR) THEN
c     IF(NSTEP.EQ.0.AND.IC(IS).NE.3) GO TO 10
c     X(IS)=OLDX(IS)+DELTA
c     RETURN
c     ENDIF
C
C  ESTIMATION COMPLETE
C  SYMMETRIZE THE NUMERICAL HESSIAN
C
c     CALL DMSYMM(HESS,NVAR)
c     ENERGY=ES
c     CALL DVCOPY(F,OLDF,NVAR)
c     IHESS=1
c     WRITE(IOUT,2000)
c     RETURN
C
c1000  FORMAT(' ANALYTICAL SECOND DERIVATIVES USED')
C
c2000  FORMAT(' HESSIAN INITIALIZED')
C
c     END
      SUBROUTINE INITEF(CORE)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 CORE(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IOP/IOP(50)
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
c     COMMON/PHYCON/TOANG,PHYCON(29)
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
c     COMMON/ZSUBST/ANAMES(50),VALUES(50),INTVEC(50),FPVEC(50)
c     COMMON/ZMAT/IANZ(50),IZ(50,4),BL(50),ALPHA(50),BETA(50),
c    $            LBL(50),LALPHA(50),LBETA(50),NZ,NVARRD
C
c     DATA IOZMAT/507/,LZMAT/351/, IZSUBS/570/,LZSUBS/175/
      DATA DELTA/0.005D0/, ZERO/0.0D0/
C
C
C  INITIALIZATION OF LINK 110 FOR GEOMETRY OPTIMIZATION
C
C  READ IN ZMAT AND ZSUBS AND CHECK FOR VALID NVARRD
C
c     CALL TREAD(IOZMAT,IANZ,LZMAT,1,LZMAT,1,0)
c     CALL TREAD(IZSUBS,ANAMES,LZSUBS,1,LZSUBS,1,0)
c     IF(NVARRD.LT.1.OR.NVARRD.GT.50) THEN
c     WRITE(IOUT,1000) NVARRD
c     CALL LNK1E
c     ENDIF
C
C  MOVE RELEVANT DATA READ BY LINK 101 TO COMMON OPTEF
C
c     NVAR=NVARRD
c     NVTT=(NVAR*(NVAR+1))/2
C
c     CALL CBLANK(50*INTPWP(0),XNAME)
c     NC=0
c     JC=0
c     DO 9 I=1,NVAR
c     CALL GETB(2,ITMP,LEN,ANAMES,NC)
c     CALL PUTB(ITMP,LEN,XNAME,JC)
c     CALL PUTDEL(2,XNAME,JC)
c     X(I)=VALUES(I)
c     IC(I)=INTVEC(I)
c   9 CONTINUE
C
C  CHECK THE IC ARRAY
C  THE IC ARRAY IS READ IN WITH THE VARIABLES IN LINK 101
C  IT CAN CONTROL THE SETTING UP OF THE INITIAL HESSIAN (SEE BELOW)
C  AND ALSO DETERMINE IF HESSIAN MODE FOLLOWING IS SWITCHED ON.
C
c     MODE=0
c     DO 8 I=1,NVAR
c     IF(IC(I).GT.9) THEN
c     IC(I)=IC(I)-10
c     MODE=I+NVAR
c     ENDIF
c     IF(IC(I).GT.3) THEN
c     IC(I)=IC(I)-4
c     MODE=I
c     ENDIF
c     IF(IC(I).LT.0.OR.IC(I).GT.3) THEN
c     WRITE(IOUT,1005) I
c     CALL LNK1E
c     ENDIF
c   8 CONTINUE
C
C  ZERO OUT THE HESSIAN
C
c     CALL ACLEAR(2500,HESS)
C
C  SEE HOW TO OBTAIN INITIAL HESSIAN
C  THIS IS CONTROLLED BY IOP(10)
C    0    ESTIMATE HESSIAN NUMERICALLY OR VIA ESTM (DEFAULT)
C    1    READ IN FULL FRCNST MATRIX
C    2    READ IN SELECTED ELEMENTS OF FRCNST
C    3    READ FRCNST MATRIX FROM CHECKPOINT FILE
C    4    CALCULATE HESSIAN ANALYTICALLY
C    5    READ CARTESIAN FORCE CONSTANTS FROM CHECKPOINT FILE
C
c     IHOP=IOP(10)
c     IF(IOP(10).EQ.0) IHOP=6
c     IF(IHOP.GT.6.OR.IHOP.LE.0) THEN
c     WRITE(IOUT,1010) IHOP
c     CALL LNK1E
c     ENDIF
c     GO TO (110,120,130,140,130,150), IHOP
C
c 110 READ(IN,500) (FRCNST(I),I=1,NVTT)
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     GO TO 200
C
c 120 READ(IN,510) I,J,FFIN
c     IF(I.EQ.0) THEN
c     CALL CNTRCT(FRCNST,HESS,NVAR)
c     GO TO 200
c     ENDIF
c     HESS(I,J)=FFIN
c     HESS(J,I)=FFIN
c     GO TO 120
C
c 130 CALL READFC(IHOP,IOP(33),XNAME,CORE)
c     CALL EXPAND(HESS,FRCNST,NVAR)
c     GO TO 200
C
c 140 DO 7 I=1,NVAR
c     IC(I)=-1
c     IDX=(I*(I+1))/2
c     FRCNST(IDX)=ZERO
c   7 CONTINUE
c     IGETFC=4
c     GO TO 200
C
c 150 CONTINUE
C
C  NUMERICAL ESTIMATION OF PART OR ALL OF THE HESSIAN
C  FIRST CHECK THE IC ARRAY
C  IF ALL OF THE ENTRIES ARE ZERO THEN
C   (A)  FOR A TS    CALCULATE THE ENTIRE HESSIAN NUMERICALLY
C   (B)  FOR A MIN   ESTIMATE THE DIAGONAL ELEMENTS ONLY
C  NOTE THAT FOR A TS, IF ONE OR MORE OF THE IC ENTRIES ARE NON-ZERO,
C  THEN HESSIAN ESTIMATION IS CONTROLLED ENTIRELY BY THE IC ARRAY
C
c     IDX=0
c     DO 6 I=1,NVAR
c     IF(IC(I).GT.0) IDX=IDX+1
c   6 CONTINUE
c     IF(IOP(5).EQ.0.AND.IDX.EQ.0) THEN
c     DO 5 I=1,NVAR
c     IC(I)=3
c   5 CONTINUE
c     ENDIF
C
c     DO 4 I=1,NVAR
c     IDX=(I*(I+1))/2
C
C  DELTA IS THE STEPLENGTH FOR NUMERICAL ESTIMATION OF THE
C  HESSIAN
C
c     IF(IC(I).EQ.3) FRCNST(IDX)=DELTA
c     IF(IC(I).EQ.1) FRCNST(IDX)=FPVEC(I)
c     HESS(I,I)=FRCNST(IDX)
c   4 CONTINUE
C
C  PRINT THE INITIAL SECOND DERIVATIVE TABLE
C
c 200 IF(IOP(10).NE.0.AND.IOP(10).NE.4) THEN
c     DO 3 I=1,NVAR
c     IC(I)=1
c   3 CONTINUE
c     ENDIF
c     CALL PRMTBL(0,XNAME,X,IC,FRCNST,NVAR,LBL,NZ,TOANG)
C
C
C  SET OPTIMIZATION CONTROL PARAMETERS
C
      NEGREQ=1
c     NSTEP=0
      MXSTEP=MIN0(NVAR+20,40)
c     IHESS=1
c     MXHESS=999999
      EIGMAX=25.0D0
      EIGMIN=0.0001D0
c     IS=0
      IUPDAT=0
      NRFLAG= IOP(19).NE.0
      PRNT = IOP(33).EQ.0
      DUMP = IOP(34).NE.0
      DMAX=0.3D0
      CONVF=0.0003D0
C
C  CHANGE DEFAULT VALUES IF INSTRUCTED BY OPTIONS
C
      IF(IOP(5).NE.0) NEGREQ=0
      IF(IOP(6).NE.0) MXSTEP=IOP(6)
c     IF(IOP(10).EQ.0.OR.IOP(10).EQ.4) IHESS=0
c     IF(IOP(11).NE.0) MXHESS=IOP(11)
c     IF(IOP(11).EQ.1.AND.IGETFC.EQ.4) MXHESS=999999
c     IF(IOP(11).EQ.1.AND.IGETFC.EQ.4) IHESS=-999999
      IF(IOP(13).NE.0) IUPDAT=IOP(13)
      IF(IOP(16).NE.0) EIGMAX=0.1D0*IOP(16)
      IF(IOP(17).NE.0) EIGMIN=1.0D0/IOP(17)
      IF(IOP(8).NE.0) DMAX=0.01D0*IOP(8)
c     IF(IOP(21).NE.0) THEN
c       DMAX=1.0D0
c       EIGMIN=ZERO
c       EIGMAX=1.0D+12
c     ENDIF
      IF(IOP(7).NE.0) CONVF=0.001D0/IOP(7)
C
C  CALCULATE REMAINING CONVERGENCE FACTORS
C
      CNVFMX=CONVF*1.5D0
      CONVX=CONVF*4.0D0
      CNVXMX=CONVX*1.5D0
C
C  PRINT OUT SELECTED PARAMETERS
C
c     IHOP=MXHESS
c     IF(IOP(11).EQ.1) IHOP=1
c     WRITE(IOUT,1020) MXSTEP,DMAX,IHOP
C
C  CHECK HESSIAN MODE FOLLOWING
C
      IF(MODE.GT.0 .and. nstep.lt.1) THEN
      IF(MODE.GT.NVAR) THEN
      IHOP=MODE-NVAR
      WRITE(IOUT,1025) IHOP
      ELSE
      WRITE(IOUT,1030) MODE
      ENDIF
      IF(MODE.GT.2*NVAR) WRITE(IOUT,1040)
c     IF(MODE.GT.2*NVAR) CALL LNK1E
      IF(MODE.GT.2*NVAR) stop
      ENDIF
C
      RETURN
C
 500  FORMAT(8F10.6)
 510  FORMAT(2I3,F20.0)
C
1000  FORMAT(//' ************************************************'/
     $         ' ** ERROR IN INITEF. NUMBER OF VARIABLES (',I3,') **'/
     $         ' **   INCORRECT (SHOULD BE BETWEEN 1 AND 50)   **'/
     $         ' ************************************************'//)
C
1005  FORMAT(//' CALL FROM INITEF:  BAD IC ENTRY FOR VARIABLE ',I3)
C
1010  FORMAT(//' CALL FROM INITEF:  OPTION 10 OUT OF RANGE ',
     $       ' IOP(10) = ',I4)
C
1020  FORMAT(//' ***************************************************'/
     $         ' ** O P T I M I Z A T I O N   P A R A M E T E R S **'/
     $         ' **  MAXIMUM NO. OF ITERATIONS      :  ',I10,' **'/
     $         ' **  MAXIMUM ALLOWED STEP LENGTH    :  ',F10.6,' **'/
     $         ' **  STEPS BEFORE HESSIAN REEVALUATED :  ',I8,' **'/
     $         ' ***************************************************'//)
C
1025  FORMAT(//' HESSIAN MODE FOLLOWING SWITCHED ON',/
     $       ' FOLLOWING MODE ',I3)
C
1030  FORMAT(//' HESSIAN MODE FOLLOWING SWITCHED ON',/
     $       ' FOLLOWING MODE WITH LARGEST MAGNITUDE COMPONENT',
     $       ' FOR VARIABLE ',I3)
C
1040  FORMAT(//' CALL FROM INITEF:  MODE FOLLOWING OUT OF RANGE')
C
      END
      SUBROUTINE MAGCHK(EIGVAL,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
      DATA ZERO/0.0D0/
C
C  FIRST CHECK IF THE MAGNITUDES OF THE LOWEST EIGENVALUES
C  EXCEED EIGMIN
C
      DO 10 I=1,NVAR
      IF(EIGVAL(I).GT.EIGMIN) GO TO 11
      IF(DABS(EIGVAL(I)).LT.EIGMIN) THEN
      IF(EIGVAL(I).LT.ZERO) EIGVAL(I)=-EIGMIN
      IF(EIGVAL(I).GE.ZERO) EIGVAL(I)= EIGMIN
      IF(PRNT) WRITE(IOUT,1000) I,EIGVAL(I)
      ENDIF
   10 CONTINUE
   11 CONTINUE
C
C  NOW CHECK IF THE MAGNITUDES OF THE HIGHEST EIGENVALUES
C  EXCEED EIGMAX
C
      DO 20 I=1,NVAR
      II=NVAR-I+1
      IF(EIGVAL(II).LT.EIGMAX) GO TO 21
      IF(DABS(EIGVAL(II)).GT.EIGMAX) THEN
      IF(EIGVAL(II).LT.ZERO) EIGVAL(II)=-EIGMAX
      IF(EIGVAL(II).GE.ZERO) EIGVAL(II)= EIGMAX
      IF(PRNT) WRITE(IOUT,2000) II,EIGVAL(II)
      ENDIF
   20 CONTINUE
   21 CONTINUE
C
      RETURN
C
1000  FORMAT(' WARNING! EIGENVALUE ',I2,' TOO SMALL. REPLACED',
     $       ' BY ',F12.6)
C
2000  FORMAT(' WARNING! EIGENVALUE ',I2,' TOO LARGE. REPLACED',
     $       ' BY ',F12.6)
C
      END
      SUBROUTINE OVRLAP(U,NMODE,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 U(50,50)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
C  ON THE FIRST STEP DETERMINE WHICH MODE TO FOLLOW
C
      IF(NSTEP.EQ.1) THEN
C
C  (A) FOLLOWING A GIVEN MODE
C
      IF(MODE.GT.NVAR) THEN
      IT=MODE-NVAR
      GO TO 10
      ENDIF
C
C  FIND THE HESSIAN EIGENVECTOR WITH THE LARGEST MAGNITUDE
C  COMPONENT IN THE POSITION GIVEN BY MODE (READ IN VIA IC ARRAY)
C
      IT=1
      TOVLP=DABS(U(MODE,1))
      DO 5 I=2,NVAR
      IF(DABS(U(MODE,I)).GT.TOVLP) THEN
      TOVLP=DABS(U(MODE,I))
      IT=I
      ENDIF
    5 CONTINUE
C
   10 MODE=IT
      IF(PRNT) WRITE(IOUT,1000) MODE
C
      ELSE
C
C  ON SUBSEQUENT STEPS DETERMINE WHICH HESSIAN EIGENVECTOR HAS
C  THE GREATEST OVERLAP WITH THE MODE WE ARE FOLLOWING
C
      IT=1
cets  TOVLP=DVTV(U(1,1),VMODE,NVAR)
      do 11 i=1,nvar
      tovlp=u(i,1)*vmode(i)+tovlp
   11 continue
      TOVLP=DABS(TOVLP)
      DO 6 I=2,NVAR
cets  OVLP=DVTV(U(1,I),VMODE,NVAR)
      do 6 j=1,nvar
      ovlp=ovlp+u(j,i)*vmode(j)
      OVLP=DABS(OVLP)
      IF(OVLP.GT.TOVLP) THEN
      TOVLP=OVLP
      IT=I
      ENDIF
    6 CONTINUE
C
      IF(PRNT) WRITE(IOUT,1010) TOVLP
      ENDIF
C
C  SAVE THE EIGENVECTOR IN VMODE
C
      DO 7 I=1,NVAR
      VMODE(I)=U(I,IT)
    7 CONTINUE
C
      NMODE=IT
      RETURN
C
1000  FORMAT(' HESSIAN MODE FOLLOWING SWITCHED ON'/
     $       ' FOLLOWING MODE ',I3)
C
1010  FORMAT(' OVERLAP OF CURRENT MODE WITH PREVIOUS MODE IS ',F12.6)
C
      END
      SUBROUTINE UPDATE(SVEC,TVEC)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SVEC(1),TVEC(1)
      LOGICAL PRNT,NRFLAG,DUMP
      COMMON/IO/IN,IOUT,INP2,IPUN,IGMUP
      COMMON/GRDNT/ENERGY,F(50),FRCNST(1275),NVAR,IGETFC
      COMMON/OPTEF/X(50),XNAME(50),OLDF(50),D(50),HESS(50,50),
cets $             IC(50),VMODE(50),MODE,ES,NSTEP,MXSTEP,IHESS,IS,
     $             IC(50),VMODE(50),MODE,NSTEP,MXSTEP,IHESS,IS,
     $             NEGREQ,DMAX,DD,CONVF,CNVFMX,CONVX,CNVXMX,IUPDAT,
     $             MXHESS,EIGMAX,EIGMIN,PRNT,NRFLAG,DUMP,IDUM
C
      DATA ZERO/0.0D0/
C
C  UPDATING OF THE HESSIAN
C  DEPENDS ON CURRENT GRADIENTS, OLD GRADIENTS AND THE
C  CORRECTION VECTOR USED ON THE LAST CYCLE
C  SVEC & TVEC ARE FOR TEMPORARY STORAGE
C
C  2 UPDATING PROCEDURES ARE POSSIBLE
C  (I)   THE POWELL UPDATE
C        THIS PRESERVES THE SYMMETRIC CHARACTER OF THE HESSIAN
C        WHILST ALLOWING ITS EIGENVALUE STRUCTURE TO CHANGE.
C        IT IS THE DEFAULT UPDATE
C  (II)  THE BFGS UPDATE
C        THIS UPDATE HAS THE IMPORTANT CHARACTERISTIC OF RETAINING
C        POSITIVE DEFINITENESS (NOTE: THIS IS NOT RIGOROUSLY
C        GUARANTEED) WHICH CAN BE USEFUL FOR A MINIMUM SEARCH.
C        SHOULD BE USED IN CONJUNCTION WITH "MIN".
C
C
cets  CALL DMDOTV(TVEC,HESS,D,NVAR)
      do 191 i=1,nvar
      do 191 j=1,nvar
      tvec(i)=tvec(i)+hess(i,j)*d(j)
  191 continue
C
      IF(IUPDAT.EQ.0) THEN
C
C   (I) POWELL UPDATE
C
      IF(PRNT) WRITE(IOUT,1000)
C
      DO 9 I=1,NVAR
      TVEC(I)=F(I)-OLDF(I)-TVEC(I)
    9 CONTINUE
      DDS=DD*DD
cets  DDTD=DVTV(TVEC,D,NVAR)
      do 111 i=1,nvar
      ddtd=ddtd+tvec(i)*d(i)
  111 continue
      DDTD=DDTD/DDS
C
      DO 10 I=1,NVAR
      DO 11 J=1,I
      TEMP=TVEC(I)*D(J) + D(I)*TVEC(J) - D(I)*DDTD*D(J)
      HESS(I,J)=HESS(I,J)+TEMP/DDS
      HESS(J,I)=HESS(I,J)
   11 CONTINUE
   10 CONTINUE
C
      ELSE
C
C  (II) BFGS UPDATE
C
      IF(PRNT) WRITE(IOUT,2000)
C
      DO 19 I=1,NVAR
      SVEC(I)=F(I)-OLDF(I)
   19 CONTINUE
cets  DDS=DVTV(SVEC,D,NVAR)
      do 119 i=1,nvar
      dds=dds+svec(i)*d(i)
  119 continue
C
C  IF DDS IS NEGATIVE, RETENTION OF POSITIVE DEFINITENESS IS NOT
C  GUARANTEED. PRINT A WARNING AND SKIP THE UPDATE THIS TIME IF
C  REQUESTED
C
      IF(DDS.LT.ZERO) THEN
      WRITE(IOUT,1500)
      IF(IUPDAT.EQ.2) THEN
      WRITE(IOUT,1600)
      RETURN
      ENDIF
      ENDIF
C
cets  DDTD=DVTV(D,TVEC,NVAR)
      do 120 i=1,nvar
      ddtd=ddtd+d(i)*tvec(i)
  120 continue
C
      DO 20 I=1,NVAR
      DO 21 J=1,I
      TEMP= (SVEC(I)*SVEC(J))/DDS - (TVEC(I)*TVEC(J))/DDTD
      HESS(I,J)=HESS(I,J)+TEMP
      HESS(J,I)=HESS(I,J)
   21 CONTINUE
   20 CONTINUE
      ENDIF
C
      RETURN
C
1000  FORMAT(' HESSIAN UPDATED USING POWELL UPDATE')
C
1500  FORMAT(' WARNING! HEREDITARY POSITIVE DEFINITENESS ENDANGERED')
C
1600  FORMAT(' UPDATE SKIPPED THIS CYCLE')
C
2000  FORMAT(' HESSIAN UPDATED USING BFGS UPDATE')
C
      END
      SUBROUTINE FNDNEG(EIGVAL,NEG,NVAR)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 EIGVAL(1)
      DATA ZERO/0.0D0/
C
C  FIND THE NUMBER OF NEGATIVE EIGENVALUES
C  THIS WILL BE RETURNED IN NEG
C
      DO 9 I=1,NVAR
      IF(EIGVAL(I).GT.ZERO) GO TO 10
    9 CONTINUE
   10 NEG=I-1
C
      RETURN
      END
      SUBROUTINE CNTRCT(A,B,N)
      REAL*8 A(1),B(50,1)
C
C  CONTRACTS A FULL MATRIX B INTO A SINGLE SUBSCRIPT
C  LOWER TRIANGLE ARRAY A
C
      DO 10 I=1,N
      II=(I*(I-1))/2
      DO 10 J=1,I
      IJ=II+J
      A(IJ)=B(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE EXPAND(A,B,N)
      REAL*8 A(50,1),B(1)
C
C  EXPANDS A SINGLE SUBSCRIPT LOWER TRIANGLE ARRAY B
C  INTO A FULL MATRIX A
C
      DO 10 I=1,N
      II=(I*(I-1))/2
      DO 10 J=1,I
      IJ=II+J
      A(I,J)=B(IJ)
      A(J,I)=A(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVSKAL(A,B,SCALE,N)
      REAL*8 A(1),B(1),SCALE
C
C  A = B * SCALE
C
      DO 10 I=1,N
      A(I)=B(I)*SCALE
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVADDV(A,B,C,N)
      REAL*8 A(1),B(1),C(1)
C
C  A = B + C
C
      DO 10 I=1,N
      A(I)=B(I)+C(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVNEGV(A,B,C,N)
      REAL*8 A(1),B(1),C(1)
C
C  A = B - C
C
      DO 10 I=1,N
      A(I)=B(I)-C(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DVCOPY(A,B,N)
      REAL*8 A(1),B(1)
C
C  COPIES VECTOR B INTO A
C
      DO 10 I=1,N
      A(I)=B(I)
   10 CONTINUE
C
      RETURN
      END
      FUNCTION DVTV(A,B,N)
      REAL*8 A(50),B(50)
C
C  DVTV = A' * B
C
      DVTV=0.0D0
      DO 10 I=1,N
      DVTV=DVTV+A(I)*B(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DNEGV(A,N)
      REAL*8 A(1)
C
C  A = -A
C
      DO 10 I=1,N
      A(I)=-A(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMDOTV(A,B,C,N)
      REAL*8 A(1),B(50,1),C(1)
      DATA ZERO/0.0D0/
C
C  A = B * C
C
      DO 10 I=1,N
      A(I)=ZERO
      DO 10 J=1,N
      A(I)=A(I)+B(I,J)*C(J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMCOPY(A,B,N)
      REAL*8 A(50,1),B(50,1)
C
C  COPIES MATRIX B INTO A
C
      DO 10 I=1,N
      DO 10 J=1,N
      A(I,J)=B(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMSYMM(A,N)
      REAL*8 A(50,1)
      DATA HALF/0.5D0/
C
C  SYMMETRIZES A MATRIX A
C
      DO 10 I=2,N
      DO 10 J=1,I-1
      A(I,J)=HALF*(A(I,J)+A(J,I))
      A(J,I)=A(I,J)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE DMPRNT(A,N,IOUT)
      REAL*8 A(50,1)
C
C  PRINTS OUT THE MATRIX A
C
      LOW=1
      NUP=6
   10 NUP=MIN0(NUP,N)
      WRITE(IOUT,1000) (I,I=LOW,NUP)
      DO 20 I=1,N
      WRITE(IOUT,2000) I,(A(I,J),J=LOW,NUP)
   20 CONTINUE
      NUP=NUP+6
      LOW=LOW+6
      IF(LOW.LT.N) GO TO 10
C
      RETURN
C
1000  FORMAT(1X,6I12)
C
2000  FORMAT(1X,I3,6F12.6)
C
      END
      subroutine convgd(A,B,ireslt)
      real*8 a,b
      character*3 ireslt
c
c  A < B ?
c
      if(a.lt.b) then
          ireslt = 'YES'
          else
          ireslt = ' NO'
          endif
      return
c
      end
      subroutine aclear(n,a)
      real*8 a(n)
c
c  A = 0
c
      do 10 i=1,n
 10   a(i) = 0.0d0
      return
c
      end
      PROGRAM BMWRTA
      DOUBLE PRECISION G(30,3),X(30,3),ZETA
      PARAMETER (LTEXT=1200)
      CHARACTER LABEL*80,OPTION*4,TEXT(LTEXT)*80,TEXT2(30)*16
 1000 FORMAT(A4)
 1002 FORMAT(I5)
 1004 FORMAT(A80)
 1006 FORMAT(4F20.10)
 1008 FORMAT(5X,I5)
 1010 FORMAT(A16)
 1012 FORMAT(A16,3F16.12)
 1014 FORMAT(3F16.12)
      IIN=11
      IOUT=40
      call drum
      open (unit=iout,file='bmat.dat',status='old')
      open (unit=11,file='file11',status='old')
C  READ GEOMETRY AND GRADIENTS FROM FILE11.
 1    READ(IIN,1000,END=3) OPTION
      GO TO 1
 3    BACKSPACE IIN
      BACKSPACE IIN
      READ(IIN,1002) NA
      IF(NA.GT.0) GO TO 5
      GO TO 3
  5   DO  7  I=1,NA
  7   READ(IIN,1006,END=100) ZETA,(X(I,J),J=1,3)
      DO  9  I=1,NA
  9   READ(IIN,1006,END=100) ZETA,(G(I,J),J=1,3)
C  READ NA AND TEXT FROM BMAT FILE.
 11   READ(IOUT,1000,END=100) OPTION
      IF(OPTION.EQ.'CARD') THEN
            BACKSPACE IOUT
            READ(IOUT,1008) NA
            GO TO 13
      END IF
      GO TO 11
 13   READ(IOUT,1000,END=100) OPTION
      IF(OPTION(1:1).EQ.' ') GO TO 15
      GO TO 13
 15   BACKSPACE IOUT
      DO 17  I=1,NA
 17   READ(IOUT,1010,END=100) TEXT2(I)
      DO 19  I=1,NA
 19   READ(IOUT,1000,END=100) OPTION
      K=1
 21   CONTINUE
          IF ( K .GT. LTEXT ) THEN
              WRITE(6,*) 'BMWRTG: ERROR: THE TEXT BUFFER IS TOO SMALL,'
              WRITE(6,*) '        INCREASE LTEXT TO THE FILE LENGTH.'
              WRITE(6,*) 'BMWRTG: ABORTING.'
              STOP
          ENDIF
          READ(IOUT,1004,END=23)TEXT(K)
          K=K+1
          GO TO 21
C   WRITE COORDINATES,GRADIENTS, AND TEXT INTO BMAT FILE.
 23   DO 25  I=1,K+2*NA
 25   BACKSPACE IOUT
      DO 27  I=1,NA
 27   WRITE(IOUT,1012) TEXT2(I),(X(I,J),J=1,3)
      DO 29  I=1,NA
 29   WRITE(IOUT,1014) (G(I,J),J=1,3)
      DO 31  I=1,K-1
 31   WRITE(IOUT,1004) TEXT(I)
 100  CONTINUE
      END
      DOUBLE PRECISION G(30,3),X(30,3),ZETA
      CHARACTER LABEL*80,OPTION*4,TEXT(200)*80,TEXT2(30)*16
 1000 FORMAT(A4)
 1002 FORMAT(I5)
 1004 FORMAT(A80)
 1006 FORMAT(4F20.10)
 1008 FORMAT(10X,I2)
 1010 FORMAT(A16)
 1012 FORMAT(A16,3F16.12)
 1014 FORMAT(3F16.12)
      call drum
      IIN=11
      IOUT=40
c
      open (unit=iout,file='bmat.dat',status='old')
      open (unit=11,file='file11',status='old')
c
C  READ GEOMETRY AND GRADIENTS FROM FILE11.
 1    READ(IIN,1000,END=3) OPTION
      GO TO 1
 3    BACKSPACE IIN
      BACKSPACE IIN
      READ(IIN,1002) NA
      IF(NA.GT.0) GO TO 5
      GO TO 3
  5   DO  7  I=1,NA
  7   READ(IIN,1006,END=100) ZETA,(X(I,J),J=1,3)
      DO  9  I=1,NA
  9   READ(IIN,1006,END=100) ZETA,(G(I,J),J=1,3)
C  READ NA AND TEXT FROM BMAT FILE.
 11   READ(IOUT,1000,END=100) OPTION
      IF(OPTION.EQ.'CARD') THEN
            BACKSPACE IOUT
            READ(IOUT,1008) NA
            GO TO 13
      END IF
      GO TO 11
 13   READ(IOUT,1000,END=100) OPTION
      IF(OPTION(1:1).EQ.' ') GO TO 15
      GO TO 13
 15   BACKSPACE IOUT
      DO 17  I=1,NA
 17   READ(IOUT,1010,END=100) TEXT2(I)
      DO 19  I=1,NA
 19   READ(IOUT,1000,END=100) OPTION
      K=1
 21   READ(IOUT,1004,END=23)TEXT(K)
      K=K+1
      GO TO 21
C   WRITE COORDINATES,GRADIENTS, AND TEXT INTO BMAT FILE.
 23   DO 25  I=1,K+2*NA
 25   BACKSPACE IOUT
      DO 27  I=1,NA
 27   WRITE(IOUT,1012) TEXT2(I),(X(I,J),J=1,3)
      DO 29  I=1,NA
 29   WRITE(IOUT,1014) (G(I,J),J=1,3)
      DO 31  I=1,K-1
 31   WRITE(IOUT,1004) TEXT(I)
 100  CONTINUE
      END
      PROGRAM GEOMIU
c This version of geomup changes the '# GEOMUP #' to a '# GEOM   #'
c
c mtext = maximum number of lines in the input file past the first
c         '# GEOMUP #'
c matom = maximum number of atoms.
 
c----------------------------------------------------------
c Updated: May 7, 1988 by Curtis Janssen
c Reason:   Test number of atoms and size of input file to
c        avoid overwriting when reading data.  Also, test
c        ierr after 'call locate'.
C**********************************************************
C***LAST UPDATED ON FEBRUARY 13, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C   THE SOURCE CODE OF GEOMETRY UPDATING PROGRAM
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter (mtext=1200, matom=200)
      CHARACTER TEXT(mtext)*80
      DIMENSION I30(200),CHG(50),COORD(3,matom)
    1 FORMAT(//,2X,' THE GEOMETRY UPDATING PROGRAM'//)
    2 FORMAT(//,2X,' PARAMETERS'/
     1 2X,' MPOINT = ',I5/
     2 2X,' MCONST = ',I5/
     3 2X,' NCALCS = ',I5/
     4 2X,' NATOM  = ',I5/
     5 2X,' N3N    = ',I5/
     6 2X,' IGEOP  = ',I5)
    3 FORMAT(//,2X,' OLD COORDINATES IN TAPE30'/
     1 39X,' OLD X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    4 FORMAT(3X,I5,1X,4F16.10)
    5 FORMAT(//,2X,' NEW COORDINATES IN TAPE30'/
     1 39X,' NEW X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    6 FORMAT(3F20.10)
    7 FORMAT(//,2X,' GEOMETRY IN TAPE30 IS UPDATED'/)
C
c     CALL TSTART(6)
c     CALL NOUNFL
      call drum
C
      INPUT=5
      ITAPE6=6
      ITAP30=30
C
      WRITE(6,1)
C
C************************************
C***UPDATE TAPE30 FOR NEW GEOMETRY***
C************************************
C
C   READ IN GEOMETRY FROM TAPE30
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I30,200,101,JUNK)
      MPOINT=I30(2)
      MCONST=I30(3)
      NCALCS=I30(5)
      NATOM=I30(19)
      N3N=NATOM*3
      IGEOP=100+MCONST+MPOINT+NCALCS
c
      if (natom .gt. matom) then
         write(6,*) '--ERROR--------------------------------'
         write(6,*) 'GEOMUPIU: You have too many atoms. Increase matom.'
         call mabort
         endif
C
      WRITE(6,2) MPOINT,MCONST,NCALCS,NATOM,N3N,IGEOP
      CALL WREADW(ITAP30,LOCCAL,1,IGEOP,JUNK)
      IGEOP=LOCCAL+80
      CALL WREADW(ITAP30,COORD,N3N*2,IGEOP,JUNK)
C
      WRITE(6,3)
      DO 101 I=1,NATOM
      WRITE(6,4) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  101 CONTINUE
C
      CALL LOCATE(INPUT,'# GEOMUP #',IERR)
      if (ierr .ne. 0) then
          write(6,*) '--ERROR--------------------------------'
          write(6,*) 'GEOMUPIU: The input must have a ''# GEOMUP #'''
          call mabort
          endif
c
      WRITE(6,5)
CWA
 1000 FORMAT(A80)
 1001 FORMAT('# GEOM   #')
      KWA=1
 1005 READ(INPUT,1000,END=1010) TEXT(KWA)
          KWA=KWA+1
          if (kwa .gt. mtext) then
              write(6,*) '--ERROR--------------------------------'
              write(6,*) 'GEOMUPIU: Your input file is too large.'
              write(6,*) '         Decrease its size or increase mtext'
              call mabort
              endif
          GO TO 1005
 1010 continue
      DO 1015  I=1,KWA+1
 1015     BACKSPACE INPUT
      WRITE(INPUT,1001)
      DO 1020  I=1,KWA-1
 1020     WRITE(INPUT,1000) TEXT(I)
      DO 1025  I=1,KWA-1
 1025     BACKSPACE INPUT
CWA
      DO 102 I=1,NATOM
      READ(5,6) XX,YY,ZZ
      COORD(1,I)=XX
      COORD(2,I)=YY
      COORD(3,I)=ZZ
      WRITE(6,4) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  102 CONTINUE
      CALL WWRITW(ITAP30,COORD,N3N*2,IGEOP,JUNK)
      WRITE(6,7)
C
c     CALL TSTOP(6)
      CALL RCLOSE(ITAP30,3)
      STOP
      END
 
      PROGRAM GEOMUP
C**********************************************************
C***LAST UPDATED ON FEBRUARY 13, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C   THE SOURCE CODE OF GEOMETRY UPDATING PROGRAM
C   THIS PROGRAM IS ABLE TO TREAT UP TO '50' ATOMS
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER TEXT(200)*80
      DIMENSION I30(200),CHG(50),COORD(3,50)
    1 FORMAT(//,2X,' THE GEOMETRY UPDATING PROGRAM'//)
    2 FORMAT(//,2X,' PARAMETERS'/
     1 2X,' MPOINT = ',I5/
     2 2X,' MCONST = ',I5/
     3 2X,' NCALCS = ',I5/
     4 2X,' NATOM  = ',I5/
     5 2X,' N3N    = ',I5/
     6 2X,' IGEOP  = ',I5)
    3 FORMAT(//,2X,' OLD COORDINATES IN TAPE30'/
     1 39X,' OLD X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    4 FORMAT(3X,I5,1X,4F16.10)
    5 FORMAT(//,2X,' NEW COORDINATES IN TAPE30'/
     1 39X,' NEW X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    6 FORMAT(3F20.10)
    7 FORMAT(//,2X,' GEOMETRY IN TAPE30 IS UPDATED'/)
c
      call drum
C
c     CALL TSTART(6)
C
      INPUT=5
      ITAPE6=6
      ITAP30=30
c
      open (unit=itap30,file='bmat.punch',status='unknown')
C
      WRITE(6,1)
C
C************************************
C***UPDATE TAPE30 FOR NEW GEOMETRY***
C************************************
C
C   READ IN GEOMETRY FROM TAPE30
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I30,200,101,JUNK)
      MPOINT=I30(2)
      MCONST=I30(3)
      NCALCS=I30(5)
      NATOM=I30(19)
      N3N=NATOM*3
      IGEOP=100+MCONST+MPOINT+NCALCS
C
      WRITE(6,2) MPOINT,MCONST,NCALCS,NATOM,N3N,IGEOP
      CALL WREADW(ITAP30,LOCCAL,1,IGEOP,JUNK)
      IGEOP=LOCCAL+80
      CALL WREADW(ITAP30,COORD,N3N*2,IGEOP,JUNK)
C
      WRITE(6,3)
      DO 101 I=1,NATOM
      WRITE(6,4) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  101 CONTINUE
C
      CALL LOCATE(INPUT,'# GEOMUP #',IERR)
      WRITE(6,5)
CWA
 1000 FORMAT(A80)
 1001 FORMAT('# GEOM   #')
      KWA=1
 1005 READ(INPUT,1000,END=1010) TEXT(KWA)
      KWA=KWA+1
      GO TO 1005
 1010 DO 1015  I=1,KWA+1
 1015 BACKSPACE INPUT
      WRITE(INPUT,1001)
      DO 1020  I=1,KWA-1
 1020 WRITE(INPUT,1000) TEXT(I)
      DO 1025  I=1,KWA-1
 1025 BACKSPACE INPUT
CWA
      DO 102 I=1,NATOM
      READ(5,6) XX,YY,ZZ
      COORD(1,I)=XX
      COORD(2,I)=YY
      COORD(3,I)=ZZ
      WRITE(6,4) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  102 CONTINUE
      CALL WWRITW(ITAP30,COORD,N3N*2,IGEOP,JUNK)
      WRITE(6,7)
C
c     CALL TSTOP(6)
      CALL RCLOSE(ITAP30,3)
      STOP
      END
      PROGRAM GNEXTS
C**********************************************************
C***LAST UPDATED ON FEBRUARY 20, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C***LAST UPDATED ON AUGUST 19, 1985 BY RICHARD REMINGTON***
C*** REASON: INCREASE MATRIX NAT TO NAT(50,50) FROM     ***
C*** NAT(10,10) FOR LARGE CASES AND ADD AN ADDITIONAL   ***
C*** OPTION TO  "IPRNT"  IN ORDER TO SUPPRESS PRINTING  ***
C*** OF ANGLES FOR LARGE CASES (ANY NEGATIVE VALUE FOR  ***
C*** THE EIGHTH PARAMETER SUPPRESSES ANGLE PRINTING).   ***
C**********************************************************
C   THE SOURCE CODE OF GEOMETRY OPTIMIZATION PROGRAM
C   THIS PROGRAM IS ABLE TO TREAT UP TO '50' ATOMS
C   THIS PROGRAM IS ABLE TO TREAT UP TO '150' INTERNAL COORDINATES
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION CC(100000),IA(1)
      DIMENSION I30(200),NUNQ(50),NAT(50,50),COORD(3,50)
      CHARACTER*8 UPD
      LOGICAL UPDATE
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/EX(50),EY(50),EZ(50)
      COMMON/COM105/ENGR(150),RCOOD(150)
      COMMON/COM106/ESCF(150),GNORM(150),SNORM(150)
      COMMON/COM107/R(1275)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM109/XMAX,YMAX,ZMAX
      COMMON/COM110/NSET(150),NORD(150),NXVAR(150)
      COMMON/COM112/XOLD(150),XNEW(150)
      EQUIVALENCE (CC,IA)
      DATA ZERO,TEN / 0.0D+00 , 10.0D+00 /
      DATA FMILI / 1.0D-3 /
    1 FORMAT(//,2X,' THE GEOMETRY OPTIMIZATION PROGRAM'//)
    2 FORMAT(2I5,F20.10,I5)
    3 FORMAT(10I5)
    4 FORMAT(14I5)
    5 FORMAT(A5,3I5)
    6 FORMAT(2X,' NCOOD   = ',I5/
     1 2X,' NSORT   = ',I5/
     2 2X,' IHESS   = ',I5/
     3 2X,' IMETR   = ',I5/
     4 2X,' IAGHES  = ',I5/
     5 2X,' NVAR    = ',I5/
     6 2X,' NROOT   = ',I5/
     7 2X,' IPRNT   = ',I5/
     8 2X,' NATOM   = ',I5/
     9 2X,' N3N     = ',I5/
     A 2X,' NINT    = ',I5/
     B 2X,' IFORCE  = ',I5/
     C 2X,' NSTORE  = ',I5/
     D 2X,' NCASE   = ',I5/
     E 2X,' NPLUS   = ',I5/
     F 2X,' NDIF    = ',I5/
     H 2X,' NCHNG   = ',I5/
     H 2X,' NCONV   = ',I5/
     I 2X,' NUNIQ   = ',I5)
    7 FORMAT(//,2X,' THERE ARE NOT ENOUGH DATA TO USE THE QUASI NEWTON-R
     1APHSON METHOD'/)
    8 FORMAT(//,2X,' OLD COORDINATES IN TAPE30'/
     1 39X,' OLD X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    9 FORMAT(3X,I5,1X,4F16.10)
   10 FORMAT(//,2X,' NEW COORDINATES IN TAPE30'/
     1 39X,' NEW X IN A.U.'/
     2 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
   11 FORMAT(//,2X,' GEOMETRY IN TAPE30 IS UPDATED'/)
   12 FORMAT(//,2X,':::::::::::::::::::::::::::'/
     1          2X,':::GEOMETRY IS OPTIMIZED:::'/
     2          2X,':::::::::::::::::::::::::::'//
     3          2X,' GNORM = ',F15.10,7X,' GCONV = ',F15.10/)
   13 FORMAT(//,2X,' TOO BIG CHANGE IN GEOMETRY---SCRATCH YOUR HEAD TO F
     1IND A NEW GEOMETRY'//
     2          2X,' XMAX = ',F15.10,7X,' YMAX = ',F15.10,7X,' ZMAX = ',
     3                        F15.10,7X,' GCHNG = ',F15.10/)
   14 FORMAT(//,2X,' SHORT OF INFORMATION---SCRATCH YOUR HEAD TO FIND A
     1NEW GEOMETRY'/)
C
      call drum
c
c     CALL TSTART(6)
C
      LDIM=1275
      MDIM=150
      NDIM=50
      INPUT=5
      ITAPE6=6
      ITAP12=12
      ITAP13=13
      ITAP15=15
      ITAP30=30
      IFLAG=0
      MAXCOR=100000
C
      WRITE(6,1)
      REWIND ITAP12
      open (unit=itap13,file='fort.13',status='old')
      REWIND ITAP13
      READ(ITAP12,2) NATOM,NINT,ESCFZ,IFORCE
C
C   NSORT IS A PARAMETER FOR SORTING
C     NSORT=0---NO SORT
C     NSORT=1---GRADIENT SORT
C     NSORT=2---ENERGY SORT
C     NSORT=3---SELECTED GRADIENT SORT
C   IMETR IS A PARAMETER FOR THE VARIABLE METRIC METHOD
C     IMETR=0---SKIP THIS METHOD
C     IMETR=1---MURTAGH-SARGENT METHOD
C     IMETR=2---FLETCHER METHOD
C     IMETR=3---DAVIDON-FLETCHER-POWELL METHOD
C   IAHESS IS A PARAMETER FOR THE AUGMENTED HESSIAN METHOD
C     IAHESS=0---SKIP THIS METHOD
C     IAHESS=1---USE THIS METHOD
C
      N3N=NATOM*3
      CALL LOCATE(INPUT,'# GNEXTS #',IERR)
      READ(5,3) NCOOD,NSORT,IHESS,IMETR,IAGHES,NVAR,NROOT,IPRNT
      IF(NROOT.LE.0) NROOT=1
      READ(5,4) (NSET(I),I=1,NCOOD)
      DO 101 I=1,N3N
  101 NXVAR(I)=I
      IF(NVAR.EQ.0) NVAR=N3N
      IF(NVAR.EQ.N3N) GO TO 201
      READ(5,4) (NXVAR(I),I=1,NVAR)
  201 READ(ITAP13,3) NSTORE
      NCASE=NCOOD+1
      NPLUS=NSTORE+1
      NDIF=NPLUS-NCASE
      READ(5,5) UPD,NCHNG,NCONV,NUNIQ
      IF(UPD.EQ.'UP     ') UPDATE=.TRUE.
      IF(NCHNG.EQ.0) NCHNG=2
      IF(NCONV.EQ.0) NCONV=7
      IF(NUNIQ.EQ.0) NUNIQ=NATOM
      WRITE(6,6) NCOOD,NSORT,IHESS,IMETR,IAGHES,NVAR,NROOT,IPRNT,
     1 NATOM,N3N,NINT,IFORCE,NSTORE,NCASE,NPLUS,NDIF,NCHNG,NCONV,NUNIQ
      GCHNG=TEN**(-NCHNG)
      GCONV=TEN**(-NCONV)
      IF(.NOT.UPDATE) GO TO 202
      DO 102 I=1,NATOM
      NUNQ(I)=1
      NAT(I,1)=I
  102 CONTINUE
      IF(NUNIQ.EQ.NATOM) GO TO 202
      DO 103 I=1,NUNIQ
      READ(5,4) NN,(NAT(I,J),J=1,NN)
      NUNQ(I)=NN
  103 CONTINUE
C
C   READ IN STORED INFORMATION FROM TAPE13
  202 CONTINUE
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+NINT*NPLUS
      IC5=IC4+NINT*NPLUS
      IC6=IC5+N3N*NPLUS
      IC7=IC6+N3N*NPLUS
      IC8=IC7+NINT*NPLUS
      ICMAX=IC8+NINT*NPLUS
C.................X       G       COOD    ENG.....
      CALL READIN(CC(IC5),CC(IC6),CC(IC7),CC(IC8))
C
C   SORT DATA W.R.T. GRADIENT OR ENERGY
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+NINT*NPLUS
      IC5=IC4+NINT*NPLUS
      IC6=IC5+N3N*NPLUS
      IC7=IC6+N3N*NPLUS
      IC8=IC7+NINT*NPLUS
      ICMAX=IC8+NINT*NPLUS
C...............SX      SG      SCOOD   SENG    X       G.......
      CALL SORT(CC(IC1),CC(IC2),CC(IC3),CC(IC4),CC(IC5),CC(IC6),
C...............COOD    ENG.....
     1          CC(IC7),CC(IC8))
      GNORML=GNORM(NPLUS)*FMILI
      IF(NSORT.EQ.3) GNORML=SNORM(NPLUS)*FMILI
      IF(GNORML.LT.GCONV) GO TO 215
C
C*********************************
C***QUASI NEWTON-RAPHSON METHOD***
C*********************************
C:::THIS SECTION ONLY HANDLES THE INTERNAL COORDINATE SYSTEM:::
C
      IF(NDIF.LT.0) GO TO 203
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+NINT*NPLUS
      IC5=IC4+NINT*NPLUS
      IC6=IC5+NCOOD*NCOOD
      IC7=IC6+NCOOD*NCOOD
      IC8=IC7+NCOOD*NCOOD
      IC9=IC8+NCOOD
      IA9=IC9+IC9-1
      ICMAX=IC9+NCOOD
C................SX      SG      SCOOD   SENG    FC      FT......
      CALL QUASI(CC(IC1),CC(IC2),CC(IC3),CC(IC4),CC(IC5),CC(IC6),
C................EE      PIVOT   INDEX...
     1           CC(IC7),CC(IC8),IA(IA9))
C
C   ESTIMATE FORCE CONSTANT MATRIX
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+NINT*NPLUS
      IC5=IC4+NINT*NPLUS
      IC6=IC5+NCOOD*NCOOD
      IC7=IC6+NCOOD*NCOOD
      IC8=IC7+NCOOD*NCOOD
      IC9=IC8+NCOOD*NCOOD
      IC10=IC9+NCOOD*NCOOD
      IC11=IC10+NCOOD
      IA11=IC11+IC11-1
      ICMAX=IC11+NCOOD
C.................SCOOD   SENG    FC      DELC    FF      DELG....
      CALL FESTIM(CC(IC3),CC(IC4),CC(IC5),CC(IC6),CC(IC7),CC(IC8),
C.................EE      PIVOT    INDEX....
     1            CC(IC9),CC(IC10),IA(IA11))
      IF(DABS(XMAX).GT.GCHNG) GO TO 204
      IF(DABS(YMAX).GT.GCHNG) GO TO 204
      IF(DABS(ZMAX).GT.GCHNG) GO TO 204
      GO TO 212
  203 CONTINUE
      WRITE(6,7)
C
C********************************
C***THE VARIABLE METRIC METHOD***
C********************************
C:::THIS SECTION ONLY HANDLES THE CARTESIAN COORDINATE SYSTEM:::
  204 CONTINUE
      IF(.NOT.UPDATE.AND.IMETR.EQ.0) GO TO 205
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+N3N*N3N
      IC5=IC4+NVAR*NVAR
      IC6=IC5+NVAR*NVAR
      IC7=IC6+NVAR*NVAR
      IC8=IC7+NVAR
      IA8=IC8+IC8-1
      ICMAX=IC8+NVAR
C.................SX      SG      FX      HH      FT      EE......
      CALL METRIC(CC(IC1),CC(IC2),CC(IC3),CC(IC4),CC(IC5),CC(IC6),
C.................PIVOT   INDEX...........................
     1            CC(IC7),IA(IA8),NVAR,IMETR,IHESS,UPDATE)
C
C**********************************
C***THE AUGMENTED HESSIAN METHOD***
C**********************************
  205 CONTINUE
      IF(IAGHES.EQ.0) GO TO 210
      N3N1=N3N+1
      N3NTRI=N3N1*(N3N1+1)/2
      IC1=1
      IC2=IC1+N3N*NPLUS
      IC3=IC2+N3N*NPLUS
      IC4=IC3+N3N*N3N
      IC5=IC4+N3N1*N3N1
      IC6=IC5+N3N1*N3N1
      IC7=IC6+N3N1*N3N1
      IC8=IC7+N3N1
      IC9=IC8+N3N1
      IC10=IC9+N3N1
      IC11=IC10+N3N1
      ICMAX=IC11+N3NTRI
C.................SX      SG      FX      ELX     EE      FT......
      CALL AGHESS(CC(IC1),CC(IC2),CC(IC3),CC(IC4),CC(IC5),CC(IC6),
C.................VALU    EIGN    FV1     FV2      FC.......
     1            CC(IC7),CC(IC8),CC(IC9),CC(IC10),CC(IC11),
C.............................
     2            N3N1,N3NTRI)
C
C*******************************
C***UPDATE TAPE10 IF REQUIRED***
C*******************************
C
  210 CONTINUE
      IF(.NOT.UPDATE.AND.NDIF.LT.0) GO TO 218
C
      IF(DABS(XMAX).GT.GCHNG) GO TO 217
      IF(DABS(YMAX).GT.GCHNG) GO TO 217
      IF(DABS(ZMAX).GT.GCHNG) GO TO 217
C
C   READ IN GEOMETRY FROM TAPE30
  212 CONTINUE
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I30,200,101,JUNK)
      MPOINT=I30(2)
      MCONST=I30(3)
      NCALCS=I30(5)
      IGEOP=100+MCONST+MPOINT+NCALCS
      CALL WREADW(ITAP30,LOCCAL,1,IGEOP,JUNK)
      IGEOP=LOCCAL+80
      CALL WREADW(ITAP30,COORD,intowp(N3N),IGEOP,JUNK)
      WRITE(6,8)
      DO 104 I=1,NATOM
      WRITE(6,9) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  104 CONTINUE
      DO 107 I=1,NUNIQ
      NN=NUNQ(I)
      SUMX=ZERO
      SUMY=ZERO
      SUMZ=ZERO
      DO 105 J=1,NN
      MM=NAT(I,J)
      SUMX=SUMX+DABS(XX(MM))
      SUMY=SUMY+DABS(YY(MM))
      SUMZ=SUMZ+DABS(ZZ(MM))
  105 CONTINUE
      ANX=DBLE(NN)
      AVGX=SUMX/ANX
      AVGY=SUMY/ANX
      AVGZ=SUMZ/ANX
      DO 106 J=1,NN
      MM=NAT(I,J)
      XX(MM)=DSIGN(AVGX,XX(MM))
      YY(MM)=DSIGN(AVGY,YY(MM))
      ZZ(MM)=DSIGN(AVGZ,ZZ(MM))
  106 CONTINUE
  107 CONTINUE
      WRITE(6,10)
      DO 108 I=1,NATOM
      COORD(1,I)=XX(I)
      COORD(2,I)=YY(I)
      COORD(3,I)=ZZ(I)
      WRITE(6,9) I,CHG(I),COORD(1,I),COORD(2,I),COORD(3,I)
  108 CONTINUE
      CALL WWRITW(ITAP30,COORD,intowp(N3N),IGEOP,JUNK)
      WRITE(6,11)
      CALL RCLOSE(ITAP30,3)
      GO TO 220
C
C   GEOMETRY IS OPTIMIZED
  215 CONTINUE
      WRITE(6,12) GNORML,GCONV
      GO TO 220
C
C   GEOMETRY CHANGE IS TOO LARGE
  217 CONTINUE
      WRITE(6,13) XMAX,YMAX,ZMAX,GCHNG
      GO TO 220
C
C   SHORT OF INFORMATION
  218 CONTINUE
      WRITE(6,14)
C
  220 CONTINUE
C
c     CALL TSTOP(6)
      STOP
      END
      SUBROUTINE READIN(X,G,COOD,ENG)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(N3N,NPLUS),G(N3N,NPLUS)
      DIMENSION COOD(NINT,NPLUS),ENG(NINT,NPLUS)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/EX(50),EY(50),EZ(50)
      COMMON/COM105/ENGR(150),RCOOD(150)
      COMMON/COM106/ESCF(150),GNORM(150),SNORM(150)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM110/NSET(150),NORD(150),NXVAR(150)
      DATA ITAP12,ITAP13 / 12 , 13 /
      DATA FKILO,FMILI / 1.0D+3 , 1.0D-3 /
    1 FORMAT(2I5,F20.10,I5)
    2 FORMAT(10I5)
    3 FORMAT(I5,F20.10)
    4 FORMAT(////,2X,10H CASE   = ,I5/
     1 2X,10H ESCF   = ,F20.10)
    5 FORMAT(//,2X,22H CARTESIAN COORDINATES,51X,10H GRADIENTS/
     1 4X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z,
     2                       17X,2H X,14X,2H Y,14X,2H Z)
    6 FORMAT(4F20.10)
    7 FORMAT(3X,I5,1X,4F16.10,3X,3F16.10)
    8 FORMAT(//,2X,' INTERNAL GRADIENTS (IN 1.0D+3 A.U.)'/
     1 5X,4H NO.,10X,7H COORD.,13X,6H GRAD./)
    9 FORMAT(2F20.10)
   10 FORMAT(2X,I7,5X,2F20.10)
   11 FORMAT(/,2X,22H NORM FOR GRADIENTS = ,F15.7)
   12 FORMAT(//,2X,' ***SELECTED VARIABLES DO NOT MATCH***'/
     1 2X,' NCOOD = ',I5,' II = ',I5/)
   13 FORMAT(/,2X,' NORM FOR CASE ',I5,3X,' IS ',F15.7/)
   14 FORMAT(///,2X,' CARTESIAN COORDINATE MATRIX'/)
   15 FORMAT(//,2X,' INTERNAL COORDINATE MATRIX'/)
   16 FORMAT(//,2X,' CARTESIAN GRADIENT MATRIX'/)
   17 FORMAT(//,2X,' INTERNAL GRADINET MATRIX'/)
   18 FORMAT(//,2X,' GRADIENTS NORMS AND ENERGIES'/
     1 3X,4H NO.,8X,6H GNORM,14X,6H SNORM,14X,7H ENERGY/)
   19 FORMAT(2X,I4,5X,3F20.10)
C
      REWIND ITAP12
      READ(ITAP12,1) NATOM,NINT,ESCFZ,IFORCE
      REWIND ITAP13
      READ(ITAP13,2) NSTORE
C
      DO 105 ICASE=1,NPLUS
      IF(ICASE.EQ.NPLUS) GO TO 202
      READ(ITAP13,3) JCASE,ESCF(ICASE)
      GO TO 203
  202 ESCF(ICASE)=ESCFZ
  203 IF(IPRNT.LE.0) GO TO 301
      WRITE(6,4) ICASE,ESCF(ICASE)
  301 CONTINUE
      IF(IPRNT.LE.0) GO TO 302
      WRITE(6,5)
C***READ CARTESIAN COORDINATES OF EACH CASE
  302 DO 102 I=1,NATOM
      IF(ICASE.EQ.NPLUS) GO TO 204
      READ(ITAP13,6) CHG(I),XX(I),YY(I),ZZ(I)
      GO TO 102
  204 READ(ITAP12,6) CHG(I),XX(I),YY(I),ZZ(I)
  102 CONTINUE
C***READ CARTESIAN GRADIENTS OF EACH CASE
      DO 103 I=1,NATOM
      IF(ICASE.EQ.NPLUS) GO TO 205
      READ(ITAP13,6) CHG(I),EX(I),EY(I),EZ(I)
      GO TO 206
  205 READ(ITAP12,6) CHG(I),EX(I),EY(I),EZ(I)
  206 IF(IPRNT.LE.0) GO TO 303
      WRITE(6,7) I,CHG(I),XX(I),YY(I),ZZ(I),EX(I),EY(I),EZ(I)
  303 IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      X(IX,ICASE)=XX(I)
      X(IY,ICASE)=YY(I)
      X(IZ,ICASE)=ZZ(I)
      G(IX,ICASE)=EX(I)
      G(IY,ICASE)=EY(I)
      G(IZ,ICASE)=EZ(I)
  103 CONTINUE
      IF(IPRNT.LE.0) GO TO 304
      CALL DIST(NATOM,XX,YY,ZZ,NDIM)
      WRITE(6,8)
C***READ COORDINATES AND GRADIENTS OF EACH CASE
  304 DO 104 I=1,NINT
      IF(ICASE.EQ.NPLUS) GO TO 207
      READ(ITAP13,9) RCOOD(I),ENGR(I)
      GO TO 208
  207 READ(ITAP12,9) RCOOD(I),ENGR(I)
  208 ENGR(I)=ENGR(I)*FKILO
      IF(IPRNT.LE.0) GO TO 305
      WRITE(6,10) I,RCOOD(I),ENGR(I)
  305 COOD(I,ICASE)=RCOOD(I)
      ENG(I,ICASE)=ENGR(I)
  104 CONTINUE
C   CALCULATE NORM OF GRADIENTS
      CALL ANORM(CNORM,ENGR,MDIM,NINT)
      IF(IPRNT.LE.0) GO TO 306
      WRITE(6,11) CNORM
  306 GNORM(ICASE)=CNORM
  105 CONTINUE
C
      DO 108 ICASE=1,NPLUS
      II=0
      DO 107 I=1,NINT
      DO 106 J=1,NCOOD
      IF(NSET(J).NE.I) GO TO 106
      II=II+1
      ENGR(II)=ENG(I,ICASE)
  106 CONTINUE
  107 CONTINUE
      IF(II.EQ.NCOOD) GO TO 307
      WRITE(6,12) NCOOD,II
      STOP
  307 CONTINUE
      CALL ANORM(CNORM,ENGR,MDIM,NCOOD)
      IF(IPRNT.LE.0) GO TO 308
      WRITE(6,13) ICASE,CNORM
  308 SNORM(ICASE)=CNORM
  108 CONTINUE
C
C   SUMMARY OF INPUT
      IF(IPRNT.LE.0) GO TO 309
      WRITE(6,14)
      CALL MATOUT(X,N3N,NPLUS,N3N,NPLUS,6)
      WRITE(6,15)
      CALL MATOUT(COOD,NINT,NPLUS,NINT,NPLUS,6)
      WRITE(6,16)
      CALL MATOUT(G,N3N,NPLUS,N3N,NPLUS,6)
      WRITE(6,17)
      CALL MATOUT(ENG,NINT,NPLUS,NINT,NPLUS,6)
  309 WRITE(6,18)
      DO 110 ICASE=1,NPLUS
      WRITE(6,19) ICASE,GNORM(ICASE),SNORM(ICASE),ESCF(ICASE)
  110 CONTINUE
C
C   STORE GEOMETRIES AND GRADIENTS IN TAPE13
      REWIND ITAP13
      WRITE(ITAP13,2) NPLUS
      DO 115 ICASE=1,NPLUS
      WRITE(ITAP13,3) ICASE,ESCF(ICASE)
      DO 111 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      XX(I)=X(IX,ICASE)
      YY(I)=X(IY,ICASE)
      ZZ(I)=X(IZ,ICASE)
      WRITE(ITAP13,6) CHG(I),XX(I),YY(I),ZZ(I)
  111 CONTINUE
      DO 112 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      EX(I)=G(IX,ICASE)
      EY(I)=G(IY,ICASE)
      EZ(I)=G(IZ,ICASE)
      WRITE(ITAP13,6) CHG(I),EX(I),EY(I),EZ(I)
  112 CONTINUE
      DO 113 I=1,NINT
      RCOOD(I)=COOD(I,ICASE)
      ENGR(I)=ENG(I,ICASE)*FMILI
      WRITE(ITAP13,9) RCOOD(I),ENGR(I)
  113 CONTINUE
  115 CONTINUE
C
      REWIND ITAP12
      REWIND ITAP13
C
      RETURN
      END
      SUBROUTINE DIST(NATOM,XX,YY,ZZ,NNX)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION XX(NNX),YY(NNX),ZZ(NNX)
      COMMON/COM107/R(1275)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      DATA ZERO / 0.0D+00 /
    1 FORMAT(//,2X,28H INTERATOMIC DISTANCE MATRIX/)
C
      IJ=0
      DO 101 I=1,NATOM
      DO 101 J=1,I
      IJ=IJ+1
      R(IJ)=ZERO
      IF(I.EQ.J) GO TO 101
      XD=XX(I)-XX(J)
      YD=YY(I)-YY(J)
      ZD=ZZ(I)-ZZ(J)
      RR=DSQRT(XD*XD+YD*YD+ZD*ZD)
      R(IJ)=RR
  101 CONTINUE
      WRITE(6,1)
      CALL PRINT(R,LDIM,NATOM,6)
      RETURN
      END
      SUBROUTINE ANGLE(NATOM,XX,YY,ZZ,NNX)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION XX(NNX),YY(NNX),ZZ(NNX)
      COMMON/COM107/R(1275)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      DATA PI / 3.1415926536D+00 /
    1 FORMAT(//,2X,' BOND ANGLES'/
     1 2X,' I   J   K',3X,' DEGREES   ',1X,' J   I   K',3X,' DEGREES  ',
     2 1X,' I   K   J',3X,' DEGREES   '/)
    2 FORMAT(3I4,F11.3, 2X,3I4,F11.3,1X,3I4,F11.3)
    3 FORMAT(//,2X,' BOND ANGLES WILL NOT BE PRINTED---IPRNT .LT. 0 '/)
C
      AR=PI/180.0D+00
      IF(IPRNT.GE.0) WRITE(6,1)
      IF(IPRNT.LT.0) WRITE(6,3)
      DO 101 I=1,NATOM-2
      DO 101 J=I+1,NATOM-1
      IJ=I+J*(J-1)/2
      XIJ=XX(I)-XX(J)
      YIJ=YY(I)-YY(J)
      ZIJ=ZZ(I)-ZZ(J)
      EXIJ=-XIJ/R(IJ)
      EYIJ=-YIJ/R(IJ)
      EZIJ=-ZIJ/R(IJ)
      EXJI=-EXIJ
      EYJI=-EYIJ
      EZJI=-EZIJ
      DO 101 K=J+1,NATOM
      IK=I+K*(K-1)/2
      XIK=XX(I)-XX(K)
      YIK=YY(I)-YY(K)
      ZIK=ZZ(I)-ZZ(K)
      EXIK=-XIK/R(IK)
      EYIK=-YIK/R(IK)
      EZIK=-ZIK/R(IK)
      EXKI=-EXIK
      EYKI=-EYIK
      EZKI=-EZIK
      JK=J+K*(K-1)/2
      XJK=XX(J)-XX(K)
      YJK=YY(J)-YY(K)
      ZJK=ZZ(J)-ZZ(K)
      EXJK=-XJK/R(JK)
      EYJK=-YJK/R(JK)
      EZJK=-ZJK/R(JK)
      EXKJ=-EXJK
      EYKJ=-EYJK
      EZKJ=-EZJK
      AIJK=EXJI*EXJK+EYJI*EYJK+EZJI*EZJK
      AJIK=EXIJ*EXIK+EYIJ*EYIK+EZIJ*EZIK
      AIKJ=EXKI*EXKJ+EYKI*EYKJ+EZKI*EZKJ
      ANGIJK=DACOS(AIJK)/AR
      ANGJIK=DACOS(AJIK)/AR
      ANGIKJ=DACOS(AIKJ)/AR
      IF(IPRNT.GE.0) WRITE(6,2) I,J,K,ANGIJK,J,I,K,ANGJIK,I,K,J,ANGIKJ
  101 CONTINUE
C
      RETURN
      END
      SUBROUTINE ANORM(CNORM,C,NNC,NC)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION C(NNC)
      DATA ZERO / 0.0D+00 /
C
      CNORM=ZERO
      DO 101 I=1,NC
      CNORM=CNORM+C(I)*C(I)
  101 CONTINUE
      CNORM=DSQRT(CNORM)
      RETURN
      END
      SUBROUTINE SORT(SX,SG,SCOOD,SENG,X,G,COOD,ENG)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SX(N3N,NPLUS),SG(N3N,NPLUS),X(N3N,NPLUS),G(N3N,NPLUS)
      DIMENSION SCOOD(NINT,NPLUS),SENG(NINT,NPLUS)
      DIMENSION COOD(NINT,NPLUS),ENG(NINT,NPLUS)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM106/ESCF(150),GNORM(150),SNORM(150)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM110/NSET(150),NORD(150),NXVAR(150)
    1 FORMAT(//,2X,' SORTED CARTESIAN COORDINATE MATRIX'/)
    2 FORMAT(//,2X,' SORTED CARTESIAN GRADIENT MATRIX'/)
    3 FORMAT(//,2X,' SORTED INTERNAL COORDINATE MATRIX'/)
    4 FORMAT(//,2X,' SORTED GRADIENT MATRIX'/)
C
      DO 101 I=1,NPLUS
      NORD(I)=I
  101 CONTINUE
      IF(NPLUS.EQ.1) GO TO 205
      IF(NSORT.EQ.0) GO TO 205
      GO TO (201,202,203),NSORT
C
C   GRADIENT SORT
  201 CALL ORDER(GNORM,NORD,MDIM,NPLUS)
      GO TO 205
C
C   ENERGY SORT
  202 CALL ORDER(ESCF,NORD,MDIM,NPLUS)
      GO TO 205
C
C   SELECTED GRADIENT SORT
  203 CALL ORDER(SNORM,NORD,MDIM,NPLUS)
C
C   NO SORT AND/OR AFTER SORT
  205 II=0
      DO 104 I=1,NPLUS
      II=II+1
      MM=NORD(I)
      DO 102 J=1,NCOOD
      NN=NSET(J)
      SCOOD(J,II)=COOD(NN,MM)
      SENG(J,II)=ENG(NN,MM)
  102 CONTINUE
      DO 103 J=1,N3N
      SX(J,II)=X(J,MM)
      SG(J,II)=G(J,MM)
  103 CONTINUE
  104 CONTINUE
      IF(IPRNT.LE.0) GO TO 206
      WRITE(6,1)
      CALL MATOUT(SX,N3N,NPLUS,N3N,NPLUS,6)
      WRITE(6,2)
      CALL MATOUT(SG,N3N,NPLUS,N3N,NPLUS,6)
  206 CONTINUE
      WRITE(6,3)
      CALL MATOUT(SCOOD,NINT,NPLUS,NCOOD,NPLUS,6)
      WRITE(6,4)
      CALL MATOUT(SENG,NINT,NPLUS,NCOOD,NPLUS,6)
C
      RETURN
      END
      SUBROUTINE ORDER(A,NORD,NND,N)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(NND),NORD(NND)
C
      N1=N-1
      DO 102 I=1,N1
      IR=I+1
      DO 101 J=IR,N
      IF(A(I).GT.A(J)) GO TO 101
      AA=A(I)
      A(I)=A(J)
      A(J)=AA
      NN=NORD(I)
      NORD(I)=NORD(J)
      NORD(J)=NN
  101 CONTINUE
  102 CONTINUE
      RETURN
      END
      SUBROUTINE QUASI(SX,SG,SCOOD,SENG,FC,FT,EE,PIVOT,INDEX)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SX(N3N,NPLUS),SG(N3N,NPLUS)
      DIMENSION SCOOD(NINT,NPLUS),SENG(NINT,NPLUS)
      DIMENSION FC(NCOOD,NCOOD),FT(NCOOD,NCOOD),EE(NCOOD,NCOOD)
      DIMENSION PIVOT(NCOOD),INDEX(NCOOD)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/XT(150)
      COMMON/COM105/ENGR(150),RCOOD(150)
      COMMON/COM107/COEF(1275)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM109/XMAX,YMAX,ZMAX
      COMMON/COM112/XOLD(150),XNEW(150)
      DATA ZERO,ONE / 0.0D+00 , 1.0D+00 /
    1 FORMAT(//,2X,'*************************************'/
     1          2X,'***THE QUASI NEWTON-RAPHSON METHOD***'/
     2          2X,'*************************************'//)
    2 FORMAT(//,2X,' FC MATRIX'/)
    3 FORMAT(//,2X,' INVERSE GRADIENT MATRIX'/)
    4 FORMAT(//,2X,' DETERM = ',D20.10/)
    5 FORMAT(//,2X,' ENG * ENG(-1) = E '/)
C
      WRITE(6,1)
C
C   CALCULATE INVERSE FORCE CONSTANT MATRIX
      DO 101 I=1,NCOOD
      ENGR(I)=SENG(I,NPLUS)
      DO 101 J=1,NCOOD
      JJ=NDIF+J
      FC(I,J)=SENG(I,JJ)
  101 CONTINUE
      IF(IPRNT.LE.0) GO TO 201
      WRITE(6,2)
      CALL MATOUT(FC,NCOOD,NCOOD,NCOOD,NCOOD,6)
  201 CONTINUE
      DO 102 I=1,NCOOD
      DO 102 J=1,NCOOD
  102 FT(I,J)=FC(I,J)
      CALL MATINV(FC,EE,PIVOT,INDEX,NCOOD,NCOOD,DETERM,NCOOD)
      IF(IPRNT.LE.0) GO TO 202
      WRITE(6,3)
      CALL MATOUT(FC,NCOOD,NCOOD,NCOOD,NCOOD,6)
  202 WRITE(6,4) DETERM
C
C   CHECK UNITARITY OF THE INVERTED MATRIX
      CALL MTXMPY(FT,NCOOD,FC,NCOOD,EE,NCOOD,EE,NCOOD,NCOOD,1)
      IF(IPRNT.LE.0) GO TO 203
      WRITE(6,5)
      CALL MATOUT(EE,NCOOD,NCOOD,NCOOD,NCOOD,6)
C
C   ESTIMATE NEW GEOMETRY
  203 DO 103 I=1,NCOOD
      COEF(I)=ZERO
      DO 103 J=1,NCOOD
      COEF(I)=COEF(I)+FC(I,J)*ENGR(J)
  103 CONTINUE
      DO 104 I=1,N3N
      XT(I)=ZERO
      DO 104 J=1,NCOOD
      JJ=NDIF+J
      XT(I)=XT(I)+SX(I,JJ)*COEF(J)
  104 CONTINUE
      SUM=ZERO
      DO 105 I=1,NCOOD
      SUM=SUM+COEF(I)
  105 CONTINUE
      FACT=ONE/(SUM-ONE)
C
      DO 106 I=1,N3N
      XOLD(I)=SX(I,NPLUS)
      XNEW(I)=(XT(I)-XOLD(I))*FACT
  106 CONTINUE
      IFLAG=1
      CALL OLDNEW(XOLD,XNEW,IFLAG)
C
      RETURN
      END
      SUBROUTINE FESTIM(SCOOD,SENG,FC,DELC,FF,DELG,EE,PIVOT,INDEX)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SCOOD(NINT,NPLUS),SENG(NINT,NPLUS)
      DIMENSION FC(NCOOD,NCOOD),DELC(NCOOD,NCOOD),FF(NCOOD,NCOOD)
      DIMENSION DELG(NCOOD,NCOOD),EE(NCOOD,NCOOD)
      DIMENSION PIVOT(NCOOD),INDEX(NCOOD)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      DATA HALF / 0.5D+00 /
      DATA FKILO / 1.0D+3 /
    1 FORMAT(//,2X,' DELC MATRIX'/)
    2 FORMAT(//,2X,' DELG MATRIX'/)
    3 FORMAT(//,2X,' INVERSE DELC MATRIX'/)
    4 FORMAT(//,2X,' DETERM = ',D20.10/)
    5 FORMAT(//,2X,' DELC * DELC(-1) = E '/)
    6 FORMAT(//,2X,' ESTIMATED FORCE CONSTANT MATRIX'/)
    7 FORMAT(//,2X,' AVERAGED FORCE CONSTANT MATRIX'/)
C
C   ESTIMATE FORCE CONSTANT MATRIX
      DO 101 I=1,NCOOD
      DO 101 J=1,NCOOD
      JJ=NDIF+J
      DELC(I,J)=SCOOD(I,JJ)-SCOOD(I,NPLUS)
      DELC(I,J)=DELC(I,J)*FKILO
  101 CONTINUE
      IF(IPRNT.LE.0) GO TO 201
      WRITE(6,1)
      CALL MATOUT(DELC,NCOOD,NCOOD,NCOOD,NCOOD,6)
  201 DO 102 I=1,NCOOD
      DO 102 J=1,NCOOD
      JJ=NDIF+J
      DELG(I,J)=SENG(I,JJ)-SENG(I,NPLUS)
  102 CONTINUE
      IF(IPRNT.LE.0) GO TO 202
      WRITE(6,2)
      CALL MATOUT(DELG,NCOOD,NCOOD,NCOOD,NCOOD,6)
  202 DO 103 I=1,NCOOD
      DO 103 J=1,NCOOD
      FC(I,J)=DELC(I,J)
  103 CONTINUE
      CALL MATINV(FC,EE,PIVOT,INDEX,NCOOD,NCOOD,DETERM,NCOOD)
      IF(IPRNT.LE.0) GO TO 203
      WRITE(6,3)
      CALL MATOUT(FC,NCOOD,NCOOD,NCOOD,NCOOD,6)
  203 WRITE(6,4) DETERM
      CALL MTXMPY(DELC,NCOOD,FC,NCOOD,EE,NCOOD,EE,NCOOD,NCOOD,1)
      IF(IPRNT.LE.0) GO TO 204
      WRITE(6,5)
      CALL MATOUT(EE,NCOOD,NCOOD,NCOOD,NCOOD,6)
  204 CALL MTXMPY(FC,NCOOD,DELG,NCOOD,FF,NCOOD,EE,NCOOD,NCOOD,4)
      IF(IPRNT.LE.0) GO TO 205
      WRITE(6,6)
      CALL MATOUT(FF,NCOOD,NCOOD,NCOOD,NCOOD,6)
  205 DO 104 I=1,NCOOD
      DO 104 J=I,NCOOD
      EE(I,J)=(FF(I,J)+FF(J,I))*HALF
      IF(I.EQ.J) GO TO 104
      EE(J,I)=EE(I,J)
  104 CONTINUE
      WRITE(6,7)
      CALL MATOUT(EE,NCOOD,NCOOD,NCOOD,NCOOD,6)
C
      RETURN
      END
      SUBROUTINE OLDNEW(XOLD,XNEW,IFLAG)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION XOLD(150),XNEW(150)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/XT(50),YT(50),ZT(50)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM109/XMAX,YMAX,ZMAX
      DATA ZERO / 0.0D+00 /
    1 FORMAT(//,2X,' OLD COORDINATES'/
     1 38X,' OLD X IN A.U.'/
     2 3X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
    2 FORMAT(3X,I5,4F16.10)
    3 FORMAT(//,2X,' NEW COORDINATES'/
     1 38X,' NEW X IN A.U.'/
     2 3X,4H NO.,4X,7H CHARGE,9X,2H X,14X,2H Y,14X,2H Z/)
C
      WRITE(6,1)
      XMAX=ZERO
      YMAX=ZERO
      ZMAX=ZERO
      DO 101 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      IF(IFLAG.EQ.0) GO TO 201
      XDIF=XNEW(IX)-XOLD(IX)
      YDIF=XNEW(IY)-XOLD(IY)
      ZDIF=XNEW(IZ)-XOLD(IZ)
      IF(DABS(XDIF).GT.DABS(XMAX)) XMAX=XDIF
      IF(DABS(YDIF).GT.DABS(YMAX)) YMAX=YDIF
      IF(DABS(ZDIF).GT.DABS(ZMAX)) ZMAX=ZDIF
  201 CONTINUE
      WRITE(6,2) I,CHG(I),XOLD(IX),XOLD(IY),XOLD(IZ)
  101 CONTINUE
      WRITE(6,3)
      DO 102 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      WRITE(6,2) I,CHG(I),XNEW(IX),XNEW(IY),XNEW(IZ)
  102 CONTINUE
C
      DO 103 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      XT(I)=XNEW(IX)
      YT(I)=XNEW(IY)
      ZT(I)=XNEW(IZ)
  103 CONTINUE
C
C   CALCULATE INTERATOMIC DISTANCES FOR NEXT GEOMETRY
      CALL DIST(NATOM,XT,YT,ZT,NDIM)
      IF(NATOM.LE.2) GO TO 202
      CALL ANGLE(NATOM,XT,YT,ZT,NDIM)
C
  202 CONTINUE
      IF(IFLAG.EQ.0) GO TO 203
      DO 104 I=1,NATOM
      XX(I)=XT(I)
      YY(I)=YT(I)
      ZZ(I)=ZT(I)
  104 CONTINUE
C
  203 CONTINUE
      RETURN
      END
      SUBROUTINE METRIC(SX,SG,FX,HH,FT,EE,PIVOT,INDEX,NVAR,METHOD,
     1                  IHESS,UPDATE)
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL UPDATE
      DIMENSION SX(N3N,NPLUS),SG(N3N,NPLUS),FX(N3N,N3N)
      DIMENSION HH(NVAR,NVAR),FT(NVAR,NVAR),EE(NVAR,NVAR)
      DIMENSION PIVOT(NVAR),INDEX(NVAR)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/XT(150)
      COMMON/COM105/ENG0(150),ENG1(150)
      COMMON/COM106/ESCF(150),GNORM(150),SNORM(150)
      COMMON/COM107/X(150),D(150),DELX(150),DELG(150),HG(150),DUMA(525)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM110/NSET(150),NORD(150),NXVAR(150)
      COMMON/COM112/XOLD(150),XNEW(150)
      DATA ITAP15 / 15 /
      DATA ZERO,ONE / 0.0D+00 , 1.0D+00 /
    1 FORMAT(//,2X,'********************************'/
     1          2X,'***THE VARIABLE METRIC METHOD***'/
     2          2X,'********************************'//)
    2 FORMAT(2I5)
    3 FORMAT(3F20.10)
    4 FORMAT(//,2X,' FX MATRIX'/)
    5 FORMAT(//,2X,' EXTRACTED FX MATRIX'/)
    6 FORMAT(//,2X,' HH MATRIX'/)
    7 FORMAT(//,2X,' DETERM = ',D20.10/)
    8 FORMAT(//,2X,' FX * FX(-1) = E'/)
    9 FORMAT(///,2X,' ALGOR CYCLE = ',I5)
   10 FORMAT(//,2X,13H NEW X MATRIX/
     1 2X,4H NO.,5X,4H II.,6X,5H OLDX,18X,5H DELX,18X,5H NEWX/)
   11 FORMAT(3X,I2,4X,I5,3(3X,F20.10))
   12 FORMAT(//,2X,20H DELG AND HG VECTORS/)
   13 FORMAT(2X,I2,2(5X,F15.8))
   14 FORMAT(//,2X,7H GHG = ,F15.8/
     1 2X,7H DG  = ,F15.8)
   15 FORMAT(//,2X,' UPDATED H MATRIX'/)
   16 FORMAT(//,2X,' GEOMETRY CHANGE IS TOO LARGE---TRY AGAIN'/
     1          2X,' NALGOR,NMAX,NADD,XMAX = ',3I5,F10.5/)
   17 FORMAT(//,2X,' SUBROUTINE METRIC IS NOT ABLE TO FIND A RESONABLE
     1GEOMETRY GUESS'/)
C
      WRITE(6,1)
C
      XLIMIT=0.5D+00
      NADD=0
      NMAX=NPLUS
  200 CONTINUE
      IF(IHESS.EQ.0) GO TO 201
      REWIND ITAP15
      READ(ITAP15,2) NNATOM,NNC
      READ(ITAP15,3) ((FX(I,J),J=1,N3N),I=1,N3N)
      REWIND ITAP15
      GO TO 202
C
C   UNIT MATRIX AS AN INITIAL HESSIAN
  201 CONTINUE
      DO 101 I=1,N3N
      FX(I,I)=ONE
      DO 101 J=1,N3N
      IF(I.EQ.J) GO TO 101
      FX(I,J)=ZERO
  101 CONTINUE
C
  202 CONTINUE
      IF(IPRNT.LE.0) GO TO 203
      WRITE(6,4)
      CALL MATOUT(FX,N3N,N3N,N3N,N3N,6)
C
  203 CONTINUE
      DO 102 I=1,NVAR
      II=NXVAR(I)
      DO 102 J=1,NVAR
      JJ=NXVAR(J)
      HH(I,J)=FX(II,JJ)
      FT(I,J)=HH(I,J)
  102 CONTINUE
      IF(IPRNT.LE.0) GO TO 204
      WRITE(6,5)
      CALL MATOUT(HH,NVAR,NVAR,NVAR,NVAR,6)
  204 CONTINUE
      CALL MATINV(HH,EE,PIVOT,INDEX,NVAR,NVAR,DETERM,NVAR)
      IF(IPRNT.LE.0) GO TO 205
      WRITE(6,6)
      CALL MATOUT(HH,NVAR,NVAR,NVAR,NVAR,6)
  205 WRITE(6,7) DETERM
      IF(IPRNT.LE.0) GO TO 206
      CALL MTXMPY(FT,NVAR,HH,NVAR,EE,NVAR,EE,NVAR,NVAR,1)
      WRITE(6,8)
      CALL MATOUT(EE,NVAR,NVAR,NVAR,NVAR,6)
C
  206 CONTINUE
      DO 103 I=1,N3N
      X(I)=SX(I,NPLUS)
      XT(I)=X(I)
  103 CONTINUE
C
      NALGOR=1
      NPOS=NALGOR+NADD
      DO 104 I=1,NVAR
      II=NXVAR(I)
      ENG0(I)=SG(II,NPOS)
  104 CONTINUE
C
C   START ITERATION
  300 CONTINUE
      IF(IPRNT.LE.0) GO TO 301
      WRITE(6,9) NALGOR
C
C   CALCULATE D VECTOR
  301 DO 105 I=1,NVAR
      D(I)=ZERO
      DO 105 J=1,NVAR
      D(I)=D(I)-HH(I,J)*ENG0(J)
  105 CONTINUE
C
C   FIND ALPHA
      CALL INTER(ALPHA,D,ENG0,MDIM,NVAR)
C
C   ESTIMATE NEW COORDINATES
      IF(IPRNT.LE.0) GO TO 302
      WRITE(6,10)
  302 CONTINUE
      XMAX=ZERO
      DO 106 I=1,NVAR
      II=NXVAR(I)
      X00=X(II)
      DELX(I)=ALPHA*D(I)
      DMAX=DABS(DELX(I))
      IF(DMAX.GT.XMAX) XMAX=DMAX
      X11=X00+DELX(I)
      XT(II)=X11
      IF(IPRNT.LE.0) GO TO 106
      WRITE(6,11) I,II,X00,DELX(I),X11
  106 CONTINUE
C
      IF(XMAX.GT.XLIMIT) GO TO 310
      NALGOR=NALGOR+1
      NPOS=NALGOR+NADD
      IF(NALGOR.GT.NMAX) GO TO 320
      DO 107 I=1,NVAR
      II=NXVAR(I)
      ENG1(I)=SG(II,NPOS)
  107 CONTINUE
C
C   CALCULATION OF HH MATRIX FOR NEXT ITERATION
      DO 108 I=1,NVAR
      DELG(I)=ENG1(I)-ENG0(I)
  108 CONTINUE
C
      IF(METHOD-2) 401,403,405
C
C::::::::::::::::::::::::::::
C:::MURTAGH-SARGENT METHOD:::
C::::::::::::::::::::::::::::
  401 DO 110 I=1,NVAR
      HG(I)=DELX(I)
      DO 110 J=1,NVAR
      HG(I)=HG(I)-HH(I,J)*DELG(J)
  110 CONTINUE
      IF(IPRNT.LE.0) GO TO 402
      WRITE(6,12)
      DO 111 I=1,NVAR
      WRITE(6,13) I,DELG(I),HG(I)
  111 CONTINUE
  402 GHG=ZERO
      DG=ZERO
      DO 112 I=1,NVAR
      GHG=GHG+HG(I)*DELG(I)
      DG=DG+HG(I)*HG(I)
  112 CONTINUE
      DO 113 I=1,NVAR
      DO 113 J=1,NVAR
      HH(I,J)=HH(I,J)+(HG(I)*HG(J))/GHG
  113 CONTINUE
      IF(IPRNT.LE.0) GO TO 410
      WRITE(6,14) GHG,DG
      GO TO 410
C
C:::::::::::::::::::::
C:::FLETCHER METHOD:::
C:::::::::::::::::::::
  403 DO 120 I=1,NVAR
      HG(I)=ZERO
      DO 120 J=1,NVAR
      HG(I)=HG(I)+HH(I,J)*DELG(J)
  120 CONTINUE
      IF(IPRNT.LE.0) GO TO 404
      WRITE(6,12)
      DO 121 I=1,NVAR
      WRITE(6,13) I,DELG(I),HG(I)
  121 CONTINUE
  404 GHG=ZERO
      DG=ZERO
      DO 122 I=1,NVAR
      GHG=GHG+HG(I)*DELG(I)
      DG=DG+DELX(I)*DELG(I)
  122 CONTINUE
      DO 123 I=1,NVAR
      DO 123 J=1,NVAR
      HH(I,J)=HH(I,J)-(HG(I)*DELX(J)+HG(J)*DELX(I))/DG
     1 +(ONE+GHG/DG)*((DELX(I)*DELX(J))/DG)
  123 CONTINUE
      IF(IPRNT.LE.0) GO TO 410
      WRITE(6,14) GHG,DG
      GO TO 410
C
C::::::::::::::::::::::::::::::::::::
C:::DAVIDON-FLETCHER-POWELL METHOD:::
C::::::::::::::::::::::::::::::::::::
  405 DO 130 I=1,NVAR
      HG(I)=ZERO
      DO 130 J=1,NVAR
      HG(I)=HG(I)+HH(I,J)*DELG(J)
  130 CONTINUE
      IF(IPRNT.LE.0) GO TO 406
      WRITE(6,12)
      DO 131 I=1,NVAR
      WRITE(6,13) I,DELG(I),HG(I)
  131 CONTINUE
  406 GHG=ZERO
      DG=ZERO
      DO 132 I=1,NVAR
      GHG=GHG+HG(I)*DELG(I)
      DG=DG+DELX(I)*DELG(I)
  132 CONTINUE
      DO 133 I=1,NVAR
      DO 133 J=1,NVAR
      HH(I,J)=HH(I,J)-(HG(I)*HG(J))/GHG+(DELX(I)*DELX(J))/DG
  133 CONTINUE
      IF(IPRNT.LE.0) GO TO 410
      WRITE(6,14) GHG,DG
C
C#####################
C###UPDATE H MATRIX###
C#####################
  410 CONTINUE
      IF(IPRNT.LE.0) GO TO 415
      WRITE(6,15)
      CALL MATOUT(HH,NVAR,NVAR,NVAR,NVAR,6)
C
  415 DO 135 I=1,NVAR
      ENG0(I)=ENG1(I)
  135 CONTINUE
      GO TO 300
C
C   GEOMETRY CHANGE IS TOO LARGE
  310 CONTINUE
      WRITE(6,16) NALGOR,NMAX,NADD,XMAX
      NMAX=NMAX-1
      NADD=NADD+1
      IF(NMAX.LE.0) GO TO 315
      GO TO 200
C
C   YOU CANNOT FIND NEXT GEOMETRY
  315 WRITE(6,17)
      RETURN
C
  320 CONTINUE
      DO 136 I=1,N3N
      XOLD(I)=SX(I,NPLUS)
      XNEW(I)=XT(I)
  136 CONTINUE
      IFLAG=0
      IF(UPDATE) IFLAG=1
      CALL OLDNEW(XOLD,XNEW,IFLAG)
C
      RETURN
      END
      SUBROUTINE INTER(ALPHA,D,ENG0,NND,NN)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION D(NND),ENG0(NND)
      DATA ZERO,ONE,TWO / 0.0D+00 , 1.0D+00 , 2.0D+00 /
      DATA FDEL / 1.0D+00 /
C
      GXS=ZERO
      DO 101 I=1,NN
      GXS=GXS+D(I)*ENG0(I)
  101 CONTINUE
      FX0=-(TWO*FDEL)/GXS
      ALPHA=DMIN1(ONE,FX0)
      RETURN
      END
      SUBROUTINE AGHESS(SX,SG,FX,ELX,EE,FT,VALU,EIGN,FV1,FV2,FC,
     1                  N3N1,N3NTRI)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SX(N3N,NPLUS),SG(N3N,NPLUS),FX(N3N,N3N)
      DIMENSION ELX(N3N1,N3N1),EE(N3N1,N3N1),FT(N3N1,N3N1)
      DIMENSION VALU(N3N1),EIGN(N3N1),FV1(N3N1),FV2(N3N1),FC(N3NTRI)
      COMMON/COM101/NATOM,N3N,NINT
      COMMON/COM102/NSORT,NCOOD,NDIF,NPLUS,NCASE,NROOT
      COMMON/COM103/CHG(50),XX(50),YY(50),ZZ(50)
      COMMON/COM104/EX(50),EY(50),EZ(50)
      COMMON/COM107/AGX(150),AGENG(150),DELX(150),DUMA(825)
      COMMON/COM108/LDIM,MDIM,NDIM,IPRNT
      COMMON/COM112/XOLD(150),XNEW(150)
      DATA ITAP15 / 15 /
      DATA DLIMIT / 1.0D-06 /
      DATA ZERO / 0.0D+00 /
    1 FORMAT(//,2X,'**********************************'/
     1          2X,'***THE AUGMENTED HESSIAN METHOS***'/
     2          2X,'**********************************'//)
    2 FORMAT(2I5)
    3 FORMAT(3F20.10)
    4 FORMAT(//,2X,' HESSIAN MATRIX'/)
    5 FORMAT(//,2X,' HESSIAN MATRIX IN TRIANGULAR FORM'/)
    6 FORMAT(//,2X,' EIGENVALUES'/)
    7 FORMAT(2X,I5,F20.10)
    8 FORMAT(//,2X,' EIGENVECTORS '/)
    9 FORMAT(//,2X,' ELX * ELX(-1) = 1'/)
   10 FORMAT(//,2X,' U(-1) * FX * U = FT'/)
   11 FORMAT(//,2X,' AUGMENTED HESSIAN MATRIX'/)
   12 FORMAT(//,2X,' AUGMENTED HESSIAN MATRIX IN TRIANGLE FORM'/)
   13 FORMAT(//,2X,' ELT * ELT(-1) = 1'/)
   14 FORMAT(//,2X,' AUGMENTED X MATRIX'/)
   15 FORMAT(2X,I5,2F20.10)
   16 FORMAT(//,2X,' DELX MATRIX'/)
C
      WRITE(6,1)
C
      REWIND ITAP15
      READ(ITAP15,2) NNATOM,NNC
      READ(ITAP15,3) ((FX(I,J),J=1,N3N),I=1,N3N)
      REWIND ITAP15
      IF(IPRNT.LE.0) GO TO 201
      WRITE(6,4)
      CALL MATOUT(FX,N3N,N3N,N3N,N3N,6)
C
C   DIAGONALIZE HESSIAN MATRIX
  201 CONTINUE
      IJ=0
      DO 101 I=1,N3N
      DO 101 J=1,I
      IJ=IJ+1
      FC(IJ)=FX(I,J)
  101 CONTINUE
      IF(IPRNT.LE.0) GO TO 202
      WRITE(6,5)
      CALL PRINT(FC,N3NTRI,N3N,6)
  202 CONTINUE
      CALL RSP(N3N1,N3N,N3NTRI,FC,VALU,1,ELX,FV1,FV2)
      IF(IPRNT.LE.0) GO TO 203
      WRITE(6,6)
      DO 102 I=1,N3N
  102 WRITE(6,7) I,VALU(I)
      WRITE(6,8)
      CALL MATOUT(ELX,N3N1,N3N1,N3N,N3N,6)
      CALL MTXMPY(ELX,N3N1,ELX,N3N1,EE,N3N1,EE,N3N1,N3N,3)
      WRITE(6,9)
      CALL MATOUT(EE,N3N1,N3N1,N3N,N3N,6)
C
C   UNITARY ROTATION OF FX MATRIX FOR A TEST
      CALL MTXMPY(ELX,N3N1,FX,N3N,FT,N3N1,EE,N3N1,N3N,5)
      WRITE(6,10)
      CALL MATOUT(FT,N3N1,N3N1,N3N,N3N,6)
C
  203 CONTINUE
      DO 103 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      EX(I)=SG(IX,NPLUS)
      EY(I)=SG(IY,NPLUS)
      EZ(I)=SG(IZ,NPLUS)
  103 CONTINUE
      DO 104 I=1,N3N1
      DO 104 J=1,N3N1
  104 FT(I,J)=ZERO
      DO 105 I=2,N3N1
  105 FT(I,I)=VALU(I-1)
      DO 107 I=1,N3N
      VAL=ZERO
      DO 106 J=1,NATOM
      JX=(J-1)*3+1
      JY=JX+1
      JZ=JX+2
      VAL=VAL+ELX(JX,I)*EX(J)+ELX(JY,I)*EY(J)+ELX(JZ,I)*EZ(J)
  106 CONTINUE
      AGENG(I)=VAL
      FT(I+1,1)=VAL
      FT(1,I+1)=VAL
  107 CONTINUE
      IF(IPRNT.LE.0) GO TO 204
      WRITE(6,11)
      CALL MATOUT(FT,N3N1,N3N1,N3N1,N3N1,6)
C
  204 CONTINUE
      IJ=0
      DO 108 I=1,N3N1
      DO 108 J=1,I
      IJ=IJ+1
      FC(IJ)=FT(I,J)
  108 CONTINUE
      IF(IPRNT.LE.0) GO TO 205
      WRITE(6,12)
      CALL PRINT(FC,N3NTRI,N3N1,6)
  205 CONTINUE
      CALL RSP(N3N1,N3N1,N3NTRI,FC,EIGN,1,ELX,FV1,FV2)
      WRITE(6,6)
      DO 109 I=1,N3N1
  109 WRITE(6,7) I,EIGN(I)
      IF(IPRNT.LE.0) GO TO 206
      WRITE(6,8)
      CALL MATOUT(ELX,N3N1,N3N1,N3N1,N3N1,6)
      CALL MTXMPY(ELX,N3N1,ELX,N3N1,EE,N3N1,EE,N3N1,N3N1,3)
      WRITE(6,13)
      CALL MATOUT(EE,N3N1,N3N1,N3N1,N3N1,6)
C
C   ESTIMATE NEXT GEOMETRY
      WRITE(6,14)
  206 DO 110 I=1,N3N
      AGX(I)=ZERO
      DEN=VALU(I)-EIGN(NROOT)
      IF(DABS(DEN).LE.DLIMIT) GO TO 207
      AGX(I)=-AGENG(I)/DEN
  207 IF(IPRNT.LE.0) GO TO 110
      WRITE(6,15) I,DEN,AGX(I)
  110 CONTINUE
      IF(IPRNT.LE.0) GO TO 208
      WRITE(6,16)
  208 DO 112 I=1,N3N
      VAL=ZERO
      DO 111 J=1,N3N
  111 VAL=VAL+ELX(I,J)*AGX(J)
      DELX(I)=VAL
      IF(IPRNT.LE.0) GO TO 112
      WRITE(6,15) I,VAL
  112 CONTINUE
      DO 113 I=1,NATOM
      IX=(I-1)*3+1
      IY=IX+1
      IZ=IX+2
      X0=SX(IX,NPLUS)
      Y0=SX(IY,NPLUS)
      Z0=SX(IZ,NPLUS)
      XNEW(IX)=X0+DELX(IX)
      XNEW(IY)=Y0+DELX(IY)
      XNEW(IZ)=Z0+DELX(IZ)
  113 CONTINUE
      IFLAG=0
      CALL OLDNEW(XOLD,XNEW,IFLAG)
C
      RETURN
      END
      SUBROUTINE MTXMPY(A,NAD,B,NBD,C,NCD,D,NDD,N,IMPY)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(NAD,NAD),B(NBD,NBD),C(NCD,NCD),D(NDD,NDD)
      DATA ZERO / 0.0D+00 /
C
      DO 101 I=1,NCD
      DO 101 J=1,NCD
  101 C(I,J)=ZERO
      GO TO (201,202,203,204,205,206),IMPY
C     C=A*B
  201 DO 102 I=1,N
      DO 102 J=1,N
      DO 102 K=1,N
  102 C(I,J)=C(I,J)+A(I,K)*B(K,J)
      RETURN
C     C=TA*B
  202 DO 103 I=1,N
      DO 103 J=1,N
      DO 103 K=1,N
  103 C(I,J)=C(I,J)+A(K,I)*B(K,J)
      RETURN
C     C=A*TB
  203 DO 104 I=1,N
      DO 104 J=1,N
      DO 104 K=1,N
  104 C(I,J)=C(I,J)+A(I,K)*B(J,K)
      RETURN
C     C=TA*TB
  204 DO 105 I=1,N
      DO 105 J=1,N
      DO 105 K=1,N
  105 C(I,J)=C(I,J)+A(K,I)*B(J,K)
      RETURN
C     C=TA*B*A
  205 DO 106 I=1,N
      DO 106 J=1,N
      D(I,J)=ZERO
      DO 106 K=1,N
  106 D(I,J)=D(I,J)+A(K,I)*B(K,J)
      DO 107 I=1,N
      DO 107 J=1,N
      DO 107 K=1,N
  107 C(I,J)=C(I,J)+D(I,K)*A(K,J)
      RETURN
C     C=A*B*TA
  206 DO 108 I=1,N
      DO 108 J=1,N
      D(I,J)=ZERO
      DO 108 K=1,N
  108 D(I,J)=D(I,J)+A(I,K)*B(K,J)
      DO 109 I=1,N
      DO 109 J=1,N
      DO 109 K=1,N
  109 C(I,J)=C(I,J)+D(I,K)*A(J,K)
      RETURN
      END
      PROGRAM INTCOS
C  THE CARTESIAN-INTERNAL COORDINATE CONVERSION PROGRAM
C**********************************************************
C***LAST UPDATED ON FEBRUARY 06, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C   THIS PROGRAM CAN TREAT MOLECULES WITH '50' ATOMS
C   DIMENSION STATEMENTS
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION CC(360000),IA(1)
      DIMENSION I30(200),COORD(3,50),GRAD(3,50)
C   COMMON STATEMENTS
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB102/ESCF
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB104/IFORCE,IGRAD,IATOM,ICOOD,IPRNT
      COMMON/VIB201/CHG(50),X(50),Y(50),Z(50)
      COMMON/VIB202/R(1275)
      COMMON/VIB203/ENGX(50),ENGY(50),ENGZ(50)
      COMMON/VIB204/RINT(150),ENGR(150)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB301/KR(150),LR(150)
      COMMON/VIB302/KA(150),LA(150),MA(150),AGLB(150)
      COMMON/VIB303/KB(100),LB(100),MB(100),AGLL(100)
      COMMON/VIB304/KD(100),LD(100),MD(100),ND(100)
      COMMON/VIB305/KT(100),LT(100),MT(100),NT(100)
      COMMON/VIB306/AGLT(100),AGLO(100),AGLR(100)
      COMMON/VIB307/AGLD(100),AGLE(100),AGLF(100)
      EQUIVALENCE (CC,IA)
C   FORMAT STATEMENTS
    1 FORMAT(//,2X,' THE INTERNAL ENERGY GRADIENT PROGRAM'//)
    2 FORMAT(16I5)
    3 FORMAT(3X,20A4)
    4 FORMAT(//,2X,' NATOM = ',I5/
     1 2X,' SCF ENERGY = ',F20.10)
    5 FORMAT(//,2X,' MOLECULAR GEOMETRY'/
     1 5X,4H NO.,11X,7H CHARGE,13X,2H X,18X,2H Y,18X,2H Z/)
    6 FORMAT(2X,I7,5X,4F20.10)
    7 FORMAT(//,2X,' CARTESIAN ENERGY GRADIENTS'/
     1 5X,4H NO.,11X,7H CHARGE,13X,2H X,18X,2H Y,18X,2H Z/)
    8 FORMAT(I5,F20.10)
    9 FORMAT(4F20.10)
   10 FORMAT(20A4)
C
      call drum
c
c     CALL TSTART(6)
C
      INPUT=5
      ITAPE6=6
      ITAP11=11
      ITAP13=13
      ITAP30=30
      MAXCOR=360000
C
      CALL LOCATE(INPUT,'# INTCOS #',IERR)
C
      IOFF(1)=0
      DO 101 I=1,149
      IOFF(I+1)=IOFF(I)+I
  101 CONTINUE
      WRITE(6,1)
      READ(5,2) NST,NBND,NLIB,NDEF,NTORS,IFORCE,IGRAD,IATOM,ICOOD,
     1          IPRNT
      IF(IGRAD.NE.0) GO TO 201
C
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I30,200,101,JUNK)
      IEND=I30(1)
      MPOINT=I30(2)
      MCONST=I30(3)
      MCALCS=I30(4)
      NCALCS=I30(5)
      NATOM=I30(19)
      NAT1=NATOM-1
      N3N=NATOM*3
      JUNK=101+MCONST
      CALL WREADW(ITAP30,IPT,1,JUNK,JUNK)
      CALL WREADW(ITAP30,CHG,INTOWP(NATOM),IPT,JUNK)
      IGEOP=100+MCONST+MPOINT+NCALCS
      CALL WREADW(ITAP30,LOCCAL,1,IGEOP,JUNK)
      CALL WREADW(ITAP30,I30,20,LOCCAL,JUNK)
      WRITE(6,3) (I30(I),I=1,20)
      IGEOP=LOCCAL+60
      CALL WREADW(ITAP30,I30,20,IGEOP,IGEOP)
      CALL WREADW(ITAP30,COORD,intowp(N3N),IGEOP,JUNK)
      JUNK=JUNK+INTOWP(1)
      CALL WREADW(ITAP30,ESCF,intowp(1),JUNK,JUNK)
      JUNK=I30(2)
      CALL WREADW(ITAP30,GRAD,intowp(N3N),JUNK,JUNK)
      WRITE(6,4) NATOM,ESCF
      WRITE(6,5)
      DO 102 I=1,NATOM
      X(I)=COORD(1,I)
      Y(I)=COORD(2,I)
      Z(I)=COORD(3,I)
      WRITE(6,6) I,CHG(I),X(I),Y(I),Z(I)
  102 CONTINUE
      CALL DIST(IPRNT)
      WRITE(6,7)
      DO 103 I=1,NATOM
      ENGX(I)=GRAD(1,I)
      ENGY(I)=GRAD(2,I)
      ENGZ(I)=GRAD(3,I)
      WRITE(6,6) I,CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  103 CONTINUE
      GO TO 203
C
  201 CONTINUE
      NTAPE=IGRAD/100
      IF(NTAPE.EQ.13) GO TO 202
      NSETS=MOD(IGRAD,100)
      IF(NSETS.EQ.0) NSETS=IGRAD
      REWIND ITAP11
      DO 106 II=1,NSETS
      READ(ITAP11,10) (I30(I),I=1,20)
      READ(ITAP11,8) NATOM,ESCF
      DO 104 I=1,NATOM
      READ(ITAP11,9) CHG(I),X(I),Y(I),Z(I)
  104 CONTINUE
      DO 105 I=1,NATOM
      READ(ITAP11,9) CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  105 CONTINUE
  106 CONTINUE
      WRITE(6,3) (I30(I),I=1,20)
      WRITE(6,4) NATOM,ESCF
      NAT1=NATOM-1
      N3N=NATOM*3
      WRITE(6,5)
      DO 107 I=1,NATOM
      WRITE(6,6) I,CHG(I),X(I),Y(I),Z(I)
  107 CONTINUE
      CALL DIST(IPRNT)
      WRITE(6,7)
      DO 108 I=1,NATOM
      WRITE(6,6) I,CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  108 CONTINUE
      GO TO 203
C
  202 CONTINUE
      NSETS=MOD(IGRAD,100)
      REWIND ITAP13
      NATOM=IATOM
      READ(ITAP13,2) NSTORE
      DO 113 II=1,NSETS
      READ(ITAP13,8) NUM,ESCF
      DO 110 I=1,NATOM
      READ(ITAP13,9) CHG(I),X(I),Y(I),Z(I)
  110 CONTINUE
      DO 111 I=1,NATOM
      READ(ITAP13,9) CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  111 CONTINUE
      DO 112 I=1,ICOOD
      READ(ITAP13,9) RR,GR
  112 CONTINUE
  113 CONTINUE
      WRITE(6,4) NATOM,ESCF
      NAT1=NATOM-1
      N3N=NATOM*3
      WRITE(6,5)
      DO 114 I=1,NATOM
      WRITE(6,6) I,CHG(I),X(I),Y(I),Z(I)
  114 CONTINUE
      CALL DIST(IPRNT)
      WRITE(6,7)
      DO 115 I=1,NATOM
      WRITE(6,6) I,CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  115 CONTINUE
C
  203 CONTINUE
C   NINT IS NUMBER OF INTERNAL COORDINATES
      NINT=NST+NBND+NLIB+NDEF+NTORS
      NMAX=MAX0(NINT,N3N)
      NMAXSQ=NMAX*NMAX
      NATOM2=NATOM*NATOM
      IC1=1
      IC2=IC1+NMAXSQ
      IC3=IC2+NMAXSQ
      IC4=IC3+NMAXSQ
      IC5=IC4+NMAXSQ
      IC6=IC5+NMAXSQ
      IC7=IC6+NMAX
      IA7=IC7*2-1
      IC8=IC7+NMAX
      IC9=IC8+NATOM2
      IC10=IC9+NATOM2
      ICMAX=IC10+NATOM2
C................B       BIN     AA      BB      FX      FF......
      CALL VIBGF(CC(IC1),CC(IC2),CC(IC3),CC(IC4),CC(IC5),CC(IC5),
C................PIVOT   INDEX   EX      EY      EZ............
     1           CC(IC6),IA(IA7),CC(IC8),CC(IC9),CC(IC10),NMAX)
C
c     CALL TSTOP(6)
      STOP
      END
      SUBROUTINE DIST(IPRNT)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB201/CHG(50),X(50),Y(50),Z(50)
      COMMON/VIB202/R(1275)
      DATA ZERO / 0.0D+00 /
      DATA LDIM / 1275 /
    1 FORMAT(//,2X,' INTERATOMIC DISTANCE MATRIX'/)
C
      IJ=0
      DO 101 I=1,NATOM
      DO 101 J=1,I
      IJ=IJ+1
      R(IJ)=ZERO
      IF(I.EQ.J) GO TO 101
      XD=X(I)-X(J)
      YD=Y(I)-Y(J)
      ZD=Z(I)-Z(J)
      R(IJ)=DSQRT(XD*XD+YD*YD+ZD*ZD)
  101 CONTINUE
      IF(IPRNT.EQ.0) GO TO 201
      WRITE(6,1)
      CALL PRINT(R,LDIM,NATOM,6)
  201 RETURN
      END
      SUBROUTINE VIBGF(B,BIN,AA,BB,FX,FF,PIVOT,INDEX,EX,EY,EZ,NMAX)
C   DIMENSION AND COMMON STATEMENTS
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX),BIN(NMAX,NMAX),AA(NMAX,NMAX),BB(NMAX,NMAX)
      DIMENSION FX(NMAX,NMAX),FF(NMAX,NMAX)
      DIMENSION PIVOT(NMAX),INDEX(NMAX*2)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB102/ESCF
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB104/IFORCE,IGRAD,IATOM,ICOOD,IPRNT
      COMMON/VIB201/CHG(50),X(50),Y(50),Z(50)
      COMMON/VIB202/R(1275)
      COMMON/VIB203/ENGX(50),ENGY(50),ENGZ(50)
      COMMON/VIB204/RINT(150),ENGR(150)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB301/KR(150),LR(150)
      COMMON/VIB302/KA(150),LA(150),MA(150),AGLB(150)
      COMMON/VIB303/KB(100),LB(100),MB(100),AGLL(100)
      COMMON/VIB304/KD(100),LD(100),MD(100),ND(100)
      COMMON/VIB305/KT(100),LT(100),MT(100),NT(100)
      COMMON/VIB306/AGLT(100),AGLO(100),AGLR(100)
      COMMON/VIB307/AGLD(100),AGLE(100),AGLF(100)
      DATA ITAP12,ITAP15 / 12 , 15 /
      DATA ZERO,ONE / 0.0D+00 , 1.0D+00 /
      DATA PI / 3.1415926536D+00 /
C   FORMAT STATEMENTS
    1 FORMAT(//)
    2 FORMAT(10I5)
    3 FORMAT(2X,' PARAMETERS FOR THE CALCULATION'//
     * 2X,' NST    = ',I5/
     * 2X,' NBND   = ',I5/
     $ 2X,' NLIB   = ',I5/
     * 2X,' NDEF   = ',I5/
     * 2X,' NTORS  = ',I5/
     * 2X,' IFORCE = ',I5/
     * 2X,' IGRAD  = ',I5/
     * 2X,' IATOM  = ',I5/
     * 2X,' ICOOD  = ',I5/
     * 2X,' IPRNT  = ',I5/
     * 2X,' NINT   = ',I5/
     * 2X,' NATOM  = ',I5/
     * 2X,' N3N    = ',I5)
    4 FORMAT(2I5)
    5 FORMAT(//,2X,21H INTERNAL COORDINATES,50X,11H COORDINATE/
     1 73X,4H NO.)
    6 FORMAT(2X,12H BOND LENGTH/
     1 2X,20H   R   K-L    K    L/)
    7 FORMAT(2X,F10.5,2I5,51X,2H (,I2,1H))
    8 FORMAT(3I5)
    9 FORMAT(/,2X,11H BOND ANGLE/
     1 2X,25H ANG-KLM      K    L    M/)
   10 FORMAT(2X,F10.5,3I5,46X,2H (,I2,1H))
   11 FORMAT(/,2X,' LINEAR BOND ANGLE'/
     1 2X,8H ANG-KLM,5X,2H K,3X,2H L,3X,2H M/)
   12 FORMAT(4I5)
   13 FORMAT(/,2X,' OUT OF PLANE ANGLE'/
     1 2X,8H ANG-LNM,7X,8H ANG-KNM,7X,8H ANG-KNL,
     2 8X,2H K,3X,2H L,3X,2H M,3X,2H N/)
   14 FORMAT(2X,F10.5,5X,F10.5,5X,F10.5,3X,4I5,8X,2H (,I2,1H))
   15 FORMAT(/,2X,' TORSIONAL ANGLE'/
     1 2X,8H ANG-KLM,7X,8H ANG-LMN,7X,8H ANG-TOR,
     2 8X,2H K,3X,2H L,3X,2H M,3X,2H N/)
   16 FORMAT(//,2X,' EX MATRIX'/)
   17 FORMAT(//,2X,' EY MATRIX'/)
   18 FORMAT(//,2X,' EZ MATRIX'/)
   19 FORMAT(//,2X,' B MATRIX'/)
   20 FORMAT(//,2X,' B INVERSE MATRIX'/)
   21 FORMAT(//,2X,' DETERM OF B MATRIX = ',D15.7)
   22 FORMAT(//,2X,' B * B(-1) = E'/)
   23 FORMAT(//,2X,' INTERNAL ENERGY GRADIENTS '/
     1 5X,4H NO.,10X,7H COORD.,13X,6H GRAD./)
   24 FORMAT(2X,I7,5X,2F20.10)
   25 FORMAT(2I5)
   26 FORMAT(3F20.10)
   27 FORMAT(//,2X,' FX MATRIX'/)
   28 FORMAT(//,2X,' BIN * FX  MATRIX'/)
   29 FORMAT(//,2X,' F MATRIX'/)
   30 FORMAT(2I5,F20.10,I5)
   31 FORMAT(4F20.10)
   32 FORMAT(2F20.10)
   33 FORMAT(3F20.10)
C
      INPUT=5
      CALL LOCATE(INPUT,'# INTCOS #',IERR)
      READ(5,2) ID1,ID2,ID3,ID4,ID5,ID6,ID7,ID8,ID9,ID10
C
      WRITE(6,1)
      AR=PI/180.0D+00
      WRITE(6,3) NST,NBND,NLIB,NDEF,NTORS,IFORCE,IGRAD,IATOM,ICOOD,
     1           IPRNT,NINT,NATOM,N3N
C
C   THE CALCULATION OF B VECTORS
C   THE CALCULATION OF UNIT VECTORS
      DO 101 I=1,NATOM
      DO 101 J=1,NATOM
      EX(I,J)=ZERO
      EY(I,J)=ZERO
  101 EZ(I,J)=ZERO
      DO 102 I=1,NINT
      DO 102 J=1,N3N
  102 B(I,J)=ZERO
      DO 103 I=1,NAT1
      IR=I+1
      DO 103 J=IR,NATOM
      IJ=IOFF(MAX0(I,J))+MIN0(I,J)
      EX(I,J)=-(X(I)-X(J))/R(IJ)
      EY(I,J)=-(Y(I)-Y(J))/R(IJ)
      EZ(I,J)=-(Z(I)-Z(J))/R(IJ)
      EX(J,I)=-EX(I,J)
      EY(J,I)=-EY(I,J)
      EZ(J,I)=-EZ(I,J)
  103 CONTINUE
C***INPUT DATA FOR STRETCHINGS***
      READ(5,4) (KR(I),LR(I),I=1,NST)
      WRITE(6,5)
      WRITE(6,6)
      DO 104 I=1,NST
      K=KR(I)
      L=LR(I)
      II=I
      KL=IOFF(MAX0(K,L))+MIN0(K,L)
      RINT(II)=R(KL)
      WRITE(6,7) R(KL),KR(I),LR(I),II
  104 CONTINUE
      CALL STRNG(B,NMAX,EX,EY,EZ)
      IF(NBND.EQ.0) GO TO 201
C***INPUT DATA FOR BENDINGS***
      READ(5,8) (KA(I),LA(I),MA(I),I=1,NBND)
      WRITE(6,9)
      DO 105 I=1,NBND
      K=KA(I)
      L=LA(I)
      M=MA(I)
      II=I+NST
      AKLM=EX(L,K)*EX(L,M)+EY(L,K)*EY(L,M)+EZ(L,K)*EZ(L,M)
      AGLB(I)=DACOS(AKLM)
      ANG=AGLB(I)/AR
      RINT(II)=AGLB(I)
      WRITE(6,10) ANG,KA(I),LA(I),MA(I),II
  105 CONTINUE
      CALL BENDNG(B,NMAX,EX,EY,EZ)
  201 IF(NLIB.EQ.0) GO TO 202
C***INPUT DATA FOR LINEAR BENDINGS***
      NLHF=NLIB/2
      READ(5,8) (KB(I),LB(I),MB(I),I=1,NLHF)
      WRITE(6,11)
      DO 106 I=1,NLHF
      I1=2*I-1+NST+NBND
      I2=I1+1
      K=KB(I)
      L=LB(I)
      M=MB(I)
      AKLM=EX(L,K)*EX(L,M)+EY(L,K)*EY(L,M)+EZ(L,K)*EZ(L,M)
      IF(DABS(AKLM).GT.ONE) AKLM=DSIGN(ONE,AKLM)
      AGLL(I)=DACOS(AKLM)
      ANG=AGLL(I)/AR
      RINT(I1)=AGLL(I)
      RINT(I2)=AGLL(I)
      WRITE(6,10) ANG,KB(I),LB(I),MB(I),I1
      WRITE(6,10) ANG,KB(I),LB(I),MB(I),I2
  106 CONTINUE
      CALL LINBND(B,NMAX,EX,EY,EZ)
  202 IF(NDEF.EQ.0) GO TO 203
C***INPUT DATA FOR DEFORMATIONS***
      READ(5,12) (KD(I),LD(I),MD(I),ND(I),I=1,NDEF)
      WRITE(6,13)
      DO 107 I=1,NDEF
      II=I+NST+NBND+NLIB
      K=KD(I)
      L=LD(I)
      M=MD(I)
      N=ND(I)
      ALNM=EX(N,L)*EX(N,M)+EY(N,L)*EY(N,M)+EZ(N,L)*EZ(N,M)
      AGLD(I)=DACOS(ALNM)
      AKNM=EX(N,K)*EX(N,M)+EY(N,K)*EY(N,M)+EZ(N,K)*EZ(N,M)
      AGLE(I)=DACOS(AKNM)
      AKNL=EX(N,K)*EX(N,L)+EY(N,K)*EY(N,L)+EZ(N,K)*EZ(N,L)
      AGLF(I)=DACOS(AKNL)
      DLM=AGLD(I)/AR
      DKM=AGLE(I)/AR
      DKL=AGLF(I)/AR
      RINT(II)=AGLD(I)
      WRITE(6,14) DLM,DKM,DKL,KD(I),LD(I),MD(I),ND(I),II
  107 CONTINUE
      CALL DEFORM(B,NMAX,EX,EY,EZ)
  203 IF(NTORS.EQ.0) GO TO 204
C***INPUT DATA FOR TORSIONS***
      READ(5,12) (KT(I),LT(I),MT(I),NT(I),I=1,NTORS)
      WRITE(6,15)
      DO 108 I=1,NTORS
      II=I+NST+NBND+NLIB+NDEF
      K=KT(I)
      L=LT(I)
      M=MT(I)
      N=NT(I)
      AKLM=EX(L,K)*EX(L,M)+EY(L,K)*EY(L,M)+EZ(L,K)*EZ(L,M)
      AGLT(I)=DACOS(AKLM)
      ALMN=EX(M,L)*EX(M,N)+EY(M,L)*EY(M,N)+EZ(M,L)*EZ(M,N)
      AGLO(I)=DACOS(ALMN)
C     PX=(EY(K,L)*EZ(L,M)-EZ(K,L)*EY(L,M))
C     PY=(EZ(K,L)*EX(L,M)-EX(K,L)*EZ(L,M))
C     PZ=(EX(K,L)*EY(L,M)-EY(K,L)*EX(L,M))
C     QX=(EY(L,M)*EZ(M,N)-EZ(L,M)*EY(M,N))
C     QY=(EZ(L,M)*EX(M,N)-EX(L,M)*EZ(M,N))
C     QZ=(EX(L,M)*EY(M,N)-EY(L,M)*EX(M,N))
C     SINPQ=DSQRT(ONE-AKLM*AKLM)*DSQRT(ONE-ALMN*ALMN)
C     AKLMN=(PX*QX+PY*QY+PZ*QZ)/SINPQ
      PX=(EY(L,K)*EZ(L,M)-EZ(L,K)*EY(L,M))
      PY=(EZ(L,K)*EX(L,M)-EX(L,K)*EZ(L,M))
      PZ=(EX(L,K)*EY(L,M)-EY(L,K)*EX(L,M))
      QX=(EY(M,L)*EZ(M,N)-EZ(M,L)*EY(M,N))
      QY=(EZ(M,L)*EX(M,N)-EX(M,L)*EZ(M,N))
      QZ=(EX(M,L)*EY(M,N)-EY(M,L)*EX(M,N))
      SINPQ=DSQRT(ONE-AKLM*AKLM)*DSQRT(ONE-ALMN*ALMN)
      AKLMN=(PX*QX+PY*QY+PZ*QZ)/SINPQ
      IF(DABS(AKLMN).GT.ONE) AKLMN=DSIGN(ONE,AKLMN)
      AGLR(I)=DACOS(AKLMN)
      ATL=AGLT(I)/AR
      ATM=AGLO(I)/AR
      ATT=AGLR(I)/AR
      RINT(II)=AGLR(I)
      WRITE(6,14) ATL,ATM,ATT,KT(I),LT(I),MT(I),NT(I),II
  108 CONTINUE
      CALL TORS(B,NMAX,EX,EY,EZ)
C
C   PRINT OUT E VECTORS
  204 IF(IPRNT.LE.2) GO TO 301
      WRITE(6,16)
      CALL MATOUT(EX,NATOM,NATOM,NATOM,NATOM,6)
      WRITE(6,17)
      CALL MATOUT(EY,NATOM,NATOM,NATOM,NATOM,6)
      WRITE(6,18)
      CALL MATOUT(EZ,NATOM,NATOM,NATOM,NATOM,6)
C
  301 IF(IPRNT.LE.2) GO TO 302
      WRITE(6,19)
      CALL MATOUT(B,NMAX,NMAX,NINT,N3N,6)
C   THE CALCULATION OF INVERSE B MATRIX
  302 DO 111 I=1,NINT
      DO 111 J=1,NINT
      BB(I,J)=ZERO
      DO 111 K=1,N3N
      BB(I,J)=BB(I,J)+B(I,K)*B(J,K)
  111 CONTINUE
      DO 112 I=1,NINT
      DO 112 J=1,NINT
  112 BIN(I,J)=BB(I,J)
      CALL MATINV(BIN,AA,PIVOT,INDEX,NINT,NINT,DETERM,NMAX)
      IF(IPRNT.LE.2) GO TO 303
      WRITE(6,20)
      CALL MATOUT(BIN,NMAX,NMAX,NINT,NINT,6)
  303 WRITE(6,21) DETERM
      DO 113 I=1,NINT
      DO 113 J=1,NINT
      AA(I,J)=ZERO
      DO 113 K=1,NINT
      AA(I,J)=AA(I,J)+BIN(I,K)*BB(K,J)
  113 CONTINUE
      IF(IPRNT.LE.2) GO TO 304
      WRITE(6,22)
      CALL MATOUT(AA,NMAX,NMAX,NINT,NINT,6)
  304 DO 114 I=1,NINT
      DO 114 J=1,N3N
      BB(I,J)=ZERO
      DO 114 K=1,NINT
      BB(I,J)=BB(I,J)+BIN(I,K)*B(K,J)
  114 CONTINUE
C
C***********************************************************
C***TRANSFORM GRADIENTS FROM CARTESIAN TO INTERNAL SYSTEM***
C***********************************************************
      DO 116 I=1,NINT
      ENGR(I)=ZERO
      DO 115 J=1,NATOM
      JX=3*J-2
      JY=3*J-1
      JZ=3*J
      ENGR(I)=ENGR(I)+ENGX(J)*BB(I,JX)+ENGY(J)*BB(I,JY)
     1 +ENGZ(J)*BB(I,JZ)
  115 CONTINUE
  116 CONTINUE
      WRITE(6,23)
      DO 117 I=1,NINT
      WRITE(6,24) I,RINT(I),ENGR(I)
  117 CONTINUE
C
C***********************************************************************
C***TRANSFORM FORCE CONSTANT MATRIX FROM CARTESIAN TO INTERNAL SYSTEM***
C***********************************************************************
      IF(IFORCE.EQ.0) GO TO 310
C   READ IN FORCE CONSTANT MATRIX
      REWIND ITAP15
      READ(ITAP15,25) NATOM,NNC
      READ(ITAP15,26) ((FX(I,J),J=1,N3N),I=1,N3N)
      IF(IPRNT.LE.2) GO TO 305
      WRITE(6,27)
      CALL MATOUT(FX,NMAX,NMAX,NNB,N3N,N3N,6)
C   TRANSFORM FX INTO F
  305 DO 121 I=1,NINT
      DO 121 J=1,N3N
      AA(I,J)=ZERO
      DO 120 K=1,N3N
      AA(I,J)=AA(I,J)+BB(I,K)*FX(K,J)
  120 CONTINUE
  121 CONTINUE
      IF(IPRNT.LE.2) GO TO 306
      WRITE(6,28)
      CALL MATOUT(AA,NMAX,NMAX,NINT,N3N,6)
  306 DO 123 I=1,NINT
      DO 123 J=1,NINT
      FF(I,J)=ZERO
      DO 122 K=1,N3N
      FF(I,J)=FF(I,J)+AA(I,K)*BB(J,K)
  122 CONTINUE
  123 CONTINUE
      IF(IPRNT.LE.1) GO TO 307
      WRITE(6,29)
      CALL MATOUT(FF,NMAX,NMAX,NINT,NINT,6)
  307 REWIND ITAP15
C
C   SEND INFORMATION TO GEOMETRY OPTIMIZATION PROGRAM WITH TAPE12
  310 CONTINUE
      REWIND ITAP12
      WRITE(ITAP12,30) NATOM,NINT,ESCF,IFORCE
      DO 125 I=1,NATOM
      WRITE(ITAP12,31) CHG(I),X(I),Y(I),Z(I)
  125 CONTINUE
      DO 126 I=1,NATOM
      WRITE(ITAP12,31) CHG(I),ENGX(I),ENGY(I),ENGZ(I)
  126 CONTINUE
      DO 127 I=1,NINT
      WRITE(ITAP12,32) RINT(I),ENGR(I)
  127 CONTINUE
      IF(IFORCE.EQ.0) GO TO 315
      WRITE(ITAP12,33) ((FF(I,J),J=1,NINT),I=1,NINT)
  315 CONTINUE
      REWIND ITAP12
C
      RETURN
      END
      SUBROUTINE STRNG(B,NMAX,EX,EY,EZ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB301/KR(150),LR(150)
C
C   THE CALCULATION OF S VECTORS FOR STRETCHINGS
      DO 101 I=1,NST
      K=KR(I)
      L=LR(I)
      KX=3*K-2
      KY=3*K-1
      KZ=3*K
      LX=3*L-2
      LY=3*L-1
      LZ=3*L
      B(I,KX)=EX(L,K)
      B(I,KY)=EY(L,K)
      B(I,KZ)=EZ(L,K)
      B(I,LX)=EX(K,L)
      B(I,LY)=EY(K,L)
  101 B(I,LZ)=EZ(K,L)
      RETURN
      END
      SUBROUTINE BENDNG(B,NMAX,EX,EY,EZ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB202/R(1275)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB302/KA(150),LA(150),MA(150),AGLB(150)
C
C   THE CALCULATION OF S VECTORS FOR ANGLE BENDINGS
      DO 101 I=1,NBND
      II=I+NST
      K=KA(I)
      L=LA(I)
      M=MA(I)
      KX=3*K-2
      KY=3*K-1
      KZ=3*K
      LX=3*L-2
      LY=3*L-1
      LZ=3*L
      MX=3*M-2
      MY=3*M-1
      MZ=3*M
      AG=AGLB(I)
      LK=IOFF(MAX0(L,K))+MIN0(L,K)
      LM=IOFF(MAX0(L,M))+MIN0(L,M)
      B(II,KX)=(DCOS(AG)*EX(L,K)-EX(L,M))/(R(LK)*DSIN(AG))
      B(II,KY)=(DCOS(AG)*EY(L,K)-EY(L,M))/(R(LK)*DSIN(AG))
      B(II,KZ)=(DCOS(AG)*EZ(L,K)-EZ(L,M))/(R(LK)*DSIN(AG))
      B(II,MX)=(DCOS(AG)*EX(L,M)-EX(L,K))/(R(LM)*DSIN(AG))
      B(II,MY)=(DCOS(AG)*EY(L,M)-EY(L,K))/(R(LM)*DSIN(AG))
      B(II,MZ)=(DCOS(AG)*EZ(L,M)-EZ(L,K))/(R(LM)*DSIN(AG))
      B(II,LX)=-B(II,KX)-B(II,MX)
      B(II,LY)=-B(II,KY)-B(II,MY)
  101 B(II,LZ)=-B(II,KZ)-B(II,MZ)
      RETURN
      END
      SUBROUTINE LINBND(B,NMAX,EX,EY,EZ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB201/CHG(50),X(50),Y(50),Z(50)
      COMMON/VIB202/R(1275)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB303/KB(100),LB(100),MB(100),AGLL(100)
      DATA ONE,TWO,THREE / 1.0D+00 , 2.0D+00 , 3.0D+00 /
      DATA PI / 3.1415926536D+00 /
C
 
      NLHF=NLIB/2
C   N IS A DUMMY ATOM
      DO 101 I=1,NLHF
      I1=2*I-1+NST+NBND
      I2=I1+1
      K=KB(I)
      L=LB(I)
      M=MB(I)
      KX=3*K-2
      KY=3*K-1
      KZ=3*K
      LX=3*L-2
      LY=3*L-1
      LZ=3*L
      MX=3*M-2
      MY=3*M-1
      MZ=3*M
      XN=X(M)+ONE
      YN=Y(M)+ONE
      ZN=Z(M)+ONE
      RMN=DSQRT(THREE)
      ML=IOFF(MAX0(M,L))+MIN0(M,L)
      RML=R(ML)
      KL=IOFF(MAX0(K,L))+MIN0(K,L)
      RNL=DSQRT((XN-X(L))**2+(YN-Y(L))**2+(ZN-Z(L))**2)
      SQCOS=(RNL**2-RMN**2-RML**2)/(TWO*RML*RMN)
      AGM=PI-DACOS(SQCOS)
      EXMN=ONE/RMN
      EYMN=ONE/RMN
      EZMN=ONE/RMN
      B(I1,KX)=(DCOS(AGM)*EX(M,L)-EXMN)/(R(KL)*DSIN(AGM))
      B(I1,KY)=(DCOS(AGM)*EY(M,L)-EYMN)/(R(KL)*DSIN(AGM))
      B(I1,KZ)=(DCOS(AGM)*EZ(M,L)-EZMN)/(R(KL)*DSIN(AGM))
      B(I1,MX)=(DCOS(AGM)*EX(M,L)-EXMN)/(R(ML)*DSIN(AGM))
      B(I1,MY)=(DCOS(AGM)*EY(M,L)-EYMN)/(R(ML)*DSIN(AGM))
      B(I1,MZ)=(DCOS(AGM)*EZ(M,L)-EZMN)/(R(ML)*DSIN(AGM))
      B(I1,LX)=-B(I1,KX)-B(I1,MX)
      B(I1,LY)=-B(I1,KY)-B(I1,MY)
      B(I1,LZ)=-B(I1,KZ)-B(I1,MZ)
      B(I2,KX)=-(EYMN*EZ(M,L)-EZMN*EY(M,L))/(R(KL)*DSIN(AGM))
      B(I2,KY)=-(EZMN*EX(M,L)-EXMN*EZ(M,L))/(R(KL)*DSIN(AGM))
      B(I2,KZ)=-(EXMN*EY(M,L)-EYMN*EX(M,L))/(R(KL)*DSIN(AGM))
      B(I2,MX)=-(EYMN*EZ(M,L)-EZMN*EY(M,L))/(R(ML)*DSIN(AGM))
      B(I2,MY)=-(EZMN*EX(M,L)-EXMN*EZ(M,L))/(R(ML)*DSIN(AGM))
      B(I2,MZ)=-(EXMN*EY(M,L)-EYMN*EX(M,L))/(R(ML)*DSIN(AGM))
      B(I2,LX)=-B(I2,KX)-B(I2,MX)
      B(I2,LY)=-B(I2,KY)-B(I2,MY)
      B(I2,LZ)=-B(I2,KZ)-B(I2,MZ)
  101 CONTINUE
      RETURN
      END
      SUBROUTINE DEFORM(B,NMAX,EX,EY,EZ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB202/R(1275)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB304/KD(100),LD(100),MD(100),ND(100)
C
C   THE CALCULATION OF S VECTORS FOR OUT OF PLANE DEFORMATIONS
      DO 101 I=1,NDEF
      II=I+NST+NBND+NLIB
      K=KD(I)
      L=LD(I)
      M=MD(I)
      N=ND(I)
      KX=3*K-2
      KY=3*K-1
      KZ=3*K
      LX=3*L-2
      LY=3*L-1
      LZ=3*L
      MX=3*M-2
      MY=3*M-1
      MZ=3*M
      NX=3*N-2
      NY=3*N-1
      NZ=3*N
      NK=IOFF(MAX0(N,K))+MIN0(N,K)
      NL=IOFF(MAX0(N,L))+MIN0(N,L)
      NM=IOFF(MAX0(N,M))+MIN0(N,M)
      CEXLM=EY(N,L)*EZ(N,M)-EZ(N,L)*EY(N,M)
      CEYLM=EZ(N,L)*EX(N,M)-EX(N,L)*EZ(N,M)
      CEZLM=EX(N,L)*EY(N,M)-EY(N,L)*EX(N,M)
      CEXMK=EY(N,M)*EZ(N,K)-EZ(N,M)*EY(N,K)
      CEYMK=EZ(N,M)*EX(N,K)-EX(N,M)*EZ(N,K)
      CEZMK=EX(N,M)*EY(N,K)-EY(N,M)*EX(N,K)
      CEXKL=EY(N,K)*EZ(N,L)-EZ(N,K)*EY(N,L)
      CEYKL=EZ(N,K)*EX(N,L)-EX(N,K)*EZ(N,L)
      CEZKL=EX(N,K)*EY(N,L)-EY(N,K)*EX(N,L)
      B(II,KX)=CEXLM/R(NK)
      B(II,KY)=CEYLM/R(NK)
      B(II,KZ)=CEZLM/R(NK)
      B(II,LX)=CEXMK/R(NL)
      B(II,LY)=CEYMK/R(NL)
      B(II,LZ)=CEZMK/R(NL)
      B(II,MX)=CEXKL/R(NM)
      B(II,MY)=CEYKL/R(NM)
      B(II,MZ)=CEZKL/R(NM)
      B(II,NX)=-B(II,KX)-B(II,LX)-B(II,MX)
      B(II,NY)=-B(II,KY)-B(II,LY)-B(II,MY)
  101 B(II,NZ)=-B(II,KZ)-B(II,LZ)-B(II,MZ)
      RETURN
      END
      SUBROUTINE TORS(B,NMAX,EX,EY,EZ)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION B(NMAX,NMAX)
      DIMENSION EX(NATOM,NATOM),EY(NATOM,NATOM),EZ(NATOM,NATOM)
      COMMON/VIB101/NATOM,NAT1,N3N,NINT
      COMMON/VIB103/NST,NBND,NLIB,NDEF,NTORS
      COMMON/VIB202/R(1275)
      COMMON/VIB205/IOFF(150)
      COMMON/VIB305/KT(100),LT(100),MT(100),NT(100)
      COMMON/VIB306/AGLT(100),AGLO(100),AGLR(100)
C
C   THE CALCULATION OF S VECTORS FOR TORSIONS
      DO 101 I=1,NTORS
      II=I+NST+NBND+NLIB+NDEF
      K=KT(I)
      L=LT(I)
      M=MT(I)
      N=NT(I)
      KX=3*K-2
      KY=3*K-1
      KZ=3*K
      LX=3*L-2
      LY=3*L-1
      LZ=3*L
      MX=3*M-2
      MY=3*M-1
      MZ=3*M
      NX=3*N-2
      NY=3*N-1
      NZ=3*N
      KL=IOFF(MAX0(K,L))+MIN0(K,L)
      MN=IOFF(MAX0(M,N))+MIN0(M,N)
      ML=IOFF(MAX0(M,L))+MIN0(M,L)
      AL=AGLT(I)
      AM=AGLO(I)
CCC   CEXKM=EY(L,K)*EZ(L,M)-EZ(L,K)*EY(L,M)
CCC   CEYKM=EZ(L,K)*EX(L,M)-EX(L,K)*EZ(L,M)
CCC   CEZKM=EX(L,K)*EY(L,M)-EY(L,K)*EX(L,M)
CCC   CEXNL=EY(M,N)*EZ(M,L)-EZ(M,N)*EY(M,L)
CCC   CEYNL=EZ(M,N)*EX(M,L)-EX(M,N)*EZ(M,L)
CCC   CEZNL=EX(M,N)*EY(M,L)-EY(M,N)*EX(M,L)
      CEXKM=EY(K,L)*EZ(L,M)-EZ(K,L)*EY(L,M)
      CEYKM=EZ(K,L)*EX(L,M)-EX(K,L)*EZ(L,M)
      CEZKM=EX(K,L)*EY(L,M)-EY(K,L)*EX(L,M)
      CEXNL=EY(N,M)*EZ(M,L)-EZ(N,M)*EY(M,L)
      CEYNL=EZ(N,M)*EX(M,L)-EX(N,M)*EZ(M,L)
      CEZNL=EX(N,M)*EY(M,L)-EY(N,M)*EX(M,L)
      RS2K=R(KL)*DSIN(AL)**2
      RS2M=R(ML)*DSIN(AM)**2
      RS2N=R(MN)*DSIN(AM)**2
      RS2L=R(ML)*DSIN(AL)**2
      B(II,KX)=-CEXKM/RS2K
      B(II,KY)=-CEYKM/RS2K
      B(II,KZ)=-CEZKM/RS2K
      B(II,LX)=(R(ML)-R(KL)*DCOS(AL))*CEXKM/(R(ML)*RS2K)+
     1 DCOS(AM)*CEXNL/RS2M
      B(II,LY)=(R(ML)-R(KL)*DCOS(AL))*CEYKM/(R(ML)*RS2K)+
     1 DCOS(AM)*CEYNL/RS2M
      B(II,LZ)=(R(ML)-R(KL)*DCOS(AL))*CEZKM/(R(ML)*RS2K)+
     1 DCOS(AM)*CEZNL/RS2M
      B(II,MX)=(R(ML)-R(MN)*DCOS(AM))*CEXNL/(R(ML)*RS2N)+
     1 DCOS(AL)*CEXKM/RS2L
      B(II,MY)=(R(ML)-R(MN)*DCOS(AM))*CEYNL/(R(ML)*RS2N)+
     1 DCOS(AL)*CEYKM/RS2L
      B(II,MZ)=(R(ML)-R(MN)*DCOS(AM))*CEZNL/(R(ML)*RS2N)+
     1 DCOS(AL)*CEZKM/RS2L
      B(II,NX)=-CEXNL/RS2N
      B(II,NY)=-CEYNL/RS2N
  101 B(II,NZ)=-CEZNL/RS2N
      RETURN
      END
