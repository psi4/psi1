      PROGRAM DRTFK2
C**********************************************************************
C*   NOTICE OF PROGRAM MODIFICATION                                   *
C**********************************************************************
c Moved to PSI distribution disk on 020289 - clj.
C**********************************************************************
C*  BY:  RICHARD REMINGTON                         SEARCH: C01-11-89  *
C*  DATE:  MARCH  24,  1988                                           *
C*  REASON: Remove close of unit = input                              *
C**********************************************************************
C*  BY:     GUSTAVO SCUSERIA                                          *
C*  DATE:   NOVEMBER 1, 1988                                          *
C*  REASON: CHANGE FILE55 IO TO INTEGER WORD ADDRESSING.              *
C**********************************************************************
C*  BY:  RICHARD REMINGTON                         SEARCH:  C3-24-88  *
C*  DATE:  MARCH  24,  1988                                           *
C*  REASON: DECREASE CORE TO RUN IN 7MB ON 9370                       *
C**********************************************************************
C      BY:  WESLEY ALLEN                                              *
C    DATE:  NOVEMBER 5,1986                                           *
C  REASON:  INCREASE CORE SO THAT LARGER CI GRADIENTS CAN RUN.        *
C**********************************************************************
C      BY:  TIM LEE                                                   *
C    DATE:  SEPTEMBER 21,1985                                         *
C  REASON:  MODIFICATIONS FOR TCSCF-CI GRADIENTS                      *
C**********************************************************************
C      BY:  RICHARD REMINGTON                                         *
C    DATE:  FEBRUARY  1, 1985                                         *
C  REASON:  CLEANUP OUTPUT AND STANDARDIZE UNIT 6 TO OUTPUT AND       *
C     UNIT 3 TO CHECK                                                 *
C**********************************************************************
C      BY:  RICHARD REMINGTON                                         *
C    DATE:  FEBRUARY  5, 1985   AND FEB. 6, 1985                      *
C  REASON:  CHANGE UNIT NUMBERS !! 10=>30,44=>34,57=>47,22=>42  !     *
C           CHANGE UNIT NUMBERS !! 21=>55                       !     *
C**********************************************************************
C      BY:  RICHARD REMINGTON                                         *
C    DATE:  FEBRUARY 11, 1985                                         *
C  REASON:  PRINT FILE11 PROPERLY                                     *
C**********************************************************************
C
C
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
C
C3-24-88  INTEGER IZ(1600000)
      INTEGER IZ(760000)
C3-24-88  REAL*8 RZ(800000)
      REAL*8 RZ(380000)
      EQUIVALENCE (RZ,IZ)
C
      CALL TSTART(3)
      CALL TSTART(6)
C TO SUPPRESS UNDERFLOW MESSAGES ON THE IBM
      CALL NOUNFL
      WRITE(3,*) '   BEFORE CALL TO INIT47 '
      CALL INIT47
      WRITE(3,*) '   AFTER CALL TO INIT47 '
C
      WRITE(6,*) '  '
      WRITE(6,*) ' USING NEW FILE55 IO (INTEGER WORD ADDRESSING)'
      WRITE(6,*) '  '
C
      ICHECK = 3
      INPUT  = 5
      IOUT   = 6
      ITAP42 = 42
      ITAP49 = 49
C
C3-24-88  MAXCOR=800000
      MAXCOR=380000
C*********************************************************************
      CALL ZERO(RZ,MAXCOR)
      WRITE(ICHECK,10)
  10  FORMAT(/' NEW VERSION OF DERIVA')
C
      CALL MAIN(RZ,IZ,MAXCOR)
C
      JCODE = 3
      CALL RCLOSE(ITAP42,JCODE)
      CALL RCLOSE(30,JCODE)
      CALL RCLOSE(47,JCODE)
      CALL RCLOSE(ITAP49,JCODE)
C
      CALL TSTOP(6)
      CALL TSTOP(3)
C
      STOP
      END
      SUBROUTINE MAIN(Z,A,MAXCOR)
C
C
C     THE SUBROUTINES CALL EACH OTHER IN THE FOLLOWING PATTERN
C         (VARIOUS PRINT ROUTINES ARE AFTER MAIN)
C
C        MAIN
C                  CONVRT
C                            INPSYM
C                                      GCENTR
C                            GETRAN
C                  GETMAT
C                  SCFINP
C                            DMAT
C                                      COMTRN
C                  NUCDER
C                  VDERIV
C                            INDEX
C                            TDER (ENTRY IN VDER)
C                            (ROOTS)
C                            VDER
C                  GLIMIT
C                  JKDER
C                            DDEBUT
C                            INCID
C                            ISOOUT
C                            REDUN2
C                            REDUND
C                            DSHELL
C                                      DPRIM
C                            DAB
C                            CIDENS (ENTRY IN INCID)
C                            CHDENS
C                            DGENRL
C                                      SSSS
C                                      PSSS
C                                      PSPS
C                                      PPSS
C                                      (ROOTS)
C                                      (XYZIJK)
C                                      (FRMIJK)
C                            MAKGRD
C                            FORME2
C                            MAKSKB (ENTRY IN INITB)
C                            FORMEG
C                  SYMTRY
C                            LOCAL
C                            TRANS
C                            ROT
C                            ISOOUT
C                            RDFR
C
C
C
C     NAMES IN PARENTHESES REFER TO COLLECTIONS OF SIMILAR ROUTINES,EG
C
C     (ROOTS) = RT123, ROOT4, ROOT5, DROOT
C
C
C
      IMPLICIT INTEGER (A-Z)
C
C
CIBM  INTEGER*8 FIRSTD,XECOND
      REAL*8 Z(MAXCOR),SECS
      LOGICAL OPEN
      CHARACTER*5 CALTYP,NOSYM
      CHARACTER*6 SCFTYP,LEVEL,DERTYP,CITYP
      CHARACTER*11 NAME
C
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /ITAP30/ I10(200),ITAP30,IEND,MPOINT,MCONST,MCALCS,
     #NCALCS,IFCB10(16)
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /NAME/   INAME,NAME
C
      DIMENSION A(1)
C
CIBM  DATA FIRSTD/'FIRST   '/, XECOND /'SECOND  '/
C
      NEED   = 1
      ICHECK = 3
      INPUT  = 5
      IOUT   = 6
      ITAP42 = 42
      ITAP49 = 49
C
C     ----- OPEN OUTPUT FILES WITH APPEND ACCESS -----
C
CIBM  OPEN (UNIT=IOUT,OPENMODE='A')
CIBM  OPEN (UNIT=6,OPENMODE='A')
C
C
C
      CALL LOCATE(INPUT,'# NAME ###',ERROR)
C
      IF (ERROR.EQ.0) THEN
        READ (INPUT,'(A11)') NAME
        INAME=0
      ELSE
        INAME=1
      END IF
C
      CALL LOCATE(INPUT,'# NEWDER #',ERROR)
C
      IF (ERROR.NE.0) THEN
        WRITE (IOUT,901)
  901   FORMAT (//,' DERIV: WARNING -- NO INPUT',/)
        CALTYP(1:5)='SCF  '
        NDERIV=1
        INTOUT=0
        INFOUT=0
      ELSE
        READ (INPUT,'(A5,5X,A6,I5)') CALTYP,LEVEL,IPRINT
        READ (INPUT,'(A5,2I5)') NOSYM,INTOUT,INFOUT
C01-11-89   CLOSE (UNIT=INPUT)
C
        IF (CALTYP.NE.'SCF  '.AND.CALTYP.NE.'CI   '.AND.CALTYP.NE.
     #  'MCSCF'.AND.CALTYP.NE.'TCSCF'.AND.CALTYP.NE.'GVBCI')  THEN
          WRITE (IOUT,902) CALTYP,LEVEL,IPRINT
  902     FORMAT (//,' UNKNOWN CALCULATION TYPE: ',A5,1X,A5,I5,//)
          STOP
        END IF
        NDERIV=0
        IF (LEVEL.EQ.'FIRST ') NDERIV=1
        IF (LEVEL.EQ.'SECOND') NDERIV=2
        IF (LEVEL.EQ.'THIRD ') NDERIV=3
        IF (LEVEL.EQ.'FOURTH') NDERIV=4
        IF (NDERIV.LE.0) THEN
          WRITE (IOUT,903) LEVEL
  903     FORMAT (//,' CANNOT UNDERSTAND LEVEL OF DERIVATIVE ',A5,//)
          STOP
        END IF
      END IF
C
      IF (INFOUT.EQ.0) THEN
        IF (NDERIV.EQ.2.AND.CALTYP.EQ.'SCF  ') INFOUT=1
        IF (NDERIV.EQ.2.AND.CALTYP.EQ.'TCSCF') INFOUT=1
        IF (NDERIV.EQ.2.AND.CALTYP.EQ.'CI   ') INFOUT=1
        IF (NDERIV.EQ.1.AND.CALTYP.EQ.'CI   ') INFOUT=1
        IF (NDERIV.EQ.1.AND.CALTYP.EQ.'GVBCI') INFOUT=1
        IF (NDERIV.EQ.3.AND.CALTYP.EQ.'SCF  ') THEN
          INFOUT=2
          NDERIV=2
        END IF
      END IF
C
      IF (IPRINT.EQ.0) THEN
        IPRINT=512+64+8+2
        IF (NDERIV.EQ.2) IPRINT=IPRINT+1024+128+16+4
      END IF
C
C
C
C     ----- GET CONSTANTS FROM TAPE30 -----
C
      ITAP30=30
      CALL RFILE(ITAP30)
      CALL WREADW(ITAP30,I10,200,101,JUNK)
C
      IEND=I10(1)
      MPOINT=I10(2)
      MCONST=I10(3)
      MCALCS=I10(4)
      NCALCS=I10(5)
      NAT=I10(19)
      NUM=I10(22)
      NNP=I10(23)
      NSHELL=I10(27)
      NIRRED=I10(28)
      NT=I10(29)
      NPRIM=I10(32)
      MXT=I10(36)
      NISO=I10(40)
C
C     ----- DIVIDE CORE FOR BASIS SET INFO -----
C
      EX=NEED
      CSPD=EX+NPRIM
      KATOM=WPADTI(CSPD+NPRIM*3)
      KTYPE=KATOM+NSHELL
      KSTART=KTYPE+NSHELL
      KLOC=KSTART+NSHELL
      KMIN=KLOC+NSHELL
      KMAX=KMIN+NSHELL
      KNG=KMAX+NSHELL
      ZAN=IADTWP(KNG+NSHELL)
      C=ZAN+NAT
      T=C+3*NAT
      INVT=WPADTI(T+MXT)
      ISO=INVT+NT
      LBLAT=ISO+NSHELL*NISO
      ICT=LBLAT+2*NAT
      PTR=IADTWP(ICT+NAT*NT)
      DTR=PTR+3*3*NT
      NEED=DTR+6*6*NT
C
C     ----- FORM INTEGER EQUIVALENTS FOR REAL ADDRESSES -----
C
      IEX=WPADTI(EX)
      ICSPD=WPADTI(CSPD)
      IZAN=WPADTI(ZAN)
      IC=WPADTI(C)
      IT=WPADTI(T)
      IPTR=WPADTI(PTR)
      IDTR=WPADTI(DTR)
C
      CALL BASIS(A(IEX),A(ICSPD),A(KATOM),A(KTYPE),A(KSTART),
     #A(KLOC),A(KMIN),A(KMAX),A(KNG),A(IZAN),A(IC),A(IT),
     #A(INVT),A(ISO),A(LBLAT),A(ICT),A(IPTR),A(IDTR),Z(CSPD))
C
C
C     ----- FORCE CALCULATION TO NOSYM IF DESIRED -----
C
      IF (NOSYM.EQ.'NOSYM') CALL SETNOS(NT,MXT,Z(T),A(ISO),NISO,
     #NSHELL)
C
C
C     ----- CALL APPROPRIATE DRIVER FOR CALCULATION -----
C
      IF (NDERIV.EQ.1) THEN
C       CALL M:LOAD(FIRSTD,JUNK)
        CALL SCF1(A,Z,NEED,MAXCOR,Z(EX),Z(CSPD)
     #  ,            A(KATOM),A(KTYPE),A(KSTART),A(KLOC),A(KMIN)
     #  ,            A(KMAX),A(KNG),Z(ZAN),Z(C),Z(T),A(INVT),A(ISO)
     #  ,            A(LBLAT),A(ICT),Z(PTR),Z(DTR))
C
      ELSE IF (NDERIV.EQ.2) THEN
C       CALL M:LOAD(XECOND,JUNK)
        CALL SCF2(A,Z,NEED,MAXCOR,Z(EX),Z(CSPD)
     #  ,            A(KATOM),A(KTYPE),A(KSTART),A(KLOC),A(KMIN)
     #  ,            A(KMAX),A(KNG),Z(ZAN),Z(C),Z(T),A(INVT),A(ISO)
     #  ,            A(LBLAT),A(ICT),Z(PTR),Z(DTR))
      END IF
C
CIBM  CALL CPUTIM(SECS)
CIBM  MINS=SECS/60
CIBM  HRS=MINS/60
CIBM  SECS=SECS-MINS*60
CIBM  MINS=MINS-HRS*60
      WRITE (IOUT,*) '            '
      WRITE (ICHECK,904) HRS,MINS,SECS
  904 FORMAT (//,' **** DERIVATIVE INTEGRALS FINISHED IN ',I4,':',I2
     #,       ':',F6.3,//)
C
      RETURN
      END
      SUBROUTINE SCF1(A,Z,NEED,MAXCOR,EX,CX,KATOM,KTYPE,KSTART,KLOC,
     #KMIN,KMAX,KNG,ZAN,C,T,INVT,ISO,LBLAT,ICT,
     #PTR,DTR)
C
C DRIVER ROUTINE FOR SCF FIRST DERIVATIVES  10 MAY 1983 PWS
C
C     MODIFIED 24 AUGUST 1983 AT BRL TO VARIABLY DIMENSION HONDO
C     ARRAYS                                           PWS
C
C
      IMPLICIT INTEGER (A-Z)
C
C    #KMIN,KMAX,KNG,ZAN,C,T,INVT,ISO,LBLAT,ICT,
C    #PTR,DTR
C
      REAL*8 EX(NPRIM),CX(NPRIM),ZAN(NAT),C(3,NAT),T(MXT)
      REAL*8 PTR(3,3,NT),DTR(6,6,NT),Z(MAXCOR)
      INTEGER KATOM(NSHELL),KTYPE(NSHELL),KSTART(NSHELL)
      INTEGER KLOC(NSHELL),KMIN(NSHELL),KMAX(NSHELL),KNG(NSHELL)
      INTEGER INVT(NT),ISO(NSHELL,NISO),LBLAT(2,NAT)
      INTEGER A(1),ICT(NAT,NT),IDATA(4)
CCC   INTEGER  ALABEL,BLABEL
CIBM  INTEGER*8 ONEL,TWOEL
C
      INTEGER FCB49(16),FCB18(16),FCB19(16)
      LOGICAL FOPEN,FEXIST,OPEN
      CHARACTER*5 CALTYP
      CHARACTER*6 CITYP,DERTYP,SCFTYP
      CHARACTER*11 NAME
      CHARACTER*20 FD
      CHARACTER*50 TITLE
      REAL*8 ESCF,FOCC,ALP,BET,FMTER
C
      COMMON /TYPES/ DERTYP,CITYP
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /ITAP30/ I10(200),ITAP30,IEND,MPOINT,MCONST,MCALCS,
     #NCALCS
      COMMON /COUPLC/ FOCC(5),ALP(5,5),BET(5,5),NTYPES
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /NAME/   INAME,NAME
      COMMON /HOLL/   ESCF,FMTER(13),JL
      COMMON /LABELS/ IALBEL(20),IBLBEL(20)
      COMMON /SECOND/ NAT3
C
CIBM  DATA ONEL /'D11E'/, TWOEL /'D12E'/
C
      NAT3 = 3*NAT
      NNP=NUM*(NUM+1)/2
C
C     ----- ALLOCATE MEMORY FOR GRADIENT STORAGE -----
C
      MXANGM=3
      MXSPDF=WPADTI(NEED)
      MINSH=MXSPDF+NAT
      MAXSH=MINSH+NAT*MXANGM
      DNUC=IADTWP(MAXSH+NAT*MXANGM)
      DONE=DNUC+NAT*3
      DHF=DONE+NAT*3
      DOVL=DHF+NAT*3
      DTWO=DOVL+NAT*3
      DTOT=DTWO+NAT*3
      IA=WPADTI(DTOT+NAT*3)
      NEED=IADTWP(IA+NNP)
C
C     ----- FIND LIMITS OF SHELLS, ETC -----
C
      CALL LIMITS(A(MXSPDF),A(MINSH),A(MAXSH),NAT,NSHELL,KATOM,
     #KTYPE,MXANGM)
C
C
C
C
      CALL RFILE(ITAP49)
CTJLRRCALL SREW(ITAP49)  THIS IS DONE IN RFILE
CTEMP READ (ITAP49) SCFTYP,CITYP,DERTYP,NTYPES,NBFAO,NNP,ESCF
C     SCFTYP='CLSCF '
C     CITYP='SCF   '
C     DERTYP='FIRST '
C     NTYPES=1
      CALL SREAD(ITAP49,IDATA,4)
      NTYPES=IDATA(1)
      IF (IDATA(2) .EQ. 1) SCFTYP='CLSCF '
      IF (IDATA(2) .EQ. 2) SCFTYP='HSOP  '
      IF (IDATA(2) .EQ. 3) SCFTYP='GRSCF '
      IF (IDATA(2) .EQ. 4) SCFTYP='TCSCF '
      IF (IDATA(3) .EQ. 1) DERTYP='FIRST '
      IF (IDATA(3) .EQ. 2) DERTYP='SECOND'
      IF (IDATA(4) .EQ. 1) CITYP='SCF   '
      IF (IDATA(4) .EQ. 2) CITYP='CI    '
      IF (IDATA(4) .EQ. 3) CITYP='MCSCF '
      IF (IDATA(4) .EQ. 4) CITYP='GVBCI '
      WRITE(IOUT,301) NTYPES,SCFTYP,DERTYP,CITYP
      WRITE(ICHECK,301) NTYPES,SCFTYP,DERTYP,CITYP
 301  FORMAT(/,'  NTYPES: ',I4,'  SCFTYP: ',A6,'  DERTYP: ',A6,
     1'  CITYP: ',A6)
      IF (IDATA(3).NE.1) THEN
        WRITE(IOUT,302)
 302    FORMAT(/'  INCOMPATABLE SCFTYP FOR FIRST DERIVATIVE!')
        STOP
      END IF
      NBFAO=NUM
CTJL  NNP=NUM*(NUM+1)/2
CRBR ?????????? BELOW STATEMENT ?????????
CTEMPEND
      NBSET=NTYPES
      IF (SCFTYP .EQ. 'TCSCF ') NBSET=6
      IF (CITYP .EQ. 'CI    '.OR.CITYP.EQ.'GVBCI ') NBSET=NBSET+1
C
      IF (NBFAO.NE.NUM) THEN
        WRITE (IOUT,900)
  900   FORMAT (//,' # DERIV  ERROR: MATRIX TAPE49 DOES NOT MATCH'
     #  ,          ' INTEGRAL INFORMATION',//)
        CALL EXIT(20)
      END IF
C
C
C      ----- ALLOCATE CORE FOR DENSITY MATRICES -----
C
      DENMAT=NEED
      IF (CALTYP.EQ.'MCSCF') THEN
        DENT=NEED
      ELSE
        DENT=DENMAT+NNP*NTYPES
      END IF
      DENW=DENT+NNP
      NEED=DENW+NNP
      DEN1=DENT
      IF (CALTYP.EQ.'CI   '.OR.CALTYP.EQ.'GVBCI') THEN
         DEN1=NEED
         NEED=DEN1+NNP
      END IF
C
      CALL SCFMAT(Z(DENMAT),Z(DENT),Z(DENW),Z(DEN1))
C
      CALL NUCONE(Z(DNUC),ZAN,C)
C
      TITLE='NUCLEAR REPULSION CONTRIBUTION TO FIRST DERIVATIVES'
      IF (IAND(IPRINT,2) .NE. 0) CALL PRNONE(TITLE,Z(DNUC))
C
C     ----- PASS ARRAY LOCATIONS TO INDEX FOR ONE-ELECTRON TERMS ---
C
      CALL ININDX(C,KATOM,KSTART,KNG,KTYPE,KMIN,KMAX,KLOC,A(IA),
     #Z(DEN1))
C
C     ----- CALCULATE DERIVATIVE OF ONE-ELECTRON AND OVERLAP TERMS --
C
      IF (INTOUT.EQ.0.AND.INFOUT.EQ.0) THEN
        CALL ONEONE(Z(DENW),Z(DONE),Z(DHF),Z(DOVL),C,ZAN,EX,CX)
      ELSE
        DH=NEED
        DS=DH+NNP*3*NAT
        IBF2AT=WPADTI(DS+NNP*3)
        NEED=IADTWP(IBF2AT+NUM)
        IF (NEED.GT.MAXCOR) THEN
          WRITE (IOUT,901) NEED*8,MAXCOR*8
  901     FORMAT (//,' # DERIV  ERROR: NOT ENOUGH CORE FOR DERIVATIVE'
     #    ,             ' ONE-ELECTRON INTEGRALS',2I8,//)
          CALL EXIT(25)
        END IF
C
        CALL BFTOAT(A(IBF2AT),KATOM,KLOC,KMIN,KMAX)
        CALL MAKONE(Z(DHF),Z(DH),Z(DS),C,ZAN,EX,CX)
        CALL MAKD1E(Z(DEN1),Z(DONE),Z(DH),NAT,NUM,NNP,Z(DENW),
     #  Z(DOVL),A(IBF2AT),Z(DS))
        CALL VSUB(Z(DONE),Z(DONE),Z(DHF),3*NAT)
C
C        ----- WRITE DERIVATIVE ONE-ELECTRON INTEGRALS TO FILE19 ---
C
      LENBUF = 1
      LENIBF = 1
        IF (INTOUT.NE.0) THEN
          ITAP18=78
          ITAP19=79
          CALL RFILE(ITAP19)
CTJL      CALL SREW(ITAP19)   THIS IS DONE IN RFILE.
C
          IF (IAND(INTOUT,1).NE.0) THEN
            CALL SWRIT(ITAP19,Z(DS),INTOWP(NNP*3))
          END IF
          IF (IAND(INTOUT,2).NE.0) THEN
            CALL SWRIT(ITAP19,Z(DH),INTOWP(NNP*3*NAT))
          END IF
C
C           ----- SET BUFFER SIZES FOR WRITING DERIVATIVE TWO-
C                 ELECTRON INTEGRALS, AND WRITE HEADER ON 18    -----
C
          LENIBF=SEC2I(20)
          LENBUF=SEC2I(50)/INTOWP(1)
          CALL RFILE(ITAP18)
CTJL      CALL SREW(ITAP18)  THIS IS DONE IN RFILE.
C
CTJL        WRITE (ITAP18) LENIBF,LENBUF,NAT,NUM,NNP
          CALL WWRITW(ITAP18,LENIBF,1,1,IEND)
          CALL WWRITW(ITAP18,LENBUF,1,IEND,IEND)
          CALL WWRITW(ITAP18,NAT,1,IEND,IEND)
          CALL WWRITW(ITAP18,NUM,1,IEND,IEND)
          CALL WWRITW(ITAP18,NNP,1,IEND,IEND)
C
          CALL SWRIT(ITAP18,A(IBF2AT),NUM)
        END IF
C
        IF (INFOUT.NE.0) CALL WR22A(A(IBF2AT),Z(DS),Z(DS),Z(DH),
     #  NAT,NUM,NNP,NAT3,NBSET)
C
C
C
      END IF
C
      NEED=DENW
C
C     ----- ADD HELLMAN-FEYNMAN TERM AND NUCLEAR REPULSION -----
C                 TO GIVE HELLMAN-FEYNMAN GRADIENT
C
      CALL VADD(Z(DHF),Z(DHF),Z(DNUC),3*NAT)
C
      TITLE='       HELLMAN-FEYNMAN FIRST DERIVATIVES           '
      IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DHF))
      TITLE='ONE-ELECTRON CONTRIBUTION TO FIRST DERIVATIVES     '
      IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DONE))
      IF(CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') THEN
      TITLE='OVERLAP CONTRIBUTION TO FIRST DERIVATIVES          '
      IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DOVL))
      END IF
C
C     ----- CALCULATE DERIVATIVE OF TWO-ELECTRON TERMS -----
C
      MAXSHL=MXANGM*(MXANGM+1)/2
CTJL  THE 16 ADDED TO AVOID CACHE MEMORY CONFLICT ON THE IBM 4381
      LEN2D=256+256*((4*(MXANGM-1)+3)/2)+16
      LENBLK=MAXSHL**4
      XIN=NEED
      YIN=XIN+LEN2D
      ZIN=YIN+LEN2D
      DXI=ZIN+LEN2D
      DYI=DXI+LEN2D
      DZI=DYI+LEN2D
      DXJ=DZI+LEN2D
      DYJ=DXJ+LEN2D
      DZJ=DYJ+LEN2D
      DXK=DZJ+LEN2D
      DYK=DXK+LEN2D
      DZK=DYK+LEN2D
      ABDENS=DZK+LEN2D
      IF (INTOUT.NE.0.OR.INFOUT.NE.0) THEN
        LENINT=LENBLK
      ELSE
        LENINT=1
        LENIBF=1
        LENBUF=1
      END IF
      DERINT=ABDENS+LENBLK
      IBUF=WPADTI(DERINT+LENINT*9)
      BUF=IADTWP(IBUF+LENIBF)
      NEED=BUF+LENBUF
C
      IF (CALTYP.EQ.'MCSCF'.OR.CALTYP.EQ.'CI   '.OR.CALTYP.EQ.
     #  'GVBCI') THEN
CGES    IDMSZ=SEC2I(200)
CTJL    IDMSZ=SEC2I(20)
        IDMSZ=SEC2I(20)
        IDMR=IDMSZ/INTOWP(1)
C
        IMOSHL=WPADTI(NEED)
        SHIZ=IMOSHL+NUM
        IJOFF=SHIZ+NNP
        KLOFF=IJOFF+NNP
        KLSIZ=KLOFF+NNP
CTJL    IOFFX=KLSIZ+NNP
CTJL    ABTEMP=IOFFX+NNP
        ABTEMP=KLSIZ+NNP
        IF (ABTEMP .NE. (ABTEMP/2)*2) ABTEMP=ABTEMP+1
        ABTEMP=IADTWP(ABTEMP)
        RDMBF=ABTEMP+LENBLK
        IDMBF=WPADTI(RDMBF)
        NEED=RDMBF+IDMR
      END IF
C
C
      IBMAT=1
      IF (INFOUT.NE.0) THEN
        IBMAT=NEED
        NEED=IBMAT+NNP*3*NAT*NBSET
      END IF
C
C
      IF (NEED.GT.MAXCOR) THEN
        WRITE (IOUT,902)
  902   FORMAT (//,' # DERIV  ERROR: NOT ENOUGH CORE FOR TWO-ELECTRON'
     #  ,          ' FIRST DERIVATIVES',//)
        CALL EXIT(24)
      END IF
      WRITE (ICHECK,904) NEED*8,MAXCOR*8
  904 FORMAT (/,/,' USING A TOTAL OF ',I8,' OF ',I8,' BYTES OF CORE')
C
      IF (CALTYP.EQ.'MCSCF'.OR.CALTYP.EQ.'CI   '.OR.CALTYP.EQ.
     .  'GVBCI') THEN
C
        CALL MCDEN1(A(SHIZ),A(IJOFF),A(KLOFF),A(KLSIZ),
     .              Z(RDMBF),A(IDMBF),IDMSZ,IDMR,A(IA),
     .              Z(ABDENS),LENBLK,Z(ABTEMP),MAXSHL,
     .              A(IMOSHL),KLOC,KMIN,KMAX)
      END IF
C
C     ----- LOAD OVERLAY FOR TWO-ELECTRON FIRST DERIVATIVES -----
C
C
      CALL JK1DER(A(IA),Z(DENT),Z(DENMAT),Z(DTWO),Z(XIN),Z(YIN),
     #            Z(ZIN),Z(DXI),Z(DYI),Z(DZI),Z(DXJ),Z(DYJ),Z(DZJ),
     #            Z(DXK),Z(DYK),Z(DZK),LEN2D,Z(ABDENS),LENBLK,
     #            Z(DERINT),LENINT,A(IBUF),LENIBF,Z(BUF),LENBUF,
     #            ITAP18,ITAP19,A(MXSPDF),A(MINSH),A(MAXSH),MXANGM,
     #            KATOM,C,KSTART,KNG,KTYPE,KMIN,KMAX,KLOC,EX,CX,ISO,
     #            Z(IBMAT),NBSET)
C
C
C
      CALL SYMD(Z(DTWO),ICT,PTR,INVT)
C
      IF (INFOUT.NE.0) THEN
        IDIM=10
        MI=WPADTI(XIN)
        MJ=MI+NT
        MIAT=MJ+NT
        MOP=MIAT+NT
        VX=MOP+NT
        IF(VX .NE. (VX/2)*2) VX=VX+1
        VX=IADTWP(VX)
        VY=VX+IDIM**2
        VZ=VY+IDIM**2
        UX=VZ+IDIM**2
        UY=UX+IDIM**2
        UZ=UY+IDIM**2
        TX=UZ+IDIM**2
        TY=TX+IDIM**2
        TZ=TY+IDIM**2
        LAST=TZ+IDIM**2
        IF (LAST.GT.BUF) STOP ' SCF1: LAST.GT.BUF'
      DO 211 III=XIN,LAST
      Z(III)=0.0D0
  211 CONTINUE
C
        CALL SYMF(Z(IBMAT),NBSET,ICT,PTR,DTR,INVT,A(MI),A(MJ),
     #  KTYPE,KMIN,KMAX,KLOC,A(MIAT),A(MOP),Z(VX),Z(VY),
     #  Z(VZ),Z(UX),Z(UY),Z(UZ),Z(TX),Z(TY),Z(TZ),IDIM,
     #  ISO)
C
      END IF
C
C
      TITLE='TWO-ELECTRON CONTRIBUTION TO FIRST DERIVATIVES     '
      IF (IAND(IPRINT,64) .NE. 0) CALL PRNONE(TITLE,Z(DTWO))
C
C     ----- ADD ALL CONTRIBUTIONS TO THE GRADIENT -----
C
      CALL VADD(Z(DTOT),Z(DHF),Z(DONE),3*NAT)
      IF (CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') THEN
         CALL VADD(Z(DTOT),Z(DTOT),Z(DOVL),3*NAT)
      END IF
      CALL VADD(Z(DTOT),Z(DTOT),Z(DTWO),3*NAT)
C
      TITLE='---------------- TOTAL SCF DERIVATIVES ------------'
      IF (CALTYP.EQ.'MCSCF') THEN
        TITLE='----------------TOTAL MCSCF DERIVATIVES -----------'
      END IF
      IF (CALTYP.EQ.'CI   '.OR.CALTYP.EQ.'GVBCI') THEN
        TITLE='----- CI GRADIENTS LESS CPHF TERMS ----------------'
      END IF
      IF (IAND(IPRINT,512) .NE. 0) CALL PRNONE(TITLE,Z(DTOT))
C
      IF (CITYP.NE.'CI    '.AND.CITYP.NE.'GVBCI'.AND.DERTYP.EQ.
     #  'FIRST ') THEN
        CALL PRN11(TITLE,Z(DTOT),ZAN,C)
      END IF
C
      IF (INFOUT.NE.0) CALL WR22B(Z(IBMAT),Z(DTOT),JUNK)
C
      CALL DTOTEN(Z(DTOT),NAT)
C
C
          IF (IAND(INTOUT,2).NE.0) THEN
             CALL RCLOSE(ITAP18,3)
             CALL RCLOSE(ITAP19,3)
          END IF
C
C
      RETURN
      END
      SUBROUTINE DTOTEN(D,NAT)
C
      IMPLICIT INTEGER (A-Z)
C
C
      INTEGER D(1)
C
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /ITAP30/ I10(200),ITAP30,IEND,MPOINT,MCONST,MCALCS
     #,               NCALCS
C
C
C
      JUNK=101+MCONST+MPOINT+NCALCS-1
      CALL WREADW(ITAP30,LOCCAL,1,JUNK,JUNK)
C
      LOCCAL=LOCCAL+61
      CALL WREADW(ITAP30,LOCDER,1,LOCCAL,JUNK)
      IF (LOCDER.LE.0) THEN
        LOCDER=IEND
        IEND=IEND+INTOWP(3*NAT)
        CALL WWRITW(ITAP30,LOCDER,1,LOCCAL,JUNK)
        CALL WWRITW(ITAP30,IEND,1,101,JUNK)
      END IF
C
      CALL WWRITW(ITAP30,D,INTOWP(3*NAT),LOCDER,JUNK)
C
C
      RETURN
      END
      SUBROUTINE SCF2(A,Z,NEED,MAXCOR,EX,CX,KATOM,KTYPE,KSTART,KLOC,
     #KMIN,KMAX,KNG,ZAN,C,T,INVT,ISO,LBLAT,ICT,
     #PTR,DTR)
C
C DRIVER ROUTINE FOR SCF SECOND DERIVATIVES  26 AUGUST 1983 PWS
C
C
      IMPLICIT INTEGER (A-Z)
C
C    #,              ZAN,C,T,INVT,ISO,LBLAT,ICT,PTR,DTR
C
      REAL*8 EX(NPRIM),CX(NPRIM),ZAN(NAT),C(3,NAT),T(MXT)
      REAL*8 PTR(3,3,NT),DTR(6,6,NT),Z(MAXCOR)
      INTEGER KATOM(NSHELL),KTYPE(NSHELL),KSTART(NSHELL)
      INTEGER KLOC(NSHELL),KMIN(NSHELL),KMAX(NSHELL),KNG(NSHELL)
      INTEGER INVT(NT),ISO(NSHELL,NISO),LBLAT(2,NAT)
      INTEGER A(1),ICT(NAT,NT),IDATA(4)
      INTEGER FCB49(16),FCB18(16),FCB19(16)
CCCC  INTEGER  IALBEL,IBLBEL
CIBM  INTEGER*8 ONEL,TWOEL
C
      LOGICAL FOPEN,FEXIST,OPEN,LBSTAT,LFSTAT
      CHARACTER*5 CALTYP
      CHARACTER*6 CITYP,DERTYP,SCFTYP
      CHARACTER*11 NAME
      CHARACTER*20 FD
      CHARACTER*50 TITLE
      REAL*8 ESCF,FOCC,ALP,BET,FMTER
C
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TYPES/ DERTYP,CITYP
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /ITAP30/ I10(200),ITAP30,IEND,MPOINT,MCONST,MCALCS,
     #NCALCS
      COMMON /COUPLC/ FOCC(5),ALP(5,5),BET(5,5),NTYPES
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /NAME/   INAME,NAME
      COMMON /HOLL/   ESCF,FMTER(13),JL
      COMMON /LABELS/ IALBEL(20),IBLBEL(20)
      COMMON /SECOND/ NAT3
C
CIBM  DATA ONEL /'D21E'/, TWOEL /'D22E'/
C
C
C
      WRITE(ICHECK,1100)
 1100 FORMAT(/'  IN SCF2')
      NAT3=NAT*3
      NNP=NUM*(NUM+1)/2
C
C
C     ----- ALLOCATE MEMORY FOR GRADIENT STORAGE -----
C
      MXANGM=3
      MXSPDF=WPADTI(NEED)
      MINSH=MXSPDF+NAT
      MAXSH=MINSH+NAT*MXANGM
      DNUC=IADTWP(MAXSH+NAT*MXANGM)
      DONE=DNUC+NAT*3
      DHF=DONE+NAT*3
      DOVL=DHF+NAT*3
      DTWO=DOVL+NAT*3
      DTOT=DTWO+NAT*3
      DELC = DTOT + NAT*3
CTJL  IA=WPADTI(DTOT+NAT*3)
      IA=WPADTI(DELC+NAT*3)
      FNUC=IADTWP(IA+NNP)
      WRITE(*,*) ' DELC,IA,FNUC',DELC,IA,FNUC
      WRITE(*,*) ' NAT3,NNP,NAT3*NAT3',NAT*3,NNP,NAT*3*NAT*3
      FONE=FNUC+3*NAT*3*NAT
      FHF=FONE+3*NAT*3*NAT
      FOVL=FHF+3*NAT*3*NAT
      FTWO=FOVL+3*NAT*3*NAT
      FTOT=FTWO+3*NAT*3*NAT
      NEED=FTOT+3*NAT*3*NAT
C
C     ----- FIND LIMITS OF SHELLS, ETC -----
C
      WRITE(ICHECK,1101)
 1101 FORMAT(/'  CALLING LIMITS')
      CALL LIMITS(A(MXSPDF),A(MINSH),A(MAXSH),NAT,NSHELL,KATOM,
     #KTYPE,MXANGM)
C
C
C
C
      WRITE(ICHECK,1102) ITAP49
 1102 FORMAT(/'  SFILE ON ITAP49=',I5)
      CALL RFILE(ITAP49)
      WRITE(ICHECK,1103)
 1103 FORMAT(/'  CALLING SREW')
CTJL  CALL SREW(ITAP49)  THIS IS DONE IN RFILE
CTEMP READ (ITAP49) SCFTYP,CITYP,DERTYP,NTYPES,NBFAO,NNP,ESCF
C     SCFTYP='CLSCF '
C     CITYP='SCF   '
C     DERTYP='FIRST '
C     NTYPES=1
      WRITE(ICHECK,1104)
 1104 FORMAT(/'  CALLING SREAD')
      CALL SREAD(ITAP49,IDATA,4)
      WRITE(ICHECK,1105) (IDATA(II), II=1,4)
 1105 FORMAT(/'  IDATA:',4I5)
      NTYPES=IDATA(1)
      IF (IDATA(2) .EQ. 1) SCFTYP='CLSCF '
      IF (IDATA(2) .EQ. 2) SCFTYP='HSOP  '
      IF (IDATA(2) .EQ. 3) SCFTYP='GRSCF '
      IF (IDATA(2) .EQ. 4) SCFTYP='TCSCF '
      IF (IDATA(3) .EQ. 1) DERTYP='FIRST '
      IF (IDATA(3) .EQ. 2) DERTYP='SECOND'
      IF (IDATA(4) .EQ. 1) CITYP='SCF   '
      IF (IDATA(4) .EQ. 2) CITYP='CI    '
      IF (IDATA(4) .EQ. 3) CITYP='MCSCF '
      WRITE(IOUT,301) NTYPES,SCFTYP,DERTYP,CITYP
 301  FORMAT(/,'  NTYPES: ',I4,'  SCFTYP: ',A6,'  DERTYP: ',A6,
     1'  CITYP: ',A6)
      IF (IDATA(3) .NE. 2) THEN
        WRITE(IOUT,302)
 302    FORMAT(/'  INCOMPATABLE DERTYP FOR SECOND DERIVATIVES!')
        STOP
      END IF
      NBFAO=NUM
CTJL  NNP=NUM*(NUM+1)/2
CTEMPEND
      NBSET=NTYPES
      IF (SCFTYP .EQ. 'TCSCF ') NBSET=6
      IF (CITYP .EQ. 'CI    ') NBSET=NBSET+1
C
      IF (NBFAO.NE.NUM) THEN
        WRITE (IOUT,900)
  900   FORMAT (//,' # DERIV  ERROR: MATRIX TAPE49 DOES NOT MATCH'
     #  ,          ' INTEGRAL INFORMATION',//)
        CALL EXIT(20)
      END IF
C
C
C      ----- ALLOCATE CORE FOR DENSITY MATRICES -----
C
      DENMAT=NEED
      IF (CALTYP.EQ.'MCSCF') THEN
        DENT=NEED
      ELSE
        DENT=DENMAT+NNP*NTYPES
      END IF
      DENW=DENT+NNP
      NEED=DENW+NNP
      DEN1=DENT
      IF (CALTYP.EQ.'CI   ') THEN
        DEN1=NEED
CACS    NEED=DEN1+INTOWP(NNP)
        NEED=DEN1+NNP
      END IF
C
      CALL SCFMAT(Z(DENMAT),Z(DENT),Z(DENW),Z(DEN1))
C
CTJL  CLOSE (ITAP49)
C
C     ----- LOAD OVERLAY FOR ONE-ELECTRON SECOND DERIVATIVES -----
C
C     CALL M:LOAD(ONEL,JUNK)
C
C     THIS OVERLAY STRUCTURE DID NOT WORK FOR CI FIRST
C
C     ----- CALCULATE DERIVATIVE OF NUCLEAR REPULSION -----
C
      CALL NUCTWO(Z(DNUC),Z(FNUC),ZAN,C)
C
      CALL FOLD(Z(FNUC),NAT3)
C
      TITLE='NUCLEAR REPULSION CONTRIBUTION TO FIRST DERIVATIVES'
      IF (IAND(IPRINT,2) .NE. 0) CALL PRNONE(TITLE,Z(DNUC))
      TITLE='NUCLEAR REPULSION CONTRIBUTION TO FORCE CONSTANTS  '
      IF (IAND(IPRINT,4) .NE. 0) CALL PRNTWO(TITLE,Z(FNUC))
C
C     ----- PASS ARRAY LOCATIONS TO INDEX FOR ONE-ELECTRON TERMS ---
C
      CALL ININDX(C,KATOM,KSTART,KNG,KTYPE,KMIN,KMAX,KLOC,A(IA),
     #Z(DEN1))
C
C     ----- CALCULATE DERIVATIVE OF ONE-ELECTRON AND OVERLAP TERMS --
C
      DH=NEED
      DS=DH+NNP*3*NAT
      D2S=DS+NNP*3
      IBF2AT=WPADTI(D2S)
      IF (IAND(INFOUT,2).NE.0) IBF2AT=WPADTI(D2S+NNP*6)
      NEED=IADTWP(IBF2AT+NUM)
      IF (NEED.GT.MAXCOR) THEN
        WRITE (IOUT,901) NEED*8,MAXCOR*8
  901   FORMAT (//,' # DERIV  ERROR: NOT ENOUGH CORE FOR DERIVATIVE'
     #  ,             ' ONE-ELECTRON INTEGRALS',2I8,//)
        CALL EXIT(25)
      END IF
C
      CALL BFTOAT(A(IBF2AT),KATOM,KLOC,KMIN,KMAX)
      CALL TWOONE(Z(DHF),Z(FHF),Z(FONE),Z(FOVL),Z(DH),Z(DS),C,ZAN,
     #EX,CX,Z(DENW),Z(D2S))
      CALL MAKD1E(Z(DEN1),Z(DONE),Z(DH),NAT,NUM,NNP,Z(DENW),
     #Z(DOVL),A(IBF2AT),Z(DS))
      CALL VSUB(Z(DONE),Z(DONE),Z(DHF),3*NAT)
C
      CALL FOLD(Z(FHF),NAT3)
      CALL FOLD(Z(FONE),NAT3)
      CALL FOLD(Z(FOVL),NAT3)
C
C
C     ----- WRITE DERIVATIVE ONE-ELECTRON INTEGRALS TO FILE19 ---
C
      IF (IAND(INTOUT,1).NE.0) THEN
        ITAP18=78
        ITAP19=79
        CALL RFILE(ITAP19)
CTJL    CALL SREW(ITAP19)  THIS IS DONE IN RFILE.
C
CTJL    DO 1210 ITJL = 1,NAT
C       DO 1210 ITJ = 1,3
C       WRITE(*,*) '   DERIVATIVE H FOR DEGREE ',(3*(ITJL-1)+ITJ)
C       CALL PRINT(Z(DH+((ITJL-1)*3+ITJ-1)*NNP),NNP,NUM,6)
C1210 CONTINUE
CTJL
        CALL SWRIT(ITAP19,Z(DS),INTOWP(NNP*3))
        CALL SWRIT(ITAP19,Z(DH),INTOWP(NNP*3*NAT))
C
C     ----- SET BUFFER SIZES FOR WRITING DERIVATIVE TWO-
C           ELECTRON INTEGRALS, AND WRITE HEADER ON 18    -----
C
        LENIBF=SEC2I(20)
        LENBUF=SEC2I(50)/INTOWP(1)
        CALL RFILE(ITAP18)
CTJL     CALL SREW(ITAP18)  THIS IS DONE IN RFILE.
C
CTJL     WRITE (ITAP18) LENIBF,LENBUF,NAT,NUM,NNP
        CALL WWRITW(ITAP18,LENIBF,1,1,IEND)
        CALL WWRITW(ITAP18,LENBUF,1,IEND,IEND)
        CALL WWRITW(ITAP18,NAT,1,IEND,IEND)
        CALL WWRITW(ITAP18,NUM,1,IEND,IEND)
        CALL WWRITW(ITAP18,NNP,1,IEND,IEND)
C
        CALL SWRIT(ITAP18,A(IBF2AT),NUM)
      END IF
      IF (INFOUT.NE.0) CALL WR22A(A(IBF2AT),Z(DS),Z(D2S),Z(DH),
     #NAT,NUM,NNP,NAT3,NBSET)
C
C
C
      NEED=DENW
C
C   ADD UP THE HELLMAN-FEYNMAN, OVERLAP, ONE ELECTRON AND TWO ELECTRON
C   CONTRIBUTIONS TO THE CI GRADIENT IN ORDER TO EVALUATE THE CPCI.
C   (NEED THE ELECTRONIC CONTRIBUTION TO THE GRADIENT.)
C                                                    TJL
C
 
      CALL VADD(Z(DELC),Z(DHF),Z(DONE),3*NAT)
      CALL VADD(Z(DELC),Z(DELC),Z(DOVL),3*NAT)
C
C     ----- ADD HELLMAN-FEYNMAN TERM AND NUCLEAR REPULSION -----
C                 TO GIVE HELLMAN-FEYNMAN GRADIENT
C
      CALL VADD(Z(DHF),Z(DHF),Z(DNUC),3*NAT)
C
      CALL VADD(Z(FHF),Z(FHF),Z(FNUC),NAT3**2)
      TITLE='       HELLMAN-FEYNMAN FIRST DERIVATIVES           '
      IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DHF))
      TITLE='        HELLMAN-FEYNMAN FORCE CONSTANTS            '
      IF (IAND(IPRINT,16).NE. 0) CALL PRNTWO(TITLE,Z(FHF))
      TITLE='ONE-ELECTRON CONTRIBUTION TO FIRST DERIVATIVES     '
      IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DONE))
      TITLE='ONE-ELECTRON CONTRIBUTION TO FORCE CONSTANTS       '
      IF (IAND(IPRINT,16).NE. 0) CALL PRNTWO(TITLE,Z(FONE))
CACS
CACS  IF(CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') THEN
        TITLE='OVERLAP CONTRIBUTION TO FIRST DERIVATIVES          '
        IF (IAND(IPRINT,8) .NE. 0) CALL PRNONE(TITLE,Z(DOVL))
        TITLE='OVERLAP CONTRIBUTION TO FORCE CONSTANTS            '
        IF (IAND(IPRINT,16).NE. 0) CALL PRNTWO(TITLE,Z(FOVL))
CACS  END IF
CACS
C
C     ----- CALCULATE DERIVATIVE OF TWO-ELECTRON TERMS -----
C
      MAXSHL=MXANGM*(MXANGM+1)/2
      LEN2D=512
      LENBLK=MAXSHL**4
      XIN=NEED
      YIN=XIN+LEN2D
      ZIN=YIN+LEN2D
      DXI=ZIN+LEN2D
      DYI=DXI+LEN2D
      DZI=DYI+LEN2D
      DXJ=DZI+LEN2D
      DYJ=DXJ+LEN2D
      DZJ=DYJ+LEN2D
      DXK=DZJ+LEN2D
      DYK=DXK+LEN2D
      DZK=DYK+LEN2D
      DD2D=DZK+LEN2D
      ABDENS=DD2D+LEN2D*18
      LENINT=LENBLK
      DERINT=ABDENS+INTOWP(LENBLK)
      IBUF=WPADTI(DERINT+LENINT*9)
      BUF=IADTWP(IBUF+LENIBF)
      NEED=BUF+LENBUF
C
CTJL  IF (CALTYP.EQ.'MCSCF') THEN
      IF (CALTYP.EQ.'MCSCF'.OR.CALTYP.EQ.'CI   ') THEN
        IDMSZ=SEC2I(100)
        IDMR=IDMSZ/INTOWP(1)
C
        IMOSHL=WPADTI(NEED)
        SHIZ=IMOSHL+NUM
        IJOFF=SHIZ+NNP
        KLOFF=IJOFF+NNP
        KLSIZ=KLOFF+NNP
        ABTEMP=IADTWP(KLSIZ+NNP)
        RDMBF=ABTEMP+LENBLK
        IDMBF=WPADTI(RDMBF)
        NEED=RDMBF+IDMR
      END IF
C
C
      IF (INFOUT.NE.0) THEN
        IBMAT=NEED
        NEED=IBMAT+NNP*3*NAT*NBSET
      END IF
C
C
C
C
      IF (NEED.GT.MAXCOR) THEN
        WRITE (IOUT,902)
  902   FORMAT (//,' # DERIV  ERROR: NOT ENOUGH CORE FOR TWO-ELECTRON'
     #  ,          ' FIRST DERIVATIVES',//)
        CALL EXIT(24)
      END IF
      WRITE (IOUT,904) NEED*8,MAXCOR*8
  904 FORMAT (/,' USING A TOTAL OF ',I8,' OF ',I8,' BYTES OF CORE',/)
C
      IF (CALTYP.EQ.'MCSCF'.OR.CALTYP.EQ.'CI   ') THEN
        CALL MCDEN1(A(SHIZ),A(IJOFF),A(KLOFF),A(KLSIZ),
     #  Z(RDMBF),A(IDMBF),IDMSZ,IDMR,A(IA),
     #  Z(ABDENS),LENBLK,Z(ABTEMP),MAXSHL,
     #  A(IMOSHL),KLOC,KMIN,KMAX)
      END IF
C
C     ----- LOAD OVERLAY FOR TWO-ELECTRON SECOND DERIVATIVES -----
C
C     CALL M:LOAD(TWOEL,JUNK)
C
C     THIS OVERLAY STRUCTURE DID NOT WORK FOR CI FIRST
C
         LBSTAT = .TRUE.
         LFSTAT = .TRUE.
CTJL  WRITE(*,*) '1IN DERIV87; LENIBF =',LENIBF,' LENBUF =',LENBUF
      IF(LENIBF .EQ. 0) THEN
         LBSTAT = .FALSE.
         LENIBF = 1
      END IF
      IF(LENBUF .EQ. 0) THEN
         LFSTAT = .FALSE.
         LENBUF = 1
      END IF
C
      CALL JK2DER(A(IA),Z(DENT),Z(DENMAT),Z(DTWO),Z(XIN),Z(YIN),
     #Z(ZIN),Z(DXI),Z(DYI),Z(DZI),Z(DXJ),Z(DYJ),Z(DZJ),
     #Z(DXK),Z(DYK),Z(DZK),Z(DD2D),LEN2D,Z(ABDENS),LENBLK,
     #Z(DERINT),LENINT,A(IBUF),LENIBF,Z(BUF),LENBUF,
     #ITAP18,ITAP19,A(MXSPDF),A(MINSH),A(MAXSH),MXANGM,
     #KATOM,C,KSTART,KNG,KTYPE,KMIN,KMAX,KLOC,EX,CX,ISO,
     #Z(FTWO),Z(IBMAT),ICT,PTR,DTR,INVT,NBSET)
C
      IF(.NOT. LBSTAT)  THEN
         LENIBF = 0
      END IF
      IF(.NOT. LFSTAT)  THEN
         LENBUF = 0
      END IF
C
      CALL FOLD(Z(FTWO),NAT3)
C
      CALL SYMD(Z(DTWO),ICT,PTR,INVT)
      CALL SYMH(Z(FTWO),ICT,PTR,INVT)
      IF (INFOUT.NE.0) THEN
        IDIM=10
        MI=WPADTI(XIN)
        MJ=MI+NT
        MIAT=MJ+NT
        MOP=MIAT+NT
        VX=IADTWP(MOP+NT)
        VY=VX+IDIM**2
        VZ=VY+IDIM**2
        UX=VZ+IDIM**2
        UY=UX+IDIM**2
        UZ=UY+IDIM**2
        TX=UZ+IDIM**2
        TY=TX+IDIM**2
        TZ=TY+IDIM**2
        LAST=TZ+IDIM**2
        IF (LAST.GT.BUF) STOP ' SCF2::LAST.GT.BUF'
C
        CALL SYMF(Z(IBMAT),NBSET,ICT,PTR,DTR,INVT,
     #  A(MI),A(MJ),KTYPE,KMIN,KMAX,KLOC,
     #  A(MIAT),A(MOP),Z(VX),Z(VY),Z(VZ),
     #  Z(UX),Z(UY),Z(UZ),Z(TX),Z(TY),
     #  Z(TZ),IDIM,ISO)
C
      END IF
C
      TITLE='TWO-ELECTRON CONTRIBUTION TO FIRST DERIVATIVES     '
      IF (IAND(IPRINT,64) .NE. 0) CALL PRNONE(TITLE,Z(DTWO))
      TITLE='TWO-ELECTRON CONTRIBUTION TO FORCE CONSTANTS       '
      IF (IAND(IPRINT,64) .NE. 0) CALL PRNTWO(TITLE,Z(FTWO))
C
C  ADD IN THE TWO ELECTRON CONTRIBUTION TO THE ELECTRONIC GRADIENT,
C  THEN WRITE IT TO FILE 47.
C
      CALL VADD(Z(DELC),Z(DELC),Z(DTWO),3*NAT)
      CALL WT47(Z(DELC),30)
        TITLE='---- CI GRADIENTS LESS NUCLEAR CONTRIBUTION ---------'
      CALL PRNONE(TITLE,Z(DELC))
C
C
C     ----- ADD ALL CONTRIBUTIONS TO THE GRADIENT -----
C
      CALL VADD(Z(DTOT),Z(DHF),Z(DONE),3*NAT)
CACS
CACS  IF(CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') THEN
        CALL VADD(Z(DTOT),Z(DTOT),Z(DOVL),3*NAT)
CACS  END IF
CACS
      CALL VADD(Z(DTOT),Z(DTOT),Z(DTWO),3*NAT)
      CALL VADD(Z(FTOT),Z(FHF),Z(FONE),NAT3**2)
      CALL VADD(Z(FTOT),Z(FTOT),Z(FTWO),NAT3**2)
CACS
CACS  IF(CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') THEN
        CALL VADD(Z(FTOT),Z(FTOT),Z(FOVL),NAT3**2)
CACS  END IF
CACS
C
      TITLE='---------------- TOTAL SCF DERIVATIVES ------------'
      IF (CALTYP.EQ.'MCSCF') THEN
      TITLE='--------------- TOTAL MCSCF DERIVATIVES -----------'
      END IF
      IF (CALTYP.EQ.'CI   ') THEN
      TITLE='---------------- TOTAL CI DERIVATIVES -------------'
      END IF
      IF (IAND(IPRINT,512) .NE. 0) CALL PRNONE(TITLE,Z(DTOT))
      TITLE='--- SCF FORCE CONSTANTS LESS CPHF CONTRIBUTION ----'
      IF (CALTYP.EQ.'MCSCF') THEN
      TITLE='- MCSCF FORCE CONSTANTS LESS CPMCHF CONTRIBUTION --'
      END IF
      IF (CALTYP.EQ.'CI   ') THEN
      TITLE='-- DERIVATIVE INTEGRAL CONTRIBUTION TO CI FORCES --'
C
C  WRITE DERIVATIVE INTEGRAL CONTRIBUTION TO FILE 47
C
      CALL WT47(Z(FTOT),26)
      END IF
      IF (IAND(IPRINT,1024).NE.0) CALL PRNTWO(TITLE,Z(FTOT))
C
C
      IF (INFOUT.NE.0) CALL WR22B(Z(IBMAT),Z(DTOT),Z(FTOT))
C
C     ----- WRITE GRADIENT TO TAPE30 -----
C
      CALL DTOTEN(Z(DTOT),NAT)
C
          IF (IAND(INTOUT,1).NE.0) THEN
             CALL RCLOSE(ITAP18,3)
             CALL RCLOSE(ITAP19,3)
          END IF
C
      RETURN
      END
      SUBROUTINE SCFMAT(D,DENT,DENW,DEN1)
C
C
C     READ (NTYPES) DENSITY MATRICES FROM TAPE49: CLOSED SHELL
C                                                 ALPHA OPEN SHELL
C                                                 BETA OPEN SHELL
C                                                 ENERGY WEIGHTED
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
C
      CHARACTER*5 CALTYP
      CHARACTER*6 SCFTYP,CITYP,DERTYP
      LOGICAL OPEN,CIONE
      INTEGER IDUM(4),IA47(192),FCB47(16)
C
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /COUPLC/ FOCC(5),ALP(5,5),BET(5,5),NTYPES
      COMMON /HOLL/   ESCF,FMTER(13),JL
      COMMON /LABELS/ IALBEL(20),IBLBEL(20)
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
C
      DIMENSION D(NNP,NTYPES),DENT(NNP),DENW(NNP),DEN1(NNP)
      DIMENSION ALPC(21),BETC(21)
C
      MAXTYP=5
      CIONE=.FALSE.
      IF(CALTYP.EQ.'CI   ' .AND. NDERIV.EQ.1) CIONE=.TRUE.
      IF(CALTYP.EQ.'GVBCI' .AND. NDERIV.EQ.1) CIONE=.TRUE.
C
      NBFAO=NUM
      NIJ=NNP
CTEMPEND
CSEL  CALL RSETSA(ITAP49,1)
      WRITE (ICHECK,1) CALTYP,CITYP,DERTYP
    1 FORMAT (//,' READING 49 FILE FOR DENSITY MATRICES',/
     #,       '  CALCULATION TYPE IS ',A5,1X,2A6,'.')
      WRITE (ICHECK,2) NTYPES,NBFAO,NIJ,ESCF
    2 FORMAT (/'   THERE ARE',I2,' DENSITY MATRICES.'/
     #,        '   NUMBER OF AOS:',I4,' SIZE OF MATRICES:',I5/
     #,        '   TOTAL ENERGY  =',F14.8)
      IERR = 0
      IF (NBFAO.EQ.NUM.AND.NIJ.EQ.(NUM+1)*NUM/2) GO TO 91
      IERR = IERR + 1
      WRITE (IOUT,80) NUM,NBFAO,NNP,NUM*(NUM+1)/2
   80 FORMAT (//,' **** ERROR READING TAPE49 FOR DENSITY MATRICES'
     #,       /,' NUM AOS IS',I4,' ON 49 IS ',I4,' MATRIX SIZE SHOULD'
     #,       ' BE',I5,' IS',I5,//)
   91 IF (NTYPES.LE.MAXTYP) GO TO 92
      IERR = IERR + 1
      WRITE(ICHECK,81) NTYPES,MAXTYP
   81 FORMAT (// ' XXXXX TOO MANY NTYPES',I4,' XXXXX MAX=',I4)
C
C
   92 CONTINUE
C     IF (CITYP .EQ.'CI    '.AND.CIONE ) GO TO 93
C     IF (CITYP .EQ.'SCF   '.AND..NOT.CIONE) GO TO 93
CC    IERR = IERR + 1
C     WRITE(ICHECK,82)
C  82 FORMAT(//' XXXXXX CITYP IS INCONSISTENT XXXXXXXX')
C  93 IF (DERTYP.EQ.'SECOND'.AND.TWODER) GO TO 100
C     IF (DERTYP.EQ.'FIRST '.AND..NOT.TWODER) GO TO 100
CC    IERR = IERR + 1
C     WRITE(ICHECK,83)
C  83 FORMAT(//' XXXXXX DERTYP IS INCONSISTENT XXXXXXXX')
CYO
C 100 CONTINUE
      IF (IERR.NE.0) STOP ' WHAT DO YOU WANT TO CALCULATE ?'
C
C     ----- READ EITHER SCF OR MCSCF DENSITY MATRICES -----
C
      IF (CALTYP.EQ.'MCSCF') THEN
        CALL ZERO(DENT,NNP)
        CALL ZERO(DENW,NNP)
        CALL RGETSA(ITAP49,ISECT)
        ISECT=ISECT+(NTYPES+1)*I2SEC(INTOWP(NNP))
        IF (SCFTYP(1:5).EQ.'GRSCF'.OR.SCFTYP(1:5).EQ.'TCSCF') THEN
          ISECT=ISECT+I2SEC(INTOWP(NTYPES))+2*I2SEC(INTOWP(NTYPES*
     #    (NTYPES+1)/2))
        END IF
        CALL RREAD(ITAP49,DENT,INTOWP(NNP),ISECT)
        CALL SREAD(ITAP49,DENW,INTOWP(NNP))
C
C        ----- TEMPORARY FIX FOR COMPATIBILITY -----
C
        DO 9 I=1,NNP
          DENW(I)=-DENW(I)*0.5D+00
    9   CONTINUE
C
      ELSE
C
C     ----- SCF PART -----
C
        CALL ZERO(DEN1,NNP)
        CALL ZERO(DENT,NNP)
        CALL ZERO(DENW,NNP)
        CALL ZERO(D,NNP*NTYPES)
        FOCC(1)=2.0D0
        DO 102 I=2,5
  102   FOCC(I)=0.0D0
        DO 103 I=1,5
          DO 103 J=1,5
            ALP(I,J)=0.0D0
  103   BET(I,J)=0.0D0
C
        IF (SCFTYP(1:5).NE.'HSOP ') GO TO 178
        FOCC(2)=1.0D0
        IF (NTYPES.NE.2) STOP ' ERROR IN HSOP NTYPES'
  178   CONTINUE
C
        CALL SREW(ITAP49)
        CALL SREAD(ITAP49,IDUM,4)
        DO 104 ITYP=1,NTYPES
          CALL SREAD(ITAP49,D(1,ITYP),INTOWP(NNP))
CTJL  WRITE(*,*) ' ITYP AND D '
CTJL    CALL PRINT(D(1,ITYP),NNP,NUM,6)
  104   CONTINUE
        CALL SREAD(ITAP49,DENW,INTOWP(NNP))
        IF (SCFTYP(1:5).NE.'GRSCF'.AND.SCFTYP(1:5).NE.'TCSCF') GO TO
     *  110
        NNPTY=NTYPES*(NTYPES+1)/2
        CALL SREAD(ITAP49,FOCC,INTOWP(NTYPES))
        CALL SREAD(ITAP49,ALPC,INTOWP(NNPTY))
        CALL SREAD(ITAP49,BETC,INTOWP(NNPTY))
CTJL
CTJL    WRITE(*,*) ' THE ALPHA AND BETA MATRICES FROM TAPE 49 ',NTYPES
CTJL    CALL PRINT(ALPC,NTYPES,NNPTY,6)
CTJL    CALL PRINT(BETC,NTYPES,NNPTY,6)
CTJL
        IJ=0
        DO 106 I=1,NTYPES
          DO 106 J=1,I
            IJ=IJ+1
            ALP(I,J) =  (1.0D0-ALPC(IJ))*0.50D0*FOCC(I)*FOCC(J)
            BET(I,J) = -(1.0D0-BETC(IJ))*0.25D0*FOCC(I)*FOCC(J)
            ALP(J,I)=ALP(I,J)
            BET(J,I)=BET(I,J)
  106   CONTINUE
C
CTJL
C       ALP(2,2) = 0.0D0
C       ALP(3,3) = 0.0D0
C       BET(2,2) = 0.0D0
C       BET(3,3) = 0.0D0
CTJL    WRITE(*,*) ' THE ALPHA AND BETA MATRICES ; AFTER'
CTJL    CALL MATOUT(ALP,5,5,5,5,6)
CTJL    CALL MATOUT(BET,5,5,5,5,6)
CTJL
CYO
        WRITE(ICHECK,11)
        DO 111 I=1,NTYPES
  111   WRITE(ICHECK,12) I,FOCC(I),(ALP(I,J),J=1,NTYPES)
        WRITE(ICHECK,13)
        DO 112 I=1,NTYPES
  112   WRITE(ICHECK,14) I,        (BET(I,J),J=1,NTYPES)
   11   FORMAT(//7X,' FOCC  &  ALPHA COUPLING CONSTANTS')
   12   FORMAT(1X,I5,F8.5,2X,5F12.7)
   13   FORMAT(//7X,'           BETA COUPLING CONSTANTS')
   14   FORMAT(1X,I5,10X,5F12.7)
C
  110   IF (CALTYP.NE.'MCSCF') GO TO 120
C
C     DO 115 I=1,NNP
C 115 DENT(I)=D(I,1)
C     GO TO 150
C
  120   CONTINUE
C
C     ----- GET CI ONE PARTICLE DENSITY MATRIX -----
C              AND CI LAGRANGIAN MATRIX
C
        IF (CALTYP.EQ.'CI   '.OR.CALTYP.EQ.'GVBCI') THEN
CCGF      CALL SREAD(ITAP49,DEN1,INTOWP(NNP))
CCGF      CALL SREAD(ITAP49,DENW,INTOWP(NNP))
CIBM      CALL SREW(IT47)
          CALL RT47(IA47,1)
          WRITE(ICHECK,1403)
 1403     FORMAT(/'  THE IA47 ARRAY:')
          WRITE(ICHECK,1404) (IA47(III), III=1,192)
 1404     FORMAT(10I7)
          CALL RT47(DENW,21)
CTJL      WRITE(ICHECK,1401)
 1401     FORMAT(/'  THE AO BASIS SYMMETRIZED CI LAGRANGIAN:')
CTJL      CALL PRINT(DENW,NNP,NUM,6)
CTJL      WRITE(*,*) ' IN DERTFK IA47(122),172 = ',IA47(122),IA47(172)
          CALL RT47(DEN1,22)
CTJL       WRITE(*,1402)
 1402     FORMAT(/'  THE CI 1PDM IN THE AO BASIS:')
CTJL      CALL PRINT(DEN1,NNP,NUM,6)
        END IF
        DO 125 ITYP=1,NTYPES
          DO 124 I=1,NNP
            DENT(I)=DENT(I)+D(I,ITYP)*FOCC(ITYP)
CTJL     WRITE(*,*) ' TYPE,FOCC ',ITYP,FOCC(ITYP)
  124     CONTINUE
  125   CONTINUE
C
C
C 150 CONTINUE
        DO 162 I=1,NNP
          DENW(I)=-DENW(I)
  162   CONTINUE
C
        IF (IAND(IPRINT,2048).EQ.0) RETURN
C
        WRITE (IOUT,4)
    4   FORMAT(/'  SCF TOTAL DENSITY MATRIX')
CTJL    CALL PRINT(DENT,NNP,NUM,IOUT)
        WRITE (IOUT,5)
    5   FORMAT(/'  ENERGY WEIGHTED DENSITY MATRIX')
CTJL    CALL PRINT(DENW,NNP,NUM,IOUT)
C       IF (CALTYP.NE.'CI   '.AND.CALTYP.NE.'GVBCI') RETURN
C
C       WRITE (IOUT,900)
C 900   FORMAT (/,'  CI ONE-PARTICLE DENSITY MATRIX ')
CTJL    CALL PRINT(DEN1,NNP,NUM,IOUT)
      END IF
C
      RETURN
      END
      SUBROUTINE PRNONE(TITLE,DE)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 DE(3,NAT)
      CHARACTER*50 TITLE,LET(3)*1,SCFTYP*6,CALTYP*5
C
      LOGICAL OPEN
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /SECOND/ NAT3
C
C
      DATA LET /'X','Y','Z'/
C
      WRITE (IOUT,1) TITLE
    1 FORMAT (//,T10,A50,//,' CENTER',T15,'X',T35,'Y',T55,'Z')
      DO 3 IC=1,NAT
        WRITE (IOUT,2) IC,DE(1,IC),DE(2,IC),DE(3,IC)
    2   FORMAT (/,1X,I4,3F20.12)
    3 CONTINUE
      RETURN
      END
      SUBROUTINE PRN11(TITLE,DER1,ZAN,GEOM)
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 DER1(3,NAT),ZAN(NAT),GEOM(3,NAT),A30(100)
      CHARACTER*52 TITLE
      CHARACTER*8  SCFTYP,CALTYP
C
      LOGICAL OPEN
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /ITAP30/ I10(200),ITAP30,IEND,MPOINT,MCONST,MCALCS,NCALCS
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /HOLL/   ESCF,FMTER(13),JL
      COMMON /LABELS/ IALBEL(20),IBLBEL(20)
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /SECOND/ NAT3
C
C
    1 FORMAT (20A4,/)
    2 FORMAT (I5,F20.10)
    3 FORMAT (4F20.10)
    4 FORMAT (20X,3F20.10)
C
      WRITE (11,1) (IALBEL(I),I=1,20)
      WRITE (11,2) NAT,ESCF
      DO 100  NG = 1,NAT
        WRITE (11,3)  ZAN(NG),GEOM(1,NG),GEOM(2,NG),GEOM(3,NG)
  100 CONTINUE
      DO 200  ND = 1,NAT
        WRITE (11,4)  DER1(1,ND),DER1(2,ND),DER1(3,ND)
  200 CONTINUE
      RETURN
      END
      SUBROUTINE PRNTWO(TITLE,D2E)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
C
      REAL*8 D2E(NAT3,NAT3)
      CHARACTER*50 TITLE,LET(3)*1,SCFTYP*6,CALTYP*5
C
      LOGICAL OPEN
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /SECOND/ NAT3
C
C
      DATA LET /'X','Y','Z'/
C
      WRITE (IOUT,4) TITLE,(IC,IC=1,NAT)
    4 FORMAT (//,T10,A50,//,(I26,3I30))
      WRITE (IOUT,5) ((LET(I),I=1,3),IC=1,NAT)
    5 FORMAT (/,T7,12(9X,A1))
      DO 8 IC=1,NAT
        DO 7 I=1,3
          IT=3*(IC-1)+I
          WRITE (IOUT,6) IC,LET(I),(D2E(IT,IDQ),IDQ=1,NAT3)
    6     FORMAT (/,I5,A1,4X,(12F10.6))
    7   CONTINUE
    8 CONTINUE
      RETURN
      END
      SUBROUTINE INIT22(IBF2AT,DS,DH,DTOT,FTOT,B,D2S)
C
C
      REAL*8 DS(NNP,3),DH(NNP,3,NAT),DTOT(3,NAT),FTOT(NAT3,NAT3)
      REAL*8 B(NNP,3,NAT,NBSET),D2S(NNP,6)
      INTEGER IBF2AT(NUM),FCB22(16)
      LOGICAL OPEN
      CHARACTER*5 CALTYP
      CHARACTER*6 SCFTYP
C
      COMMON /TAPES/  IOUT,ICHECK,INPUT
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TAPE22/ ITAP42,I22(100),IEND22
C
      RETURN
C
C-------------------------------------------------------------WR22A
C
      ENTRY WR22A(IBF2AT,DS,D2S,DH,NAT,NUM,NNP,NAT3,NBSET)
C
C     ----- PREPARE TAPE22 FOR CPHF -----
C
      ITAP42=42
      CALL RFILE(ITAP42)
      IEND22=101
C
      CALL IZERO(I22,100)
C
      I22(2)=NAT
      I22(3)=NUM
      I22(4)=NNP
      I22(5)=NDERIV
      I22(6)=INTOUT
      I22(7)=INFOUT
      I22(8)=NBSET
C
      I22(11)=IEND22
      CALL WWRITW(ITAP42,IBF2AT,NUM,IEND22,IEND22)
C     WRITE(ICHECK,1001) I22(11),(IBF2AT(III), III=1,NUM)
C1001 FORMAT(/'  IBF2AT WRITTEN TO 22 AT WORD ',I8
C    1       /'  IBF2AT:',10I5)
      I22(12)=IEND22
      CALL WWRITW(ITAP42,DS,INTOWP(NNP*3),IEND22,IEND22)
C     WRITE(ICHECK,1002) I22(12)
C1002 FORMAT(/'  SA WRITTEN TO 22 AT WORD ',I8)
C     DO 31 IXYZ=1,3
C31   CALL PRINT(DS(1,IXYZ),NNP,NUM,6)
C
      IF (IAND(INFOUT,2).NE.0) THEN
        I22(13)=IEND22
        CALL WWRITW(ITAP42,D2S,INTOWP(NNP*6),IEND22,IEND22)
      END IF
      I22(14)=IEND22
      CALL WWRITW(ITAP42,DH,INTOWP(NNP*3*NAT),IEND22,IEND22)
C     WRITE(ICHECK,1003) I22(14)
C1003 FORMAT(/'  DH WRITTEN TO 22 AT WORD',I8)
C     DO 2 IAT=1,NAT
C        DO 1 IXYZ=1,3
C           WRITE(ICHECK,3) IAT,IXYZ,(DH(I,IXYZ,IAT),I=1,NNP)
C   1    CONTINUE
C   2 CONTINUE
C   3 FORMAT (//,1X,2I10,/,(10F12.6))
C
C
      RETURN
C
C------------------------------------------------------WR22B
C
      ENTRY WR22B(B,DTOT,FTOT)
C
      I22(15)=IEND22
      CALL WWRITW(ITAP42,DTOT,INTOWP(3*NAT),IEND22,IEND22)
      IF (NDERIV.EQ.2) THEN
        I22(16)=IEND22
        CALL WWRITW(ITAP42,FTOT,INTOWP(NAT3**2),IEND22,IEND22)
      END IF
      I22(17)=IEND22
CTJL  WRITE(*,*) ' TWO ELECTRON DER INTS WRITTEN TO WORD ',IEND22
CTJL  WRITE(*,*) ' NNP,NAT,NBSET ',NNP,NAT,NBSET
CTJL  CALL PRINT(B(1,3,3,7),28,7,6)
      CALL WWRITW(ITAP42,B,INTOWP(NNP*3*NAT*NBSET),IEND22,IEND22)
CTJL  WRITE(*,*) ' TWO ELECTRON DER INTS LAST WORD + 1',IEND22
CTJL
CTJL  CALL ZERO(B,NNP*3*NAT*NBSET)
CTJL CALL WREADW(ITAP42,B,INTOWP(NNP*3*NAT*NBSET),I22(17),IUNK)
CTJL  CALL PRINT(B(1,3,3,7),28,7,6)
CTJL
C     WRITE(ICHECK,1004) I22(17)
C1004 FORMAT(/'  T MATRIX WRITTEN TO 22 AT WORD ',I8)
C
      I22(1)=IEND22
      CALL WWRITW(ITAP42,I22,100,1,JUNK)
C
      IOUT=3
C     DO 10 I=1,NAT
C        DO 9 J=1,3
C           WRITE (IOUT,1100) I,J
C           DO 8 K=1,NUM
C              IQL=K*(K-1)/2+1
C              IQU=K*(K-1)/2+K
C              WRITE (IOUT,1101) (B(IQ,J,I,1), IQ=IQL,IQU)
C  8        CONTINUE
C  9     CONTINUE
C 10  CONTINUE
C1100 FORMAT(//,' ATOM:',I3,' COORDINATE:',I3,' 2E-'//)
C1101 FORMAT(/,14F9.5)
C
C
CCCC  CALL SWEOF(ITAP42)
C
C     WRITE(ICHECK,1006) (I22(III), III=1,100)
C1006 FORMAT(10I5)
      RETURN
      END
      SUBROUTINE MCDEN1(SHIZ,IJOFF,KLOFF,KLSIZ,RDMBF,IDMBF,IDMSZ,IDMR,
     1IOFF,ABDENS,LENBLK,ABTEMP,MAXSHL,IMOSHL,KLOC,KMIN,KMAX)
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
C    #,              IMOSHL,KLOC,KMIN,KMAX,RDMBF
C
      REAL*8 RDMBF(IDMR),ABDENS(LENBLK)
      REAL*8 ABTEMP(MAXSHL,MAXSHL,MAXSHL,MAXSHL)
      INTEGER KLOC(NSHELL),KMIN(NSHELL),KMAX(NSHELL),IDMBF(IDMSZ)
      INTEGER SHIZ(NNP),IJOFF(NNP),KLOFF(NNP),KLSIZ(NNP),IOFF(NNP)
      LOGICAL OPEN
      LOGICAL OUT,IANDJ,KANDL,SAME
      SAVE JUNK
      CHARACTER*5 CALTYP
      CHARACTER*6 SCFTYP
C
      COMMON /TOLER/  F00TOL,FTOL
      COMMON /DSHLT/  TOL,CUTOFF,OUT
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /INFOA/  NAT,NUM,NNP,NSHELL,NIRRED,NT,NPRIM,MXT,NISO
      COMMON /DMISC/  IANDJ,KANDL,SAME
      COMMON /SHELLD/ XIDER,YIDER,ZIDER,XJDER,YJDER,ZJDER
     1,               XKDER,YKDER,ZKDER,NATOM(4),NPASS
      COMMON /DSHLNO/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL
     1,               MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL
     2,               NIJ,IJD,KLD,IJ,KL
      COMMON /CNTRL/  IPRINT,NDERIV,INTOUT,INFOUT,OPEN,SCFTYP,CALTYP
      COMMON /TAPES/  IOUT,ICHECK,INPUT,ITAP42,ITAP49
C
      DIMENSION IMOSHL(NUM)
C
      DO 160 I = 1,NSHELL
        I1 = KLOC(I)
        I2 = I1 + KMAX(I)-KMIN(I)
        DO 160 J = I1,I2
  160 IMOSHL(J) = I
      NST = NSHELL*(NSHELL+1)/2
C
C
      IT55=55
      CALL RFILE(IT55)
C     WRITE(6,*)' OPENING FILE 55'
C     WRITE(6,*)' NSHELL=',NSHELL
C     WRITE(6,*)' NST   =',NST
C     WRITE(6,*)' NNP   =',NNP
      CALL WREADW(IT55,SHIZ,NSHELL,1,JUNK)
C     WRITE(6,*)' SHIZ'
C     WRITE(6,*)  SHIZ
      CALL WREADW(IT55,IJOFF,NST,JUNK,JUNK)
C     WRITE(6,*)' IJOFF'
C     WRITE(6,*)  IJOFF
      CALL WREADW(IT55,KLOFF,NST,JUNK,JUNK)
C     WRITE(6,*) ' KLOFF'
C     WRITE(6,*)   KLOFF
      CALL WREADW(IT55,KLSIZ,NST,JUNK,JUNK)
C     WRITE(6,*) ' KLSIZ'
C     WRITE(6,*)   KLSIZ
C     IOFSET = I2SEC(JUNK) + 1
C     CALL RSETSA(IT55,IOFSET)
C     CALL RGETSA(IT55,IX)
C     CALL SREAD(IT55,IDMBF,IDMSZ)
C     WRITE(6,*)' IDMSZ =',IDMSZ
C
      IADD=0
      RETURN
C
C----------------------------------------------MCDENS-----
C
      ENTRY MCDENS(II,JJ,KK,LL,Q4)
C
C       READ DENSITY MATRIX FROM  FILE 55
C
C     WRITE(6,*)' '
      NN=0
      DMAX=0.0D+00
      II2=II
      JJ2=JJ
      KK2=KK
      LL2=LL
      IJS=IOFF(II)+JJ
      KLS=IOFF(KK)+LL
      ISTRT=INTOWP(IJOFF(IJS)+KLOFF(KLS)*KLSIZ(IJS))+JUNK
      KIZE=SHIZ(II)*SHIZ(JJ)*SHIZ(KK)*SHIZ(LL)
      CALL WREADW(IT55,RDMBF,INTOWP(KIZE),ISTRT,IEND)
C     WRITE(6,*)II,JJ,KK,LL,' ISTRT=',ISTRT,' IEND=',IEND
CGES  ISTRT=IJOFF(IJS)+KLOFF(KLS)*KLSIZ(IJS)-IADD
C     IF (ISTRT.LT.0) THEN
C       CALL RGETSA(IT55,IADDR)
C       IADDR=IADDR-I2SEC(IDMSZ)
C  53   CONTINUE
C       IADDR=IADDR-I2SEC(IDMSZ)
C       IADD=IADD-IDMR
C       ISTRT=ISTRT+IDMR
C       IF (ISTRT.LT.0) GO TO 53
C       CALL RREAD(IT55,IDMBF,IDMSZ,IADDR)
C     END IF
CGES  INEXT=ISTRT
      ICNT=0
      DO 5 ISH=1,SHIZ(II)
        DO 4 JSH=1,SHIZ(JJ)
          DO 3 KSH=1,SHIZ(KK)
            DO 2 LSH=1,SHIZ(LL)
               ICNT=ICNT+1
CGES           INEXT=INEXT+1
C 11           CONTINUE
C              IF (INEXT .GT. IDMR) THEN
C                IADD=IADD+IDMR
C                INEXT=INEXT-IDMR
C                CALL SREAD(IT55,IDMBF,IDMSZ)
C                GOTO 11
C              END IF
CGES           ABTEMP(ISH,JSH,KSH,LSH)=RDMBF(INEXT)
               ABTEMP(ISH,JSH,KSH,LSH)=RDMBF(ICNT)
    2        CONTINUE
    3      CONTINUE
    4    CONTINUE
    5 CONTINUE
C
      DO 1700 I=MINI,MAXI
        DO 1600 J=MINJ,MAXJ
          LMAX=MAXL
          DO 1500 K=MINK,MAXK
            IF (KANDL) LMAX=K
            DO 1400 L=MINL,LMAX
              NN=NN+1
              I1=LOCI+I
              I2=LOCJ+J
              I3=LOCK+K
              I4=LOCL+L
              IF(I1.GE.I2) GO TO 700
              N=I1
              I1=I2
              I2=N
  700         IF(I3.GE.I4) GO TO 800
              N=I3
              I3=I4
              I4=N
  800         IF(I1-I3) 900,1000,1100
  900         N=I1
              I1=I3
              I3=N
              N=I2
              I2=I4
              I4=N
              GO TO 1100
 1000         IF(I2.LT.I4) GO TO 900
 1100         CONTINUE
C
              IIS = IMOSHL(I1)
              JJS = IMOSHL(I2)
              KKS = IMOSHL(I3)
              LLS = IMOSHL(I4)
              IF ( (IOFF(IIS)+JJS).GE.(IOFF(KKS)+LLS) ) GO TO 1110
              N=I1
              I1=I3
              I3=N
              N=I2
              I2=I4
              I4=N
 1110         J1 = I1 - KLOC(II ) + 1
              J2 = I2 - KLOC(JJ ) + 1
              J3 = I3 - KLOC(KK ) + 1
              J4 = I4 - KLOC(LL ) + 1
              DFAC=ABTEMP(J1,J2,J3,J4)*8.0
C
              IF(I1.EQ.I2) DFAC=DFAC*0.5
              IF(I3.EQ.I4) DFAC=DFAC*0.5
              DFAC=DFAC*Q4
C
C     ----- THIS FACTOR OF TWO IS NEEDED BECAUSE ONLY GENERATE
C               ONE OF TWO POSSIBLE DERIVATIVES OF [II,KL]     -----
C
              IF (IANDJ.AND.I.EQ.J) DFAC=DFAC*2.0
C
              IF (ABS(DFAC).GT.DMAX) DMAX=ABS(DFAC)
              ABDENS(NN)=DFAC
C GF  WRITE(16,'(2X,8I5,G18.8)') II,JJ,KK,LL,J1,J2,J3,J4,DFAC
 1400       CONTINUE
 1500     CONTINUE
 1600   CONTINUE
 1700 CONTINUE
C     IF (ABS(DMAX).GT.1.0E-15) THEN
C     F00TOL=FTOL/DMAX
C     ELSE
C     F00TOL=1.0E+10
C     END IF
      F00TOL=-1.0E+10
C
      RETURN
      END
