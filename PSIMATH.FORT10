clj011889 This file was originally IOMR.
clj011889 The IBM specific routine tstart and its entry have been
clj011889 from IOMR.
clj011889 All IBM specific I/O routines have been removed. Namely:
clj011889    rfile,rgetsa,rsetsa,wwritw,wreadw,rread,rwrit
clj011889    sread, swrit, srew, and rclose.
clj012089 Removed mabort routine.
      SUBROUTINE WFILE(ITAPE,ISECT)
C
C THIS ROUTINE ZEROES OUT A FILE ON DISK
C
      IMPLICIT INTEGER (A-Z)
      INTEGER BUF(224)
C
      CALL IZERO(BUF,224)
      NSEC = ISECT / 2
      IF(2*NSEC.NE.ISECT) NSEC = NSEC + 1
      DO 1  I=1,NSEC
   1  CALL SWRIT(ITAPE,BUF,224)
C
      RETURN
      END
      SUBROUTINE ZFILE(ITAPE,ISECT)
C
C THIS ROUTINE ZEROES OUT A FILE ON DISK
C
      IMPLICIT INTEGER (A-Z)
      COMMON /IOBUFF/ BUFF(1024)
CTJL  INTEGER BUF(1024)
C         IN BLOCK DATA IOBUF IS 1024 INTEGER WORD ZEROES
CTJL  CALL IZERO(BUF,1024)
C     NSEC = ISECT * 2
C     IF(2*NSEC.NE.ISECT) NSEC = NSEC + 1
      DO 1  I=1,ISECT
   1  CALL SWRIT(ITAPE,BUFF,1024)
C
      RETURN
      END
      SUBROUTINE LOCATE(INPUT,TOKEN,IERROR)
C
C     ----- SEARCH THROUGH INPUT FILE FOR TOKEN BEGINNING
C           WITH # TO LOCATE INPUT FOR PROGRAM.  IERROR IS
C           SET TO 0 IF NO ERRORS, 1 IF ANY ERROR OCCURS.
C
C
      CHARACTER*10 TOKEN,LINE
C
      REWIND (UNIT=INPUT,ERR=99)
C
    1 CONTINUE
      READ (UNIT=INPUT,FMT='(A10)',END=99,ERR=99) LINE
      IF (LINE.NE.TOKEN) GO TO 1
C
      IERROR=0
      RETURN
C
C
   99 CONTINUE
      IERROR=1
      RETURN
      END
      INTEGER FUNCTION INTOWP(N)
      INTOWP=2*N
      RETURN
      END
      INTEGER FUNCTION I2SEC(N)
CC    I2SEC=(N+191)/192
      I2SEC=(N+1023)/1024
      RETURN
      END
      INTEGER FUNCTION SEC2I(N)
CC    SEC2I=192*N
      SEC2I=1024*N
      RETURN
      END
      INTEGER FUNCTION IROUND(N)
CC    IROUND=(N+191)/192*192
      IROUND=(N+1023)/1024*1024
      RETURN
      END
      INTEGER FUNCTION ITRUNC(N)
CC    ITRUNC=N/192*192
      ITRUNC=N/1024*1024
      RETURN
      END
      INTEGER FUNCTION IADTWP(N)
      IADTWP=(N+3)/2
      RETURN
      END
      INTEGER FUNCTION WPADTI(N)
      WPADTI=N*2-1
      RETURN
      END
      SUBROUTINE PRINT(A,NAD,M,IOUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*6 LINE(21)
      DIMENSION A(NAD)
    1 FORMAT(2X,10(7X,I5))
    2 FORMAT(2X,21A6)
    3 FORMAT(2X,I2,2X,10F12.7)
    4 FORMAT(/)
      DATA LINE / 21*'------' /
      II=0
      JJ=0
  200 II=II+1
      JJ=JJ+1
      KK=10*JJ
      NN=KK+KK*(KK-1)/2
      MM=M
      IF(M.GT.KK) MM=KK
      LL=2*(MM-II+1)+1
      WRITE (IOUT,1) (I,I=II,MM)
      WRITE (IOUT,2) (LINE(I),I=1,LL)
      DO 101 I=II,M
      I1=I*(I-1)/2+II
      I2=I+I*(I-1)/2
      IF(I2.GT.NN) I2=I1+9
      WRITE (IOUT,3) I,(A(J),J=I1,I2)
  101 CONTINUE
      IF(M.LE.KK) GO TO 201
      WRITE (IOUT,4)
      II=KK
      GO TO 200
  201 RETURN
      END
      SUBROUTINE MATOUT(A,NAD,NBD,M,N,IOUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*6 LINE(21)
      DIMENSION A(NAD,NBD)
    1 FORMAT(3X,10(7X,I5))
    2 FORMAT(3X,21A6)
    3 FORMAT(2X,I3,2X,10F12.7)
    4 FORMAT(/)
C
      DATA LINE / 21*'------' /
      II=0
      JJ=0
  200 II=II+1
      JJ=JJ+1
      KK=10*JJ
      NN=N
      IF(N.GT.KK) NN=KK
      LL=2*(NN-II+1)+1
      WRITE (IOUT,1) (I,I=II,NN)
      WRITE (IOUT,2) (LINE(I),I=1,LL)
      DO 101 I=1,M
      WRITE (IOUT,3) I,(A(I,J),J=II,NN)
  101 CONTINUE
      IF(N.LE.KK) GO TO 201
      WRITE (IOUT,4)
      II=KK
      GO TO 200
  201 RETURN
      END
      SUBROUTINE EIGOUT(A,B,C,NAD,NBD,M,N,IOUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(NAD,NBD),B(NAD),C(NAD)
      CHARACTER*6 LINE
      LINE='------'
    1 FORMAT(2X,10(7X,I5))
    2 FORMAT(2X,21A6)
    3 FORMAT(2X,I2,2X,10F12.7)
    4 FORMAT(/,6X,10F12.7)
    5 FORMAT(/)
C
      II=0
      JJ=0
  200 II=II+1
      JJ=JJ+1
      KK=10*JJ
      NN=N
      IF(N.GT.KK) NN=KK
      LL=2*(NN-II+1)+1
      WRITE(IOUT,1) (I,I=II,NN)
      WRITE(IOUT,2) (LINE,I=1,LL)
      DO 101 I=1,M
  101 WRITE(IOUT,3) I,(A(I,J),J=II,NN)
      WRITE(IOUT,4) (B(J),J=II,NN)
      WRITE(IOUT,4) (C(J),J=II,NN)
      IF(N.LE.KK) GO TO 201
      WRITE(IOUT,5)
      II=KK
      GO TO 200
  201 RETURN
      END
      INTEGER FUNCTION NREC(NLEN)
      IMPLICIT INTEGER (A-Z)
CC    IADD=(NLEN+8188)/8189
      IADD=(NLEN+255)/256
      NREC=IADD
      RETURN
      END
      SUBROUTINE INITMF(ISTART)
C   THIS PROGRAM INTIALIZES USEAGE OF THE MASTER FILE
C**********************************************************
C***LAST UPDATED ON FEBRUARY 06, 1985 BY YUKIO YAMAGUCHI***
C**********************************************************
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/CALIF/LPARA(1024),APARA(1024)
      COMMON/LIMIT/MAXBAS,MAXBUF,MAXBF2,MAXBF4
      COMMON/LOCAT/LOCS(1024)
      COMMON/MFSEC/MFILE,NSECT
C
C   DEFINE CONSTANTS
      MFILE=40
      NSECT=1024
      MAXBAS=52
      MAXBUF=4096
      MAXBF2=MAXBUF*2
      MAXBF4=MAXBUF*4
      IF(ISTART.EQ.0) GO TO 201
C
C   FIND LOCATIONS OF PARAMETERS AND MATRICES IN THE MASTER FILE
      CALL RFILE(MFILE)
      CALL RREAD(MFILE,LOCS,NSECT,1)
      CALL MREAD(LPARA,2)
      CALL MREAD(APARA,3)
C
  201 CONTINUE
      RETURN
      END
      SUBROUTINE MWRIT(IA,IADD)
      IMPLICIT INTEGER (A-Z)
      DIMENSION IA(1)
      COMMON/LOCAT/LOCS(1024)
      COMMON/MFSEC/MFILE,NSECT
C
C  NO.  :  CONTENTS
C
C   TRIA. = LOWER TRIANGULAR MATRIX
C   SQUA. = SQUARE MATRIX
C   RECT. = RECTANGULAR MATRIX
C   1   : LOCATION
C   2   : PARAMETERS
C   3   : ENERGIES AND REAL CONSTANTS
C   4   : MO ORDERING IN SCF
C   5   : MO ORDERING IN DRT
C   6   : MO CODE FOR CI
C   7   : MO CODE FOR MCSCF
C   8   : NUCLEAR CHARGE AND GEOMETRY
C   9   : AO-SO TRANSFORMATION MATRIX (RECT.)
C  10   : EIGENVALUES IN PITZER'S SCF (SQUA.)
C  11   : OCCUPATION IN PITZER'S SCF
C  12   : SO-MO EIGENVECTORS IN PITZER'S SCF (SQUA.)
C  13   : AO-MO EIGENVECTORS IN PITZER'S SCF (RECT.)
C  14   : SO OVERLAP INTEGRALS IN PITZER'S SCF (TRIA.)
C  15   : ONE ELECTRON SO INTEGRALS IN PITZER'S SCF (TRIA.)
C  16   : ONE ELECTRON MO INTEGRALS IN PITZER'S SCF (TRIA.)
C  17   : EIGENVALUES IN SORTED SCF
C  18   : OCCUPATION IN SORTED SCF
C  19   : SO-MO EIGENVECTORS IN SORTED SCF (SQUA.)
C  20   : AO-MO EIGENVECTORS IN SORTED SCF (RECT.)
C  21   : SO OVERLAP INTEGRALS IN SORTED SCF (TRIA.)
C  22   : ONE ELECTRON SO INTEGRALS IN SORTED SCF (TRIA.)
C  23   : ONE ELECTRON MO INTEGRLAS IN SORTED SCF (TRIA.)
C  24   : LAGRANGIAN MATRIX FOR SCF IN AO BASIS (TRIA.)
C  25   : LAGRANGIAN MATRIX FOR SCF IN MO BASIS (TRIA.)
C  26   : K MATRIX FOR HIGH SPIN OPEN-SHELL SCF (TRIA.)
C  27   : FIRST ZETA MATRIX  FOR GENERALIZED OPEN-SHELL SCF (TRIA.)
C  28   : SECOND ZETA MATRIX FOR GENERALIZED OPEN-SHELL SCF (TRIA.)
C  29   : THIRD ZETA MATRIX  FOR GENERALIZED OPEN-SHELL SCF (TRIA.)
C  30   : FOURTH ZETA MATRIX FOR GENERALIZED OPEN-SHELL SCF (TRIA.)
C  31   : FIFTH ZETA MATRIX  FOR GENERALIZED OPEN-SHELL SCF (TRIA.)
C  32   : LAGRANGIAN MATRIX FOR CI IN AO BASIS (TRIA.)
C  33   : LAGRANGIAN MATRIX FOR CI IN MO BASIS (SQUA.)
C  34   : ONE PDM IN AO BASIS FOR CI (TRIA.)
C  35   : ONE PDM IN MO BASIS FOR CI (TRIA.)
C  36   : LAGRANGIAN MATRIX FOR MCSCF IN AO BASIS (TRIA.)
C  37   : LAGRANGIAN MATRIX FOR MCSCF IN MO BASIS (SQUA.)
C  38   : ONE PDM IN AO BASIS FOR MCSCF (TRIA.)
C  39   : ONE PDM IN MO BASIS FOR MCSCF (TRIA.)
C
      IADDR=LOCS(IADD)
      NSECTH=NSECT/2
      NLEN=LOCS(IADD+NSECTH)
      CALL RWRIT(MFILE,IA,NLEN,IADDR)
      RETURN
C
      ENTRY MREAD(IA,IADD)
C
      IADDR=LOCS(IADD)
      NSECTH=NSECT/2
      NLEN=LOCS(IADD+NSECTH)
      CALL RREAD(MFILE,IA,NLEN,IADDR)
      RETURN
      END
      SUBROUTINE INIT47
C
C   THIS PROGRAM INTIALIZES USEAGE OF TAPE 47
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/LOC47/LOCS(192)
      COMMON/T47SEC/ITAP47
C
C   DEFINE CONSTANTS
      ITAP47=47
C
C   FIND LOCATIONS OF PARAMETERS AND MATRICES IN THE 47 FILE
      CALL RFILE(ITAP47)
      CALL WREADW(ITAP47,LOCS,192,1,JUNK)
CC    WRITE (*,*) LOCS
C
  201 CONTINUE
      RETURN
      END
      SUBROUTINE WT47(IA,IADD)
      IMPLICIT INTEGER (A-Z)
      DIMENSION IA(1)
      COMMON/LOC47/LOCS(192)
      COMMON/T47SEC/ITAP47
C
C   NO.  :  CONTENTS
C    TRIA. = TRIANGLE
C    SQUA. = SQUARE MATRIX
C    RECT. = RECTANGULAR MATRIX
C    1   : PARAMETERS(1-100),LOCATIONS(101-142),LENGTHS(151-192)
C    2   : LORD
C    3   : EIGENVALUES
C    4   : FOCC
C    5   : NSORB
C    6   : ALPHA (TRIA.)
C    7   : BETA  (TRIA.)
C    8   : SO-AO EIGENVECTORS IN PITZER'S SCF (SQUA.)
C    9   : SO-MO EIGENVECTORS IN PITZER'S SCF (SQUA.)
C   10   : AO-MO EIGENVECTORS IN PITZER'S SCF (SQUA.)
C   11   : WMOT (TRIA.)
C   12   : WAO (TRIA.)
C   13   : CM
C   14   : DC (TRIA.)
C   15   : DO (TRIA.)
C   16   : DO2 (TRIA.)
C   17   : DROL
C   18   : SO-MO EIGENVECTORS IN EIGENVALUE ORDER (SQUA.)
C   19   : AO-MO EIGENVECTORS IN EIGENVALUE ORDER (SQUA.)
C   20   : X (MO CI LAGRANGIAN) (SQUA.)
C   21   : XAO (SYMMETRIZED AO CI LAGRANGIAN) (TRIA.)
C   22   : QAO (AO ONE PARTICLE DENSITY MATRIX) (TRIA.)
C   23   : QMO (MO ONE PARTICLE DENSITY MATRIX) (TRIA.)
C   24   : ZVECT (TRIA.)
C   25   : U (FIRST-ORDER CPHF COEFFICIENTS)
C   26   : FORCE MATRIX
C   27   : IJORD (TRIA.)
C   28   : HIJ (SQUARE)
C   29   : MO DERIVATIVE CI LAGRANGIAN (SQUA.)
C   30   : ELECTRONIC CONTRIBUTION TO CI GRADIENT (3*NAT)
C
      IADDR=LOCS(IADD+100)
      NLEN=LOCS(IADD+150)
      CALL WWRITW(ITAP47,IA,NLEN,IADDR,JUNK)
      RETURN
C
      ENTRY RT47(IA,IADD)
C
CC    WRITE(*,*) ' IADD  = ',IADD
      IADDR=LOCS(IADD+100)
      NLEN=LOCS(IADD+150)
CC    WRITE(*,*) ' IADDR= ',IADDR
CC    WRITE(*,*) ' NLEN = ',NLEN
      CALL WREADW(ITAP47,IA,NLEN,IADDR,JUNK)
      RETURN
      END
      SUBROUTINE PACK(I,J,K,L,IX,JA,JAA)
C
      IF(I-L) 202,201,202
C   (11/11)
  201 IX=1
      GO TO 230
  202 IF(J-L) 208,203,211
  203 IF(K-L) 205,204,205
C   (21/11)=(12/11)=(11/21)=(11/12)
  204 IX=4
      GO TO 230
  205 IF(I-K) 207,206,207
C   (21/21)=(21/12)=(12/21)=(12/12)
  206 IX=5
      GO TO 230
C   (31/21)=(31/12)=(13/21)=(13/12)=(21/31)=(21/13)=(12/31)=(12/13)
  207 IX=11
      GO TO 230
  208 IF(K-L) 210,209,210
C   (31/22)=(13/22)=(22/31)=(22/13)
  209 IX=8
      GO TO 230
C   (41/32)=(41/23)=(14/32)=(14/23)=(32/41)=(32/14)=(23/41)=(23/14)
  210 IX=14
      GO TO 230
  211 IF(I-J) 212,212,217
  212 IF(I-K) 213,213,214
C   (22/21)=(22/12)=(21/22)=(12/22)
  213 IX=3
      GO TO 230
  214 IF(K-L) 215,215,216
C   (22/11)=(11/22)
  215 IX=2
      GO TO 230
C   (33/21)=(33/12)=(21/33)=(12/33)
  216 IX=6
      GO TO 230
  217 IF(I-K) 218,218,219
C   (32/31)=(32/13)=(23/31)=(23/13)=(31/32)=(31/23)=(13/32)=(13/23)
  218 IX=9
      GO TO 230
  219 IF(J-K) 220,221,222
C   (42/31)=(42/13)=(24/31)=(24/13)=(31/42)=(31/24)=(13/42)=(13/24)
  220 IX=13
      GO TO 230
C   (32/21)=(32/12)=(23/21)=(23/12)=(21/32)=(21/23)=(12/32)=(12/23)
  221 IX=10
      GO TO 230
  222 IF(K-L) 223,223,224
C   (32/11)=(23/11)=(11/32)=(11/23)
  223 IX=7
      GO TO 230
C   (43/21)=(43/12)=(34/21)=(34/12)=(21/43)=(21/34)=(12/43)=(12/34)
  224 IX=12
C
  230 CONTINUE
      JA=4096*I+16*J+IX
      JAA=256*K+L
      RETURN
C
      ENTRY UNPACK(I,J,K,L,IX,JA,JAA)
      IX=MOD(JA,16)
      JC=JA/16
      J=MOD(JC,256)
      I=JC/256
      L=MOD(JAA,256)
      K=JAA/256
      RETURN
      END
      SUBROUTINE EIVOUT(A,B,NAD,NBD,M,N,IOUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*6 LINE(21)
      DIMENSION A(NAD,NBD),B(NAD)
      DATA LINE / 21*'------' /
    1 FORMAT(2X,10(7X,I5))
    2 FORMAT(2X,21A6)
    3 FORMAT(2X,I2,2X,10F12.7)
    4 FORMAT(/,6X,10F12.7)
    5 FORMAT(/)
C
      II=0
      JJ=0
  200 II=II+1
      JJ=JJ+1
      KK=10*JJ
      NN=N
      IF(N.GT.KK) NN=KK
      LL=2*(NN-II+1)+1
      WRITE(IOUT,1) (I,I=II,NN)
      WRITE(IOUT,2) (LINE(I),I=1,LL)
      DO 101 I=1,M
  101 WRITE(IOUT,3) I,(A(I,J),J=II,NN)
      WRITE(IOUT,4) (B(J),J=II,NN)
      IF(N.LE.KK) GO TO 201
      WRITE(IOUT,5)
      II=KK
      GO TO 200
  201 RETURN
      END
      SUBROUTINE FRQOUT(A,B,NAD,NBD,M,N,IOUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*6 LINE(21)
      DIMENSION A(NAD,NBD),B(NBD)
      DATA LINE / 21*'------' /
    1 FORMAT(2X,10(7X,I5))
    2 FORMAT(6X,10(4X,F8.2))
    3 FORMAT(2X,21A6)
    4 FORMAT(2X,I2,2X,10F12.7)
    5 FORMAT(/)
C
      II=0
      JJ=0
  200 II=II+1
      JJ=JJ+1
      KK=10*JJ
      NN=N
      IF(N.GT.KK) NN=KK
      LL=2*(NN-II+1)+1
      WRITE(IOUT,1) (I,I=II,NN)
      WRITE(IOUT,2) (B(I),I=II,NN)
      WRITE(IOUT,3) (LINE(I),I=1,LL)
      DO 101 I=1,M
      WRITE(IOUT,4) I,(A(I,J),J=II,NN)
  101 CONTINUE
      IF(N.LE.KK) GO TO 201
      WRITE(IOUT,5)
      II=KK
      GO TO 200
  201 RETURN
      END
      SUBROUTINE EBC(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NK,NJ)
C
      CALL ZERO(A,NI*NJ)
      CALL MXMB(B,1,NI,C,1,NK,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=0.0D+00
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(I,K)*C(K,J)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     KJ=JA
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T+B(IK)*C(KJ)
C     IK=IK+NI
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EBTC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NK,NJ)
C
      CALL ZERO(A,NI*NJ)
      CALL MXMB(B,NK,1,C,1,NK,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=0.0D+00
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(K,I)*C(K,J)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     KJ=JA
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T+B(KI)*C(KJ)
C     KI=KI+1
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EBCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NJ,NK)
C
      CALL ZERO(A,NI*NJ)
      CALL MXMB(B,1,NI,C,NJ,1,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=0.0D+00
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(I,K)*C(J,K)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     JK=J
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T+B(IK)*C(JK)
C     IK=IK+NI
C     JK=JK+NJ
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EBTCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NJ,NK)
C
      CALL ZERO(A,NI*NJ)
      CALL MXMB(B,NK,1,C,NJ,1,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=0.0D+00
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(K,I)*C(J,K)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     JK=J
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T+B(KI)*C(JK)
C     JK=JK+NJ
C     KI=KI+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EMBC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NK,NJ)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=0.0D+00
                DO 1 K=1,NK
                     T=T-B(I,K)*C(K,J)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     KJ=JA
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T-B(IK)*C(KJ)
C     IK=IK+NI
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EMBTC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NK,NJ)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=0.0D+00
                DO 1 K=1,NK
                     T=T-B(K,I)*C(K,J)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     KJ=JA
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T-B(KI)*C(KJ)
C     KI=KI+1
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EMBCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NJ,NK)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=0.0D+00
                DO 1 K=1,NK
                     T=T-B(I,K)*C(J,K)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     JK=J
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T-B(IK)*C(JK)
C     IK=IK+NI
C     JK=JK+NJ
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE EMBTCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NJ,NK)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=0.0D+00
                DO 1 K=1,NK
                     T=T-B(K,I)*C(J,K)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     JK=J
C     T=0.0D+00
C     DO 1 K=1,NK
C     T=T-B(KI)*C(JK)
C     JK=JK+NJ
C     KI=KI+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE APBC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NK,NJ)
C
      CALL MXMB(B,1,NI,C,1,NK,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=A(I,J)
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(I,K)*C(K,J)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     KJ=JA
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T+B(IK)*C(KJ)
C     IK=IK+NI
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE APBTC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NK,NJ)
C
      CALL MXMB(B,NK,1,C,1,NK,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=A(I,J)
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(K,I)*C(K,J)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     KJ=JA
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T+B(KI)*C(KJ)
C     KI=KI+1
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE APBCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NJ,NK)
C
      CALL MXMB(B,1,NI,C,NJ,1,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=A(I,J)
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(I,K)*C(J,K)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     JK=J
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T+B(IK)*C(JK)
C     IK=IK+NI
C     JK=JK+NJ
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE APBTCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NJ,NK)
C
      CALL MXMB(B,NK,1,C,NJ,1,A,1,NI,NI,NK,NJ)
C
CTJL  DO 3 I=1,NI
CTJL       DO 2 J=1,NJ
CTJL            T=A(I,J)
CTJL            DO 1 K=1,NK
CTJL                 T=T+B(K,I)*C(J,K)
CTJL1           CONTINUE
CTJL            A(I,J)=T
CTJL2      CONTINUE
CTJL3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     JK=J
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T+B(KI)*C(JK)
C     JK=JK+NJ
C     KI=KI+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE AMBC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NK,NJ)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=A(I,J)
                DO 1 K=1,NK
                     T=T-B(I,K)*C(K,J)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     KJ=JA
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T-B(IK)*C(KJ)
C     IK=IK+NI
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE AMBTC(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NK,NJ)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=A(I,J)
                DO 1 K=1,NK
                     T=T-B(K,I)*C(K,J)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     JA=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     KJ=JA
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T-B(KI)*C(KJ)
C     KI=KI+1
C     KJ=KJ+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C     JA=JA+NK
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE AMBCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NI,NK),C(NJ,NK)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=A(I,J)
                DO 1 K=1,NK
                     T=T-B(I,K)*C(J,K)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     DO 2 I=1,NI
C     IK=I
C     JK=J
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T-B(IK)*C(JK)
C     IK=IK+NI
C     JK=JK+NJ
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
      SUBROUTINE AMBTCT(A,B,C,NI,NK,NJ)
C
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION A(NI,NJ),B(NK,NI),C(NJ,NK)
C
      DO 3 I=1,NI
           DO 2 J=1,NJ
                T=A(I,J)
                DO 1 K=1,NK
                     T=T-B(K,I)*C(J,K)
    1           CONTINUE
                A(I,J)=T
    2      CONTINUE
    3 CONTINUE
      RETURN
C     END
C
C     DIMENSION A(1),B(1),C(1)
C
C     IJ=1
C     DO 3 J=1,NJ
C     KI=1
C     DO 2 I=1,NI
C     JK=J
C     T=A(IJ)
C     DO 1 K=1,NK
C     T=T-B(KI)*C(JK)
C     JK=JK+NJ
C     KI=KI+1
C   1 CONTINUE
C     A(IJ)=T
C     IJ=IJ+1
C   2 CONTINUE
C   3 CONTINUE
C     RETURN
      END
 
c The function dot has been removed from iomr so ESSL can be used
c on IBM's with vector and a fortran routine can be used on machines
c without vector.
 
      SUBROUTINE ATEBC(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NI,NK),C(NK,NJ)
C
      CALL ZERO(A,NJ*NI)
C
      CALL MXMB(B,1,NI,C,1,NK,A,NJ,1,NI,NK,NJ)
C
CTJL  DO 3 J=1,NJ
CTJL     DO 2 K=1,NK
CTJL        CKJ=C(K,J)
CTJL        IF (CKJ.EQ.0.0D+00) GO TO 2
CTJL        DO 1 I=1,NI
CTJL           A(J,I)=A(J,I)+B(I,K)*CKJ
CTJL1       CONTINUE
CTJL2    CONTINUE
CTJL3 CONTINUE
C
      RETURN
      END
      SUBROUTINE ATEMBC(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NI,NK),C(NK,NJ)
C
      CALL ZERO(A,NJ*NI)
C
      DO 3 J=1,NJ
         DO 2 K=1,NK
            CKJ=C(K,J)
            IF (CKJ.EQ.0.0D+00) GO TO 2
            DO 1 I=1,NI
               A(J,I)=A(J,I)-B(I,K)*CKJ
    1       CONTINUE
    2    CONTINUE
    3 CONTINUE
C
      RETURN
      END
      SUBROUTINE ATPBC(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NI,NK),C(NK,NJ)
C
      CALL MXMB(B,1,NI,C,1,NK,A,NJ,1,NI,NK,NJ)
C
CTJL  DO 3 J=1,NJ
CTJL     DO 2 K=1,NK
CTJL        CKJ=C(K,J)
CTJL        IF (CKJ.EQ.0.0D+00) GO TO 2
CTJL        DO 1 I=1,NI
CTJL           A(J,I)=A(J,I)+B(I,K)*CKJ
CTJL1       CONTINUE
CTJL2    CONTINUE
CTJL3 CONTINUE
C
      RETURN
      END
      SUBROUTINE ATMBC(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NI,NK),C(NK,NJ)
C
      DO 3 J=1,NJ
         DO 2 K=1,NK
            CKJ=C(K,J)
            IF (CKJ.EQ.0.0D+00) GO TO 2
            DO 1 I=1,NI
               A(J,I)=A(J,I)-B(I,K)*CKJ
    1       CONTINUE
    2    CONTINUE
    3 CONTINUE
C
      RETURN
      END
      SUBROUTINE ATPBCT(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NI,NK),C(NJ,NK)
C
      CALL MXMB(B,1,NI,C,NJ,1,A,NJ,1,NI,NK,NJ)
C
CTJL  DO 3 K=1,NK
CTJL     DO 2 J=1,NJ
CTJL        CJK=C(J,K)
CTJL        IF (CJK.EQ.0.0D+00) GO TO 2
CTJL        DO 1 I=1,NI
CTJL           A(J,I)=A(J,I)+B(I,K)*CJK
CTJL1       CONTINUE
CTJL2    CONTINUE
CTJL3 CONTINUE
C
      RETURN
      END
      SUBROUTINE APBCTT(A,B,C,NI,NK,NJ)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      REAL*8 A(NJ,NI),B(NK,NI),C(NJ,NK)
C
CTJL  CALL MXMB(B,1,NI,C,NK,1,A,NI,1,NI,NK,NJ)
C
      DO 3 K=1,NK
         DO 2 J=1,NJ
            CJK=C(J,K)
            IF (CJK.EQ.0.0D+00) GO TO 2
            DO 1 I=1,NI
               A(J,I)=A(J,I)+B(K,I)*CJK
    1       CONTINUE
    2    CONTINUE
    3 CONTINUE
C
      RETURN
      END
      SUBROUTINE ZERO(A,N)
C
      REAL*8 A(N)
C
clj011889 Why vxinit???
clj   NBYTES = 8 * N
clj   CALL VXINIT(A,0,NBYTES)
      DO 1 I=1,N
           A(I)=0.0D+00
   1  CONTINUE
C
      RETURN
      END
      SUBROUTINE IZERO(A,N)
C
      INTEGER A(N)
C
clj011889 Why vxinit???
clj   NBYTES = 4 * N
clj   CALL VXINIT(A,0,NBYTES)
      DO 1 I=1,N
           A(I)=0
    1 CONTINUE
C
      RETURN
      END
      SUBROUTINE GIVENS (NX,NROOTX,NJX,A,B,ROOT,VECT)
C     DOUBLE PRECISION VERSION BY MEL LEVY 8/72
C 62.3  GIVENS  -EIGENVALUES AND EIGENVECTORS BY THE GIVENS METHOD.
C     BY FRANKLIN PROSSER, INDIANA UNIVERSITY.
C     SEPTEMBER, 1967
C     CALCULATES EIGENVALUES AND EIGENVECTORS OF REAL SYMMETRIC MATRIX
C     STORED IN PACKED UPPER TRIANGULAR FORM.
C
C     THANKS ARE DUE TO F. E. HARRIS (STANFORD UNIVERSITY) AND H. H.
C     MICHELS (UNITED AIRCRAFT RESEARCH LABORATORIES) FOR EXCELLENT
C     WORK ON NUMERICAL DIFFICULTIES WITH EARLIER VERSIONS OF THIS
C     PROGRAM.
C
C     THE PARAMETERS FOR THE ROUTINE ARE...
C         NX     ORDER OF MATRIX
C         NROOTX NUMBER OF ROOTS WANTED.  THE NROOTX SMALLEST (MOST
C                 NEGATIVE) ROOTS WILL BE CALCULATED.  IF NO VECTORS
C                 ARE WANTED, MAKE THIS NUMBER NEGATIVE.
C         NJX    ROW DIMENSION OF VECT ARRAY.  SEE -VECT- BELOW.
C                 NJX MUST BE NOT LESS THAN NX.
C         A      MATRIX STORED BY COLUMNS IN PACKED UPPER TRIANGULAR
C                FORM, I.E. OCCUPYING NX*(NX+1)/2 CONSECUTIVE
C                LOCATIONS.
C         B      SCRATCH ARRAY USED BY GIVENS.  MUST BE AT LEAST
C                 NX*5 CELLS.
C         ROOT   ARRAY TO HOLD THE EIGENVALUES.  MUST BE AT LEAST
C                NROOTX CELLS LONG.  THE NROOTX SMALLEST ROOTS ARE
C                 ORDERED LARGEST FIRST IN THIS ARRAY.
C         VECT   EIGENVECTOR ARRAY.  EACH COLUMN WILL HOLD AN
C                 EIGENVECTOR FOR THE CORRESPONDING ROOT.  MUST BE
C                 DIMENSIONED WITH -NJX- ROWS AND AT LEAST -NROOTX-
C                 COLUMNS, UNLESS NO VECTORS
C                 ARE REQUESTED (NEGATIVE NROOTX).  IN THIS LATTER
C                 CASE, THE ARGUMENT VECT IS JUST A DUMMY, AND THE
C                 STORAGE IS NOT USED.
C                 THE EIGENVECTORS ARE NORMALIZED TO UNITY.
C
C     THE ARRAYS A AND B ARE DESTROYED BY THE COMPUTATION.  THE RESULTS
C     APPEAR IN ROOT AND VECT.
C     FOR PROPER FUNCTIONING OF THIS ROUTINE, THE RESULT OF A FLOATING
C     POINT UNDERFLOW SHOULD BE A ZERO.
C     TO CONVERT THIS ROUTINE TO DOUBLE PRECISION (E.G. ON IBM 360
C     MACHINES), BE SURE THAT ALL REAL VARIABLES AND FUNCTION
C     REFERENCES ARE PROPERLY MADE DOUBLE PRECISION.
C     THE VALUE OF -ETA- (SEE BELOW) SHOULD ALSO BE CHANGED, TO REFLECT
C     THE INCREASED PRECISION.
C
C     THE ORIGINAL REFERENCE TO THE GIVENS TECHNIQUE IS IN OAK RIDGE
C     REPORT NUMBER ORNL 1574 (PHYSICS), BY WALLACE GIVENS.
C     THE METHOD AS PRESENTED IN THIS PROGRAM CONSISTS OF FOUR STEPS,
C     ALL MODIFICATIONS OF THE ORIGINAL METHOD...
C     FIRST, THE INPUT MATRIX IS REDUCED TO TRIDIAGONAL FORM BY THE
C     HOUSEHOLDER TECHNIQUE (J. H. WILKINSON, COMP. J. 3, 23 (1960)).
C     THE ROOTS ARE THEN LOCATED BY THE STURM SEQUENCE METHOD (J. M.
C     ORTEGA (SEE REFERENCE BELOW).  THE VECTORS OF THE TRIDIAGONAL
C     FORM ARE THEN EVALUATED (J. H. WILKINSON, COMP. J. 1, 90 (1958)),
C     AND LAST THE TRIDIAGONAL VECTORS ARE ROTATED TO VECTORS OF THE
C     ORIGINAL ARRAY (FIRST REFERENCE).
C     VECTORS FOR DEGENERATE (OR NEAR-DEGENERATE) ROOTS ARE FORCED
C     TO BE ORTHOGONAL, USING A METHOD SUGGESTED BY B. GARBOW, ARGONNE
C     NATIONAL LABS (PRIVATE COMMUNICATION, 1964).  THE GRAM-SCHMIDT
C     PROCESS IS USED FOR THE ORTHOGONALIZATION.
C
C     AN EXCELLENT PRESENTATION OF THE GIVENS TECHNIQUE IS FOUND IN
C     J. M. ORTEGA-S ARTICLE IN -MATHEMATICS FOR DIGITAL COMPUTERS,-
C     VOLUME 2, ED. BY RALSTON AND WILF, WILEY (1967), PAGE 94.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DOUBLE PRECISION B(NX,5),A(1),ROOT(NROOTX),VECT(NJX,NROOTX)
      DOUBLE PRECISION ETA,THETA,DEL1,DELTA,SMALL,DELBIG,THETA1,TOLER
      DOUBLE PRECISION RPOWER,RPOW1,RAND1,FACTOR,ANORM,ALIMIT,SUM,TEMP
      DOUBLE PRECISION AK,ROOTL,ROOTX,TRIAL,F0,SAVE,AROOT
      DOUBLE PRECISION ELIM1,ELIM2
C
C ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C **  USERS PLEASE NOTE...
C **  THE FOLLOWING TWO PARAMETERS, ETA AND THETA, SHOULD BE ADJUSTED
C **  BY THE USER FOR HIS PARTICULAR MACHINE.
C **  ETA IS AN INDICATION OF THE PRECISION OF THE FLOATING POINT
C **  REPRESENTATION ON THE COMPUTER BEING USED (ROUGHLY 10**(-M),
C **  WHERE M IS THE NUMBER OF DECIMALS OF PRECISION ).
C **  THETA IS AN INDICATION OF THE RANGE OF NUMBERS THAT CAN BE
C **  EXPRESSED IN THE FLOATING POINT REPRESENTATION (ROUGHLY THE
C **  LARGEST NUMBER).
C **  SOME RECOMMENDED VALUES FOLLOW.
C **  FOR IBM 7094, UNIVAC 1108, ETC. (27-BIT BINARY FRACTION, 8-BIT
C **  BINARY EXPONENT), ETA=1.E-8, THETA=1.E37.
C **  FOR CONTROL DATA 3600 (36-BIT BINARY FRACTION, 11-BIT BINARY
C **  EXPONENT), ETA=1.E-11, THETA=1.E307.
C **  FOR CONTROL DATA 6600 (48-BIT BINARY FRACTION, 11-BIT BINARY
C **  EXPONENT), ETA=1.E-14, THETA=1.E307.
C **  FOR IBM 360/50 AND 360/65 DOUBLE PRECISION (56-BIT HEXADECIMAL
C **  FRACTION, 7-BIT HEXADECIMAL EXPONENT), ETA=1.E-16, THETA=1.E75.
C **
      THETA = 1.D75
      ETA = 1.D-16
C ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      DEL1=ETA/100.0D0
      DELTA=ETA**2*100.0D0
      SMALL=ETA**2/100.0D0
      DELBIG=THETA*DELTA/1000.0D0
      THETA1=1000.0D0/THETA
C     TOLER  IS A FACTOR USED TO DETERMINE IF TWO ROOTS ARE CLOSE
C     ENOUGH TO BE CONSIDERED DEGENERATE FOR PURPOSES OF ORTHOGONALI-
C     ZING THEIR VECTORS.  FOR THE MATRIX NORMED TO UNITY, IF THE
C     DIFFERENCE BETWEEN TWO ROOTS IS LESS THAN TOLER, THEN
C     ORTHOGONALIZATION WILL OCCUR.
      TOLER = ETA*100.
C
C     INITIAL VALUE FOR PSEUDORANDOM NUMBER GENERATOR... (2**23)-3
      RPOWER=8388608.0D0
      RPOW1 = RPOWER/2.
      RAND1=RPOWER-3.0D0
C
      N = NX
      NROOT = IABS(NROOTX)
      IF (NROOT.EQ.0) GO TO 1001
      IF (N-1) 1001,1003,105
1003  ROOT(1) = A(1)
      IF(NROOTX .GT. 0)VECT(1,1)=1.0D0
      GO TO 1001
105   CONTINUE
C     NSIZE    NUMBER OF ELEMENTS IN THE PACKED ARRAY
      NSIZE = (N*(N+1))/2
      NM1 = N-1
      NM2 = N-2
C
C     SCALE MATRIX TO EUCLIDEAN NORM OF 1.  SCALE FACTOR IS ANORM.
      FACTOR=0.0D-0
      DO 70 I=1,NSIZE
 70   FACTOR=DMAX1(FACTOR,DABS(A(I)))
      IF(FACTOR .NE. 0.0D0)GO TO 72
C     NULL MATRIX.  FIX UP ROOTS AND VECTORS, THEN EXIT.
      DO 78 I=1,NROOT
           IF (NROOTX.LT.0) GO TO 78
           DO 77 J=1,N
 77        VECT(J,I)=0.0D0
           VECT(I,I)=1.0D0
 78   ROOT(I)=0.0D0
      GO TO 1001
C
 72   ANORM=0.0D0
      J = 1
      K = 1
      DO 80 I=1,NSIZE
           IF (I.NE.J) GO TO 81
           ANORM=ANORM+(A(I)/FACTOR)**2/2.0D0
           K = K+1
           J = J+K
           GO TO 80
81         ANORM = ANORM + (A(I)/FACTOR)**2
80    CONTINUE
      ANORM=DSQRT(ANORM*2.0D0)*FACTOR
      DO 91 I=1,NSIZE
91    A(I) = A(I)/ANORM
      ALIMIT=1.0D-0
C
C     TRIDIA SECTION.
C     TRIDIAGONALIZATION OF SYMMETRIC MATRIX
      ID = 0
      IA = 1
      IF (NM2.EQ.0) GO TO 201
      DO 200  J=1,NM2
C     J       COUNTS ROW  OF A-MATRIX TO BE DIAGONALIZED
C     IA      START OF NON-CODIAGONAL ELEMENTS IN THE ROW
C     ID      INDEX OF CODIAGONAL ELEMENT ON ROW BEING CODIAGONALIZED.
           IA = IA+J+2
           ID = ID + J + 1
           JP2 = J+2
C     SUM SQUARES OF NON-CODIAGONAL ELEMENTS IN ROW J
           II = IA
           SUM=0.0D-0
           DO 100 I=JP2,N
                SUM = SUM + A(II)**2
100        II = II + I
           TEMP = A(ID)
           IF (SUM.GT.SMALL) GO TO 110
C     NO TRANSFORMATION NECESSARY IF ALL THE NON-CODIAGONAL
C     ELEMENTS ARE TINY.
           B(J,1) = TEMP
           A(ID)=0.0D0
           GO TO 200
C     NOW COMPLETE THE SUM OF OFF-DIAGONAL SQUARES
 110       SUM=DSQRT(SUM+TEMP**2)
C     NEW CODIAGONAL ELEMENT
           B(J,1)=-DSIGN(SUM,TEMP)
C     FIRST NON-ZERO ELEMENT OF THIS W-VECTOR
           B(J+1,2)=DSQRT((1.0D0+DABS(TEMP)/SUM)/2.0D0)
C     FORM REST OF THE W-VECTOR ELEMENTS
           TEMP=DSIGN(0.5D0/(B(J+1,2)*SUM),TEMP)
           II = IA
           DO 130 I=JP2,N
                B(I,2) = A(II)*TEMP
130        II = II + I
C     FORM P-VECTOR AND SCALAR.  P-VECTOR = A-MATRIX*W-VECTOR.
C     SCALAR = W-VECTOR*P-VECTOR.
           AK=0.0D0
C     IC      LOCATION OF NEXT DIAGONAL ELEMENT
           IC = ID + 1
           J1 = J + 1
           DO 190  I=J1,N
                JJ = IC
                TEMP=0.0D0
                DO 180  II=J1,N
C     I       RUNS OVER THE NON-ZERO P-ELEMENTS
C     II      RUNS OVER ELEMENTS OF W-VECTOR
                     TEMP = TEMP + B(II,2)*A(JJ)
C     CHANGE INCREMENTING MODE AT THE DIAGONAL ELEMENTS.
                     IF (II.LT.I) GO TO 210
                     JJ = JJ + II
                     GO TO 180
210                  JJ = JJ + 1
180             CONTINUE
C     BUILD UP THE K-SCALAR (AK)
                AK = AK + TEMP*B(I,2)
                B(I,1) = TEMP
C     MOVE IC TO TOP OF NEXT A-MATRIX -ROW-
190        IC = IC + I
C     FORM THE Q-VECTOR
           DO 150  I=J1,N
150        B(I,1) = B(I,1) - AK*B(I,2)
C     TRANSFORM THE REST OF THE A-MATRIX
C     JJ      START-1 OF THE REST OF THE A-MATRIX
           JJ = ID
C     MOVE W-VECTOR INTO THE OLD A-MATRIX LOCATIONS TO SAVE SPACE
C     I       RUNS OVER THE SIGNIFICANT ELEMENTS OF THE W-VECTOR
           DO 160  I=J1,N
                A(JJ) = B(I,2)
                DO 170  II=J1,I
                     JJ = JJ + 1
 170            A(JJ)=A(JJ)-2.0D0*(B(I,1)*B(II,2)+B(I,2)*B(II,1))
160        JJ = JJ + J
200   CONTINUE
C     MOVE LAST CODIAGONAL ELEMENT OUT INTO ITS PROPER PLACE
201   CONTINUE
      B(NM1,1) = A(NSIZE-1)
      A(NSIZE-1)=0.0D-0
C
C     STURM SECTION.
C     STURM SEQUENCE ITERATION TO OBTAIN ROOTS OF TRIDIAGONAL FORM.
C     MOVE DIAGONAL ELEMENTS INTO SECOND N ELEMENTS OF B-VECTOR.
C     THIS IS A MORE CONVENIENT INDEXING POSITION.
C     ALSO, PUT SQUARE OF CODIAGONAL ELEMENTS IN THIRD N ELEMENTS.
      JUMP=1
      DO 320 J=1,N
           B(J,2)=A(JUMP)
           B(J,3) = B(J,1)**2
320   JUMP = JUMP+J+1
      DO 310 I=1,NROOT
310   ROOT(I) = +ALIMIT
      ROOTL = -ALIMIT
C     ISOLATE THE ROOTS.  THE NROOT LOWEST ROOTS ARE FOUND, LOWEST FIRST
      DO 330 I=1,NROOT
C     FIND CURRENT -BEST- UPPER BOUND
           ROOTX = +ALIMIT
           DO 335 J=I,NROOT
 335       ROOTX=DMIN1(ROOTX,ROOT(J))
           ROOT(I) = ROOTX
C     GET IMPROVED TRIAL ROOT
 500       TRIAL=(ROOTL+ROOT(I))*0.5D0
           IF (TRIAL.EQ.ROOTL.OR.TRIAL.EQ.ROOT(I)) GO TO 330
C     FORM STURM SEQUENCE RATIOS, USING ORTEGA-S ALGORITHM (MODIFIED).
C     NOMTCH IS THE NUMBER OF ROOTS LESS THAN THE TRIAL VALUE.
           NOMTCH=N
           J=1
360        F0 = B(J,2) - TRIAL
370        CONTINUE
           IF(DABS(F0) .LT. THETA1)GO TO 380
           IF(F0 .GE. 0.0D0)NOMTCH=NOMTCH-1
           J = J + 1
           IF (J.GT.N) GO TO 390
C     SINCE MATRIX IS NORMED TO UNITY, MAGNITUDE OF B(J,3) IS LESS THAN
C     ONE, AND SINCE F0 IS GREATER THAN THETA1, OVERFLOW IS NOT POSSIBLE
C     AT THE DIVISION STEP.
           F0 = B(J,2) - TRIAL - B(J-1,3)/F0
           GO TO 370
380        J = J + 2
           NOMTCH = NOMTCH - 1
           IF (J.LE.N) GO TO 360
390        CONTINUE
C     FIX NEW BOUNDS ON ROOTS
           IF (NOMTCH.GE.I) GO TO 540
           ROOTL = TRIAL
           GO TO 500
540        ROOT(I) = TRIAL
           NOM = MIN0(NROOT,NOMTCH)
           ROOT(NOM) = TRIAL
           GO TO 500
330   CONTINUE
C     REVERSE THE ORDER OF THE EIGENVALUES, SINCE CUSTOM DICTATES
C     -LARGEST FIRST-.  THIS SECTION MAY BE REMOVED IF DESIRED WITHOUT
C     AFFECTING THE REMAINDER OF THE ROUTINE.
C     NRT = NROOT/2
C     DO 10 I=1,NRT
C     SAVE = ROOT(I)
C     NMIP1 = NROOT - I + 1
CC    ROOT(I) = ROOT(NMIP1)
C10   ROOT(NMIP1) = SAVE
C
C     TRIVEC SECTION.
C     EIGENVECTORS OF CODIAGONAL FORM
C807  CONTINUE
C     QUIT NOW IF NO VECTORS WERE REQUESTED.
      IF (NROOTX.LT.0) GO TO 1002
C     INITIALIZE VECTOR ARRAY.
      DO 15 I=1,N
           DO 15 J=1,NROOT
 15   VECT(I,J)=1.0D-0
      DO 700 I=1,NROOT
           AROOT = ROOT(I)
C     ORTHOGONALIZE IF ROOTS ARE CLOSE.
           IF (I.EQ.1) GO TO 710
C     THE ABSOLUTE VALUE IN THE NEXT TEST IS TO ASSURE THAT THE TRIVEC
C     SECTION IS INDEPENDENT OF THE ORDER OF THE EIGENVALUES.
           IF(DABS(ROOT(I-1)-AROOT) .LT. TOLER)GO TO 720
710        IA = -1
720        IA = IA + 1
           ELIM1 = A(1) - AROOT
           ELIM2 = B(1,1)
           JUMP = 1
           DO 750  J=1,NM1
                JUMP = JUMP+J+1
C     GET THE CORRECT PIVOT EQUATION FOR THIS STEP.
                IF(DABS(ELIM1) .LE. DABS(B(J,1)))GO TO 760
C     FIRST (ELIM1) EQUATION IS THE PIVOT THIS TIME.  CASE 1.
                B(J,2) = ELIM1
                B(J,3) = ELIM2
                B(J,4)=0.0D0
                TEMP = B(J,1)/ELIM1
                ELIM1 = A(JUMP) - AROOT - TEMP*ELIM2
                ELIM2 = B(J+1,1)
                GO TO 755
C     SECOND EQUATION IS THE PIVOT THIS TIME.  CASE 2.
760             B(J,2) = B(J,1)
                B(J,3) = A(JUMP) - AROOT
                B(J,4) = B(J+1,1)
                TEMP=1.0D0
                IF(DABS(B(J,1)) .GT. THETA1)TEMP=ELIM1/B(J,1)
                ELIM1 = ELIM2 - TEMP*B(J,3)
                ELIM2 = -TEMP*B(J+1,1)
C     SAVE FACTOR FOR THE SECOND ITERATION.
755             B(J,5) = TEMP
750        CONTINUE
           B(N,2) = ELIM1
           B(N,3)=0.0D-0
           B(N,4)=0.0D-0
           B(NM1,4)=0.0D-0
           ITER = 1
           IF (IA.NE.0) GO TO 801
C     BACK SUBSTITUTE TO GET THIS VECTOR.
790        L = N + 1
           DO 780 J=1,N
                L = L - 1
786             CONTINUE
                ELIM1=VECT(L,I)-VECT(L+1,I)*B(L,3)-VECT(L+2,I)*B(L,4)
C     IF OVERFLOW IS CONCEIVABLE, SCALE THE VECTOR DOWN.
C     THIS APPROACH IS USED TO AVOID MACHINE-DEPENDENT AND SYSTEM-
C     DEPENDENT CALLS TO OVERFLOW ROUTINES.
                IF(DABS(ELIM1) .GT. DELBIG)GO TO 782
                TEMP = B(L,2)
                IF(DABS(B(L,2)) .LT. DELTA)TEMP=DELTA
                VECT(L,I) = ELIM1/TEMP
                GO TO 780
C     VECTOR IS TOO BIG.  SCALE IT DOWN.
782             DO 784 K=1,N
784             VECT